// fun bar(x &[int]) int

fun main(arg1 int) int
  // a [int 3]
  // const K [int 3] = [10,20,30] // explicitly typed; type resolved by parse
  const K = [10,20,30] // ideally typed, resolved by type resolver
  // const b [int 3] = [
  //   0,
  //   1
  //   2,]

  // c = [0, 1, 2]
  // c[1] = 3

  // d = [10, c[1], 10]
  // d[1] = 4

  // mut e [int 3] = [10,11,12]
  // e[1] = 22
  //var f [int 3] = [100,101,102]
  // f = K // error: array type [int 3] is not assignable
  // g = K // error: array type [int 3] is not assignable
  // h[1] = 9

  // slices/refs of arrays
  h = &K           // &[int 3]
  cts1 = K[:]      // &[int 3]
  cts2 = K[0:]     // &[int 3]
  // cts3 = K[2:1] // error: invalid slice index: 2 > 1
  // cts4 = K[:4]  // error: index 4 out of bounds, slicing array of length 3
  cts5 = K[:2]     // &[int 2]
  cts6 = K[1:2]    // &[int 1]
  cts7 = K[2:2]    // &[int] -- runtime sized rather than [int 0] or nil
  rts1 = K[0:arg1] // &[int]
  cts8 = rts1[:2]  // &[int 2] -- upgrade to sized array type

  // error: cannot reference a reference
  //var r1 &int
  //r2 = &r1     // error: cannot reference a reference (type &int)
  //r3 = &gref   // error: cannot reference a reference (type &int)
  //global var gref &int

  cts8[0]

// one = 1



// fun invert(color [3]int) nil {
//   red = color[0]
//   // color[0] = 255 - color[0]
//   // color[1] = 255 - color[1]
//   // color[2] = 255 - color[2]
// }

// fun main() {
//   // x = i8(4)
//   color = [3]int(255, 30, 0)
//   // invert(color)
//   // x
//   color
// }


// multi-dimensional array
// color2 [3][2]int = [[255, 255], [30, 255], [0, 255]]

// // array of size defined by constant expression
// array [acap]int // == (0,0,0,0)
// acap = acap1
// acap1 = 4 * acap2
// acap2 = 2 as int8

// array = [4]int()  // == (0,0,0,0)

// slice = []int(1, 2, 3)
