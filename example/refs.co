// Questions
//
// Q: How is ownership managed?
// A: Single-owner by var
//
// Q: How is something allocated on the heap?
// A1: Explicitly with "Box(T(1,2)) -> Box<T>" (using context.allocator, Box approach)
// A2: Explicitly with "allocate(T(1,2)) -> *T" (using context.allocator, pointer approach)
//
// Q: How do you declare data immutable/read-only?
// A: With "const" keyword on var definition
//      Q: What about return values?
//      A: Function should return a ref ("&T") if the data can't be mutated.
//    +Implicitly by use (really just an optimization w/ no semantic impact.)
//
// Q: Is immutability of storage "infectious" on its data?
//    i.e. is the returned slice editable? "fun get_buf() &[]u8"
// A: Yes. It works for C, Rust, et al.
//

fun example
  a = IVec3()          // mutable IVec3 because storage is mutable
  const b = IVec3()    // immutable IVec3 because storage is immutable
  c = b                // mutable IVec3; b copied to c
  const d = [3](1,2,3) // immutable. array data stored in RO memory
  e = d                // mutable; d copied to e (array data stored on stack)
  //
  // but what about slices?
  const f = d[:]       // immutable slice pointing to RO memory
                       // C equiv: static const Slice f = { .ptr=&d, .len=3 }
  d[0] = 4             // invalid! can't modify RO memory! (C equiv: f.ptr[0]=4)
  // idea: Slices work like structs: they inherit constness
  //       i.e. C equiv of f's type is "struct { const int* ptr; uint len; }"


type IVec3
  x, y, z int

fun main() int
  fun volume(v &IVec3) int -> v.x * v.y * v.z
  a = IVec3(1, 2, 3) // allocated on stack; "a" is current owner
  b = &a             // "b" has a ref to "a"; type of "b" is "mut &IVec3" since "a" is mutable
  c = a              // ownership transfers to "c" (TODO: is "a" invalid now? or a ref?)
  d = volume(c)      // automatic referencing "&c" of argument
  return d
  // "c" goes out of scope; implicit "drop(c)" freeing the IVec3 since "c" is its owner
  // "b" goes out of scope
  // "a" goes out of scope

// examples
fun resolve(n Node) Node   // takes ownership of n, gives ownership of Node
fun set_const(n &mut Node) // borrows n read-write, mutates n
fun fmt_node(n &Node) str  // borrows n read-only, gives ownership of str
fun get_name(n &Node) &str // borrows n read-only, returns read-only ref to str
fun get_buf(n &mut Node) &mut []u8

// signatures
fun i1(v IVec3)      // callee is given ownership
fun i2(v &IVec3)     // callee is lent a read-only reference
fun i3(v &mut IVec3) // callee is lent a mutable reference

fun o1() IVec3       // caller is given ownership
fun o2() &IVec3      // caller is lent a read-only reference
fun o3() &mut IVec3  // caller is lent a mutable reference

// What about strings?
// A string literal is of what type?
s = "foo" // "str" or "&str"?
// It would be nice to support mutable strings.
// Maybe "str" is an alias for "[]u8"
// and string literals become eg "[3]u8('f','o','o')",
// then the same mutability rules can be applied as for arrays.
const s2 = "foo" // immutable == const s2 = [3]u8('f','o','o')
s3 = "foo"       // mutable   == s3 = [3]u8('f','o','o')
print("hello")   // const tmp = "[5]u8('h','e'...)" passed as "&[]u8" aka "&str"
