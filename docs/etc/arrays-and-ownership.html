<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Arrays</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="/style.css?0">
</head>
<body>
<h1><a id="arrays" class="anchor" aria-hidden="true" href="#arrays"></a>Arrays</h1>
<h2><a id="when-and-why-do-we-need-arrays" class="anchor" aria-hidden="true" href="#when-and-why-do-we-need-arrays"></a>When and why do we need arrays?</h2>
<p>Okay so it's pretty nice to be able to make lists of stuff:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>make_stuff</span><span /class="hl-params"/g>(count <span /class="hl-type"/g>uint</span>)</span></span> [Stuff]
  <span /class="hl-keyword"/g>var</span> stuffs [Stuff] = calloc(count, Stuff)
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; stuffs.cap; i++
    stuffs[stuffs.len++].somefield = i
  stuffs
</code></pre>
<p>In this example, it's important to...</p>
<ul>
<li>allocate memory on the heap as <code>count</code> might be very large</li>
<li>avoid copying the returned data; we should return a pointer</li>
<li>make owership of heap memory clear. In this case <code>stuffs</code> is initially owned
by the <code>make_stuff</code> body block and then when it returns, ownership is transferred
to the caller.</li>
</ul>
<h3><a id="fixed-size-arrays" class="anchor" aria-hidden="true" href="#fixed-size-arrays"></a>Fixed-size arrays</h3>
<p>Fixed-size arrays is contiguous memory the size of multiple instances
of its elemental type. For example <code>[i32 3]</code> is 12 bytes of memory.</p>
<p>Fixed-size arrays are useful as temporary storage for compile-time bounded loops
and for expressing uniform data like a vector.</p>
<pre><code class="language-co">items = [<span /class="hl-number"/g>1</span>, <span /class="hl-number"/g>2</span>, <span /class="hl-number"/g>3</span>] <span /class="hl-comment"/g>// [int 3] in global memory</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>vec2</span><span /class="hl-params"/g>(x, y <span /class="hl-type"/g>f32</span>)</span></span> [<span /class="hl-type"/g>f32</span> <span /class="hl-number"/g>2</span>]
  <span /class="hl-keyword"/g>var</span> p [<span /class="hl-type"/g>f32</span> <span /class="hl-number"/g>2</span>]
  p[<span /class="hl-number"/g>0</span>], p[<span /class="hl-number"/g>1</span>] = x, y
  p <span /class="hl-comment"/g>// copied to caller</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>dot</span><span /class="hl-params"/g>(p1 [<span /class="hl-type"/g>f32</span> 2], p2 [<span /class="hl-type"/g>f32</span> 2])</span></span> <span /class="hl-type"/g>f32</span>
  p1[<span /class="hl-number"/g>0</span>]*p2[<span /class="hl-number"/g>0</span>] + p1[<span /class="hl-number"/g>1</span>]*p2[<span /class="hl-number"/g>1</span>]

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>moving_avg</span><span /class="hl-params"/g>(n <span /class="hl-type"/g>int</span>, f <span /class="hl-funtype"/g><span /class="hl-type"/g>fun</span><span /class="hl-params"/g>(i <span /class="hl-type"/g>int</span>)</span></span><span /class="hl-type"/g>f64</span>)</span></span> <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>var</span> win [<span /class="hl-type"/g>f64</span> <span /class="hl-number"/g>10</span>] <span /class="hl-comment"/g>// workset, 10× f64 allocated on stack</span>
  <span /class="hl-keyword"/g>var</span> avg <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>var</span> sum <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; n; i++
    val = f(i)
    sum = sum - win[i % win.len] + val
    win[i % win.len] = val
    avg = sum / <span /class="hl-type"/g>f64</span>(win.len)
  avg
</code></pre>
<p>Constant (immutable, read-only) fixed-size arrays are stored in global constant memory
and are in many cases elided at compile time, depending on use.
Mutable fixed-size arrays use local (e.g. stack) memory inside functions and global
writable memory when defined at the package level.</p>
<p>Assigning, returning or passing fixed-size arrays as function arguments creates
copies, just like with any other value in Co.
i.e. in <code>x = [1,2,3]; y = x</code>, y is a distinct copy of the array at <code>x</code>,
while <code>z</code> in <code>x = [1,2,3]; z = &amp;x</code> is a reference (pointer) to the same array as <code>x</code>.</p>
<p>Fixed-size arrays in Co can be created both in function scope (local memory, e.g. stack)
and at the package level (global memory.)
They can be both constant and mutable.
The type of fixed-size arrays is written as <code>[T n]</code>,
for example <code>[int 3]</code> for &quot;array of 3 ints&quot;</p>
<pre><code class="language-bnf"><span /class="hl-attribute"/g>FixedArrayType</span> <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;[&quot;</span> Type UIntLit <span /class="hl-string"/g>&quot;]&quot;</span>
</code></pre>
<h3><a id="variably-sized-arrays" class="anchor" aria-hidden="true" href="#variably-sized-arrays"></a>Variably-sized arrays</h3>
<p>These are useful when defining a function that accepts a variable number of items</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>sum</span><span /class="hl-params"/g>(xs &amp;[<span /class="hl-type"/g>f64</span>])</span></span> <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>var</span> sum <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; xs.len; i++
    sum += xs[i]
  <span /class="hl-keyword"/g>return</span> i
</code></pre>
<p>Here the function only really needs two things:</p>
<ol>
<li>a pointer to (possibly read-only) memory that contains f64 data</li>
<li>total number of f64 values at that pointer (length of array)</li>
</ol>
<p>Co uses a &quot;slice reference&quot; type for this, <code>&amp;[T]</code>.</p>
<p>Variably-sized arrays are also useful locally, for example to drop
the first element under some condition only known at runtime:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>compute_stuff</span><span /class="hl-params"/g>(nozero <span /class="hl-type"/g>bool</span>)</span></span>
  values = [<span /class="hl-number"/g>0</span>, <span /class="hl-number"/g>10</span>, <span /class="hl-number"/g>20</span>] <span /class="hl-comment"/g>// [int 3] on stack</span>
  xs = values[:]       <span /class="hl-comment"/g>// mut&amp;[int] — pointer to &#x27;values&#x27;</span>
  <span /class="hl-keyword"/g>if</span> nozero
    xs = xs[<span /class="hl-number"/g>1</span>:] <span /class="hl-comment"/g>// drop first value</span>
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; xs.len; i++
    compute_one(xs[i])
</code></pre>
<p>For this Co has slicing which works on all kinds of arrays.
Slicing a fixed-size array does not copy it but yields a reference
with a pointer to the array memory, number of valid entries (length)
and the capacity of the underlying array.</p>
<p>An array reference <code>&amp;[T]</code> or <code>mut&amp;[T]</code> is represented at runtime as
a structure with the following fields:</p>
<pre><code class="language-co"><span /class="hl-keyword"/g>struct</span> const_slice_ref {
  ptr _ptrtype
  len <span /class="hl-type"/g>uint</span> <span /class="hl-comment"/g>// number of valid entries at ptr</span>
}
<span /class="hl-keyword"/g>struct</span> mutable_slice_ref {
  ptr _ptrtype
  len <span /class="hl-type"/g>uint</span> <span /class="hl-comment"/g>// number of valid entries at ptr</span>
  cap <span /class="hl-type"/g>uint</span> <span /class="hl-comment"/g>// number of entries that can be stored at ptr</span>
}
</code></pre>
<p>The syntax for array references in Co is as follows:</p>
<pre><code class="language-bnf"><span /class="hl-attribute"/g>ArrayRef</span> <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;mut&quot;</span>? <span /class="hl-string"/g>&quot;&amp;&quot;</span> ArrayType
</code></pre>
<p>In fact, references is a generic feature of Co and so its syntax is
more correctly described as:</p>
<pre><code class="language-bnf"><span /class="hl-attribute"/g>Ref</span> <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;mut&quot;</span>? <span /class="hl-string"/g>&quot;&amp;&quot;</span> Type
</code></pre>
<h3><a id="dynamic-growing-arrays" class="anchor" aria-hidden="true" href="#dynamic-growing-arrays"></a>Dynamic &quot;growing&quot; arrays</h3>
<p>Sometimes arrays need to grow by bounds only known at runtime.
For example we might parse a CSV file into an array of row structures:</p>
<pre><code class="language-co"><span /class="hl-typedef"/g><span /class="hl-keyword"/g>type</span> <span /class="hl-title"/g>CSVRow</span> [&amp;[<span /class="hl-title"/g>u8</span>]]</span>
<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>parse_csv</span><span /class="hl-params"/g>(csvdata &amp;[<span /class="hl-type"/g>u8</span>], nrows_guess <span /class="hl-type"/g>uint</span>)</span></span>
  rows = calloc(nrows_guess, CSVRow) <span /class="hl-comment"/g>// [CSVRow] heap-allocated array</span>
  <span /class="hl-keyword"/g>for</span> csvdata.len &gt; <span /class="hl-number"/g>0</span>
    row, csvdata = parse_next_row(csvdata)
    <span /class="hl-keyword"/g>if</span> row.isValid
      rows.append(row)
  log(<span /class="hl-string"/g>&quot;parsed {rows.len} rows&quot;</span>)
</code></pre>
<p>Co accomplishes this with dynamic, growable arrays allocated on the heap
using the heap allocator function <code>alloc&lt;T type&gt;(typ T, count uint) T</code>.</p>
<p>This also enables us to return large arrays as function results without
the overhead of copying an array to the caller:</p>
<pre><code class="language-co"><span /class="hl-typedef"/g><span /class="hl-keyword"/g>type</span> <span /class="hl-title"/g>CSVRow</span> [&amp;[<span /class="hl-title"/g>u8</span>]]</span>
<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>parse_csv</span><span /class="hl-params"/g>(csvdata &amp;[<span /class="hl-type"/g>u8</span>], nrows_guess <span /class="hl-type"/g>uint</span>)</span></span> [CSVRow]
  rows = alloc(nrows_guess, CSVRow) <span /class="hl-comment"/g>// [CSVRow] heap-allocated array</span>
  <span /class="hl-keyword"/g>for</span> csvdata.len &gt; <span /class="hl-number"/g>0</span>
    row, csvdata = parse_next_row(csvdata)
    <span /class="hl-keyword"/g>if</span> row.isValid
      rows.append(row)
  rows
</code></pre>
<h3><a id="resource-ownership" class="anchor" aria-hidden="true" href="#resource-ownership"></a>Resource ownership</h3>
<p>Resource ownership rules in Co are simple:</p>
<ul>
<li>Storage locations own their data.</li>
<li>Ownership is transferred only for heap arrays. All other values are copied.</li>
<li>References are pointers to data owned by someone else.</li>
</ul>
<p>When a storage location goes out of scope it relinquishes its ownership by bing &quot;dropped&quot;.
When a value is dropped, any heap arrays are deallocated.
Any lingering references to a dropped value are invalid.
Accessing such a reference causes a &quot;safe crash&quot; by panicing in &quot;safe&quot; builds
and has undefined behavior in &quot;fast&quot; builds.</p>
<p>A &quot;storage location&quot; is a variable, struct field, tuple element,
array element or function parameter.</p>
<p>All data is passed by value in Co.
Note that references are memory addresses (an integer) and thus technically
copied when passed around.</p>
<hr>
<p>[WIP]</p>
<p>Heap allocations are relatively expensive and so it should be
possible to make use of the stack even for arrays that might grow.
For example the Co compiler makes use of the following pattern:</p>
<ul>
<li>allocate a small but common number of items on the stack</li>
<li>initialize an handle struct with a pointer to that memory and its capacity</li>
<li>append items<ul>
<li>when the capacity is reached, allocate more memory<ul>
<li>if memory points to the stack:<ul>
<li>allocate heap memory</li>
<li>copy existing data to it</li>
</ul>
</li>
<li>else the memory points to the heap:<ul>
<li>realloc</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>if memory points to the heap: free</li>
</ul>
<p>It may look something like this:</p>
<pre><code class="language-c"><span /class="hl-comment"/g>// C</span>
<span /class="hl-class"/g><span /class="hl-keyword"/g>struct</span> <span /class="hl-title"/g>tmparray</span> {</span> StuffResult* p; <span /class="hl-type"/g>int</span> cap; <span /class="hl-type"/g>int</span> len; };
StuffResult* <span /class="hl-title function_"/g>append</span><span /class="hl-params"/g>(tmparray* a)</span> {}
<span /class="hl-type"/g>int</span> <span /class="hl-title function_"/g>process_stuff</span><span /class="hl-params"/g>(Stuff stuff, StuffResult** resv)</span> {
  <span /class="hl-class"/g><span /class="hl-keyword"/g>struct</span> {</span> StuffResult* p; <span /class="hl-type"/g>int</span> cap; <span /class="hl-type"/g>int</span> len; } a;
  StuffResult a_st[<span /class="hl-number"/g>3</span>];
  a.p = a_st;
  a.cap = <span /class="hl-number"/g>3</span>;
  <span /class="hl-keyword"/g>while</span> (stuff_next(&amp;stuff)) {
    StuffResult* result = append(&amp;a);
    <span /class="hl-keyword"/g>if</span> (!stuff_dequeue(&amp;stuff, result))
      a.len--;
  }
}
</code></pre>
<h3><a id="arrays-as-function-results-wip" class="anchor" aria-hidden="true" href="#arrays-as-function-results-wip"></a>Arrays as function results [WIP]</h3>
<p>Sometimes we need to produce an array as the result of a function.
If we return a pointer to the callees stack its value will likely be
over written and thus be undefined</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>main</span><span /class="hl-params"/g>()</span></span>
  numbers = make_numbers()
  bar()
  <span /class="hl-comment"/g>// &#x27;numbers&#x27; invalid here!</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>make_numbers</span><span /class="hl-params"/g>()</span></span> [<span /class="hl-type"/g>int</span>]
  <span /class="hl-keyword"/g>var</span> numbers [StuffResult <span /class="hl-number"/g>3</span>]
  numbers[<span /class="hl-number"/g>0</span>] = <span /class="hl-number"/g>1</span>
  numbers[<span /class="hl-number"/g>1</span>] = <span /class="hl-number"/g>2</span>
  numbers[<span /class="hl-number"/g>2</span>] = <span /class="hl-number"/g>3</span>
  numbers
</code></pre>
<p>So we need to make sure that only arrays allocated on the stack can escape a
function's body</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>make_numbers</span><span /class="hl-params"/g>()</span></span> [<span /class="hl-type"/g>int</span>]
  numbers = calloc(<span /class="hl-number"/g>3</span>, <span /class="hl-type"/g>int</span>) <span /class="hl-comment"/g>// allocate 3 ints on the heap</span>
  numbers[<span /class="hl-number"/g>0</span>] = <span /class="hl-number"/g>1</span>
  <span /class="hl-comment"/g>// ...</span>
  numbers
</code></pre>
<hr>
<p>WORK IN PROGRESS</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>process_stuff</span><span /class="hl-params"/g>(stuff Stuff)</span></span> [StuffResult]
  <span /class="hl-keyword"/g>var</span> results [StuffResult] = calloc(<span /class="hl-number"/g>3</span>, StuffResult)
  <span /class="hl-keyword"/g>for</span> work in stuff.next()
    <span /class="hl-keyword"/g>if</span> result = work()
      results.append(result)
  results
</code></pre>
<p>It might seem common to pass temporary arrays as arguments ...</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>createFooConfig</span><span /class="hl-params"/g>(things &amp;[Thing])</span></span> FooConfig
<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>main</span><span /class="hl-params"/g>()</span></span>
  config = createFooConfig([Thing(), Thing()])
</code></pre>
<p>... but in practice &quot;rest&quot; argument syntax covers most of these cases:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>createFooConfig</span><span /class="hl-params"/g>(things ...&amp;[Thing])</span></span> FooConfig
<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>main</span><span /class="hl-params"/g>()</span></span>
  config = createFooConfig(Thing(), Thing())
</code></pre>
<h2><a id="notes" class="anchor" aria-hidden="true" href="#notes"></a>Notes</h2>
<ul>
<li><p>lit <code>[1,2,3]</code> might be better as a slice than array?</p>
</li>
<li><p>lits may be better as type constructors, ie <code>[int](1,2,3)</code> which would allow
expressing an array type context-free, ie <code>[x]</code> is unambiguously an array type
rather than &quot;array literal in some places and array type in other places.&quot;</p>
</li>
</ul>
<h2><a id="type-model-ideas" class="anchor" aria-hidden="true" href="#type-model-ideas"></a>Type model ideas</h2>
<table>
<thead>
<tr>
<th>Owning T</th>
<th>Borrowed T</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[int 3]</td>
<td>&amp;[int 3]</td>
<td>Fixed Array</td>
</tr>
<tr>
<td>[int]</td>
<td>&amp;[int]</td>
<td>Slice of fixed Array</td>
</tr>
<tr>
<td>[int *]</td>
<td>&amp;[int *]</td>
<td>Dynamic array</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Owning T</th>
<th>Borrowed T</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[int 3]</td>
<td>&amp;[int 3]</td>
<td>Fixed Array or slice thereof</td>
</tr>
<tr>
<td>[int]</td>
<td>&amp;[int]</td>
<td>Dynamic array or slice thereof</td>
</tr>
</tbody>
</table>

</body>
</html>
