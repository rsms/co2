<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Arrays</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="/style.css?0">
</head>
<body>
<h1><a id="arrays" class="anchor" aria-hidden="true" href="#arrays"></a>Arrays</h1>
<p>Co has three constructs for dealing with arrays of values:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[T n]</code></td>
<td><a href="fixed-size-arrays">Fixed-size arrays</a> for local and global data</td>
</tr>
<tr>
<td><code>[T]</code></td>
<td><a href="#dynamic-arrays">Dynamic arrays</a> that grow at runtime and can change owners. This is the foundation for—and the only way to—allocate heap memory.</td>
</tr>
<tr>
<td><code>&amp;[T]</code></td>
<td><a href="#array-references-slices">Array references &amp; slices</a> for referring to arrays</td>
</tr>
</tbody>
</table>
<!-- - `[T n] ` [Fixed-size arrays](fixed-size-arrays) for local and global data
- `[T]   ` [Dynamic arrays](#dynamic-arrays) that grow at runtime and can change owners
- `&[T]  ` [Array references & slices](#array-references-slices) for referring to arrays -->
<h4><a id="a-quick-example" class="anchor" aria-hidden="true" href="#a-quick-example"></a>A quick example</h4>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>make_stuff</span><span /class="hl-params"/g>(count <span /class="hl-type"/g>uint</span>)</span></span> [Stuff]
  stuffs = calloc(count, Stuff) <span /class="hl-comment"/g>// [Stuff]</span>
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; stuffs.cap; i++
    stuffs.append(Stuff(i))
  stuffs <span /class="hl-comment"/g>// transfers ownership to caller</span>
</code></pre>
<p>In this example, it's important to...</p>
<ul>
<li>allocate memory on the heap as <code>count</code> might be very large</li>
<li>avoid copying the returned data; we should return a pointer</li>
<li>make owership of heap memory clear. In this case <code>stuffs</code> is initially owned
by the <code>make_stuff</code> body block and then when it returns, ownership is transferred
to the caller.</li>
</ul>
<h4><a id="language-grammar" class="anchor" aria-hidden="true" href="#language-grammar"></a>Language grammar</h4>
<pre><code class="language-bnf"><span /class="hl-attribute"/g>ArrayType</span>        <span /class="hl-operator"/g>=</span> FixedArrayType | DynamicArrayType
<span /class="hl-attribute"/g>FixedArrayType</span>   <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;[&quot;</span> Type ConstSizeExpr <span /class="hl-string"/g>&quot;]&quot;</span>
<span /class="hl-attribute"/g>DynamicArrayType</span> <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;[&quot;</span> Type <span /class="hl-string"/g>&quot;]&quot;</span>
<span /class="hl-attribute"/g>ArrayRefType</span>     <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;mut&quot;</span>? <span /class="hl-string"/g>&quot;&amp;&quot;</span> ArrayType
<span /class="hl-attribute"/g>ArrayLiteral</span>     <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;[&quot;</span> [ Expr (list_sep Expr)* list_sep? ] <span /class="hl-string"/g>&quot;]&quot;</span>
<span /class="hl-attribute"/g>list_sep</span>         <span /class="hl-operator"/g>=</span> <span /class="hl-string"/g>&quot;,&quot;</span> | <span /class="hl-string"/g>&quot;;&quot;</span>
</code></pre>
<h2><a id="fixed-size-arrays" class="anchor" aria-hidden="true" href="#fixed-size-arrays"></a>Fixed-size arrays</h2>
<p>Fixed-size arrays is contiguous memory the size of multiple instances
of its elemental type. The size of a fixed-size array is part of its type and thus
a compile-time constant.
For example <code>[i32 3]</code> is 12 bytes of memory; three 32-bit integers.</p>
<p>Fixed-size arrays are useful as temporary storage for compile-time bounded loops
and for expressing uniform data like a vector.</p>
<pre><code class="language-co">items = [<span /class="hl-number"/g>1</span>, <span /class="hl-number"/g>2</span>, <span /class="hl-number"/g>3</span>] <span /class="hl-comment"/g>// [int 3] in global memory</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>vec2</span><span /class="hl-params"/g>(x, y <span /class="hl-type"/g>f32</span>)</span></span> [<span /class="hl-type"/g>f32</span> <span /class="hl-number"/g>2</span>]
  <span /class="hl-keyword"/g>var</span> p [<span /class="hl-type"/g>f32</span> <span /class="hl-number"/g>2</span>]
  p[<span /class="hl-number"/g>0</span>], p[<span /class="hl-number"/g>1</span>] = x, y
  p <span /class="hl-comment"/g>// copied to caller</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>dot</span><span /class="hl-params"/g>(p1 [<span /class="hl-type"/g>f32</span> 2], p2 [<span /class="hl-type"/g>f32</span> 2])</span></span> <span /class="hl-type"/g>f32</span>
  p1[<span /class="hl-number"/g>0</span>]*p2[<span /class="hl-number"/g>0</span>] + p1[<span /class="hl-number"/g>1</span>]*p2[<span /class="hl-number"/g>1</span>]

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>moving_avg</span><span /class="hl-params"/g>(n <span /class="hl-type"/g>int</span>, f <span /class="hl-funtype"/g><span /class="hl-type"/g>fun</span><span /class="hl-params"/g>(i <span /class="hl-type"/g>int</span>)</span></span><span /class="hl-type"/g>f64</span>)</span></span> <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>var</span> win [<span /class="hl-type"/g>f64</span> <span /class="hl-number"/g>10</span>] <span /class="hl-comment"/g>// workset, 10× f64 allocated on stack</span>
  <span /class="hl-keyword"/g>var</span> avg <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>var</span> sum <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; n; i++
    val = f(i)
    sum = sum - win[i % win.len] + val
    win[i % win.len] = val
    avg = sum / <span /class="hl-type"/g>f64</span>(win.len)
  avg
</code></pre>
<p>Constant (immutable, read-only) fixed-size arrays are stored in global constant memory
and are in many cases elided at compile time, depending on use.
Mutable fixed-size arrays use local (e.g. stack) memory inside functions and global
writable memory when defined at the package level.</p>
<p>Assigning, returning or passing fixed-size arrays as function arguments creates
copies, just like with any other value in Co.
i.e. in <code>x = [1,2,3]; y = x</code>, y is a distinct copy of the array at <code>x</code>,
while <code>z</code> in <code>x = [1,2,3]; z = &amp;x</code> is a reference (pointer) to the same array as <code>x</code>.</p>
<p>Fixed-size arrays in Co can be created both in function scope (local memory, e.g. stack)
and at the package level (global memory.)
They can be both constant and mutable.
The type of fixed-size arrays is written as <code>[T n]</code>,
for example <code>[int 3]</code> for &quot;array of 3 ints&quot;</p>
<h2><a id="array-references-slices" class="anchor" aria-hidden="true" href="#array-references-slices"></a>Array references &amp; slices</h2>
<p>Co features &quot;references&quot; as a way to share values without making copies.
References does not constitute ownership of data but is merely a borrowed handle.
References are like pointers in C with some additional compile-time semantics to
help you discern ownership.</p>
<p>References to arrays support slicing; the ability to share a smaller
range of an array.</p>
<pre><code class="language-co">x = [<span /class="hl-number"/g>1</span>, <span /class="hl-number"/g>2</span>, <span /class="hl-number"/g>3</span>, <span /class="hl-number"/g>4</span>, <span /class="hl-number"/g>5</span>] <span /class="hl-comment"/g>// type [int 5]</span>
            <span /class="hl-comment"/g>// RESULT              TYPE         VALUE</span>
a = x       <span /class="hl-comment"/g>// copy of x           [int 5]      1,2,3,4,5</span>
b = x[<span /class="hl-number"/g>1</span>:<span /class="hl-number"/g>4</span>]  <span /class="hl-comment"/g>// copy of slice of x  [int 3]      2,3,4</span>
c = b[<span /class="hl-number"/g>1</span>:]   <span /class="hl-comment"/g>// copy of slice of x  [int 2]      3,4</span>
d = &amp;x      <span /class="hl-comment"/g>// reference to x      mut&amp;[int 5]  1,2,3,4,5</span>
e = &amp;x[<span /class="hl-number"/g>1</span>:<span /class="hl-number"/g>4</span>] <span /class="hl-comment"/g>// ref to slice of x   mut&amp;[int 3]  2,3,4</span>
f = &amp;e[<span /class="hl-number"/g>1</span>:]  <span /class="hl-comment"/g>// ref to slice of x   mut&amp;[int 2]  3,4</span>
</code></pre>
<p>Array references are useful when defining a function that accepts a variable
number of items which it only needs to read:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>sum</span><span /class="hl-params"/g>(xs &amp;[<span /class="hl-type"/g>f64</span>])</span></span> <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>var</span> sum <span /class="hl-type"/g>f64</span>
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; xs.len; i++
    sum += xs[i]
  <span /class="hl-keyword"/g>return</span> i
</code></pre>
<p>The function in the above example receives a tuple of two values:</p>
<ol>
<li>a pointer to memory that contains f64 data (array data)</li>
<li>count of valid values at the memory location (length of array)</li>
</ol>
<p>Co uses a &quot;slice reference&quot; type for this, <code>&amp;[T]</code>, which is a tuple
of pointer &amp; length. More on this in a minute.</p>
<p>Variably-sized arrays are also useful locally, for example to drop
the first element under some condition only known at runtime:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>compute_stuff</span><span /class="hl-params"/g>(nozero <span /class="hl-type"/g>bool</span>)</span></span>
  values = [<span /class="hl-number"/g>0</span>, <span /class="hl-number"/g>10</span>, <span /class="hl-number"/g>20</span>] <span /class="hl-comment"/g>// [int 3] on stack</span>
  xs = values[:]       <span /class="hl-comment"/g>// mut&amp;[int] — pointer to &#x27;values&#x27;</span>
  <span /class="hl-keyword"/g>if</span> nozero
    xs = xs[<span /class="hl-number"/g>1</span>:] <span /class="hl-comment"/g>// drop first value</span>
  <span /class="hl-keyword"/g>for</span> i = <span /class="hl-number"/g>0</span>; i &lt; xs.len; i++
    compute_one(xs[i])
</code></pre>
<p>Slicing works on all kinds of arrays.
Slicing a fixed-size array does not copy it but yields a reference
with a pointer to the array memory, number of valid entries (length)
and the capacity of the underlying array.</p>
<p>An array reference <code>&amp;[T]</code> or <code>mut&amp;[T]</code> is represented at runtime as
a structure with the following fields:</p>
<pre><code class="language-co"><span /class="hl-keyword"/g>struct</span> const_slice_ref {
  ptr memaddr <span /class="hl-comment"/g>// pointer to data</span>
  len <span /class="hl-type"/g>uint</span>    <span /class="hl-comment"/g>// number of valid entries at ptr</span>
}
<span /class="hl-keyword"/g>struct</span> mutable_slice_ref {
  ptr memaddr <span /class="hl-comment"/g>// pointer to data</span>
  len <span /class="hl-type"/g>uint</span>    <span /class="hl-comment"/g>// number of valid entries at ptr</span>
  cap <span /class="hl-type"/g>uint</span>    <span /class="hl-comment"/g>// number of entries that can be stored at ptr</span>
}
</code></pre>
<h2><a id="dynamic-arrays" class="anchor" aria-hidden="true" href="#dynamic-arrays"></a>Dynamic arrays</h2>
<p>Sometimes arrays need to grow by bounds only known at runtime.
Dynamic arrays has a length and capacity which can vary at runtime.
Dynamic arrays can grow and are allocated on the heap.
Dynamic array's data is not copied when passed around, instead its ownerhip transfers.</p>
<p>For example we might parse a CSV file into an array of row structures:</p>
<pre><code class="language-co"><span /class="hl-typedef"/g><span /class="hl-keyword"/g>type</span> <span /class="hl-title"/g>CSVRow</span> [&amp;[<span /class="hl-title"/g>u8</span>]]</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>parse_csv</span><span /class="hl-params"/g>(csvdata &amp;[<span /class="hl-type"/g>u8</span>], nrows_guess <span /class="hl-type"/g>uint</span>)</span></span>
  rows = alloc(CSVRow, nrows_guess) <span /class="hl-comment"/g>// [CSVRow] heap-allocated array</span>
  <span /class="hl-keyword"/g>for</span> csvdata.len &gt; <span /class="hl-number"/g>0</span>
    row, csvdata = parse_next_row(csvdata)
    <span /class="hl-keyword"/g>if</span> row.isValid
      rows.append(row)
  log(<span /class="hl-string"/g>&quot;parsed {rows.len} rows&quot;</span>)
  <span /class="hl-comment"/g>// &#x27;rows&#x27; deallocated here as its storage goes out of scope</span>
</code></pre>
<p>Co accomplishes this with dynamic, growable arrays allocated on the heap
using the heap allocator function <code>alloc&lt;T type&gt;(typ T, count uint) T</code>.</p>
<p>This also enables us to return large arrays as function results without
the overhead of copying an array to the caller:</p>
<pre><code class="language-co"><span /class="hl-typedef"/g><span /class="hl-keyword"/g>type</span> <span /class="hl-title"/g>CSVRow</span> [&amp;[<span /class="hl-title"/g>u8</span>]]</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>parse_csv</span><span /class="hl-params"/g>(csvdata &amp;[<span /class="hl-type"/g>u8</span>], nrows_guess <span /class="hl-type"/g>uint</span>)</span></span> [CSVRow]
  rows = alloc(CSVRow, nrows_guess) <span /class="hl-comment"/g>// [CSVRow] heap-allocated array</span>
  <span /class="hl-keyword"/g>for</span> csvdata.len &gt; <span /class="hl-number"/g>0</span>
    row, csvdata = parse_next_row(csvdata)
    <span /class="hl-keyword"/g>if</span> row.isValid
      rows.append(row)
  rows <span /class="hl-comment"/g>// ownership moves to caller</span>

<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> main</span>
  rows = parse_csv(csvdata, <span /class="hl-number"/g>32</span>)
  <span /class="hl-comment"/g>// &#x27;rows&#x27; deallocated here as its storage goes out of scope</span>
</code></pre>
<h3><a id="idea-stack-storage-optimization-of-dynamic-arrays" class="anchor" aria-hidden="true" href="#idea-stack-storage-optimization-of-dynamic-arrays"></a>Idea: Stack-storage optimization of dynamic arrays</h3>
<p>Heap allocations are relatively expensive and so it should be
possible to make use of the stack even for arrays that grows.</p>
<p>The Co compiler, written in C, makes use of the following pattern:</p>
<ul>
<li>allocate a small but common number of items on the stack</li>
<li>initialize a &quot;handle struct&quot; with a pointer to that memory and its capacity</li>
<li>append items<ul>
<li>when the capacity is reached, allocate more memory<ul>
<li>if memory points to the stack:<ul>
<li>allocate heap memory</li>
<li>copy existing data to it</li>
</ul>
</li>
<li>else the memory points to the heap:<ul>
<li>realloc</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>if memory points to the heap: free</li>
</ul>
<p>It looks something like this in C:</p>
<pre><code class="language-c"><span /class="hl-comment"/g>// C</span>
<span /class="hl-class"/g><span /class="hl-keyword"/g>struct</span> <span /class="hl-title"/g>tmparray</span> {</span> Thing* p; <span /class="hl-type"/g>void</span>* initp; <span /class="hl-type"/g>int</span> cap; <span /class="hl-type"/g>int</span> len; };
<span /class="hl-type"/g>void</span> <span /class="hl-title function_"/g>grow</span><span /class="hl-params"/g>(tmparray* a)</span> {
  a-&gt;cap *= <span /class="hl-number"/g>2</span>;
  <span /class="hl-keyword"/g>if</span> (a-&gt;p == a-&gt;initp) {
    <span /class="hl-comment"/g>// move from stack to heap</span>
    a-&gt;p = <span /class="hl-built_in"/g>malloc</span>(<span /class="hl-keyword"/g>sizeof</span>(Thing) * a-&gt;cap);
    <span /class="hl-built_in"/g>memcpy</span>(a-&gt;p, a-&gt;initp, <span /class="hl-keyword"/g>sizeof</span>(Thing) * a-&gt;len);
  } <span /class="hl-keyword"/g>else</span> {
    a-&gt;p = <span /class="hl-built_in"/g>realloc</span>(a-&gt;p, <span /class="hl-keyword"/g>sizeof</span>(Thing) * a-&gt;cap);
  }
}
<span /class="hl-type"/g>void</span> <span /class="hl-title function_"/g>push</span><span /class="hl-params"/g>(tmparray* a, Thing thing)</span> {
  <span /class="hl-keyword"/g>if</span> (a-&gt;len == a-&gt;cap)
    grow(a);
  a-&gt;p[a-&gt;len++] = thing;
}
<span /class="hl-type"/g>void</span> <span /class="hl-title function_"/g>build_a_thing</span><span /class="hl-params"/g>(Thing* v, <span /class="hl-type"/g>int</span> c)</span>;
<span /class="hl-type"/g>int</span> <span /class="hl-title function_"/g>process_stuff</span><span /class="hl-params"/g>(Stuff stuff)</span> {
  Thing a_st[<span /class="hl-number"/g>3</span>];
  <span /class="hl-class"/g><span /class="hl-keyword"/g>struct</span> <span /class="hl-title"/g>tmparray</span> <span /class="hl-title"/g>a</span> =</span> { .p=a_st, .initp=a_st, .cap=<span /class="hl-number"/g>3</span> };
  Thing thing;
  <span /class="hl-keyword"/g>while</span> (stuff_next(&amp;thing)) {
    push(&amp;a, thing);
  }
  <span /class="hl-comment"/g>// use array of values</span>
  build_a_thing(a.p, a.len);
  <span /class="hl-keyword"/g>if</span> (a.p != a_st)
    <span /class="hl-built_in"/g>free</span>(a.p);
}
</code></pre>
<p>It would be nice if Co could somehow do this as an optimization for dynamic arrays.
Here's an example of what it could look like:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>process_stuff</span><span /class="hl-params"/g>(stuff Stuff)</span></span> [Thing]
  <span /class="hl-keyword"/g>var</span> a [Thing] <span /class="hl-comment"/g>// creates a &quot;default&quot; dynamic array</span>
  <span /class="hl-comment"/g>// an implicit array of some small size is allocated on</span>
  <span /class="hl-comment"/g>// the stack here and a is pointed to it.</span>
  <span /class="hl-keyword"/g>var</span> thing Thing
  <span /class="hl-keyword"/g>for</span> stuff_next(&amp;thing)
    a.append(thing) <span /class="hl-comment"/g>// may move a&#x27;s data to heap</span>
  build_a_thing(&amp;a)
  <span /class="hl-comment"/g>// a dropped here; if a&#x27;s data is on heap it is freed</span>
</code></pre>
<p>The implementation struct of <code>[T]</code> could look like this:</p>
<pre><code class="language-co"><span /class="hl-keyword"/g>struct</span> dynarray {
  ptr memaddr <span /class="hl-comment"/g>// pointer to data</span>
  ish <span /class="hl-type"/g>bool</span>    <span /class="hl-comment"/g>// true if ptr is in the heap</span>
  len <span /class="hl-type"/g>uint</span>    <span /class="hl-comment"/g>// number of valid entries at ptr</span>
  cap <span /class="hl-type"/g>uint</span>    <span /class="hl-comment"/g>// number of entries that can be stored at ptr</span>
}
</code></pre>
<hr>
<h2><a id="notes-thoughts" class="anchor" aria-hidden="true" href="#notes-thoughts"></a>Notes &amp; thoughts</h2>
<ul>
<li><p>Should lit <code>[1,2,3]</code> yield a <code>mut&amp;[int 3]</code> instead of <code>[int 3]</code>?
May be more useful if it did..?</p>
</li>
<li><p>Array lits may be better as type constructors, ie <code>[int](1,2,3)</code> which would allow
expressing an array type context-free, i.e. <code>[x]</code> is unambiguously an array type
rather than &quot;array literal in some places and array type in other places.&quot;</p>
</li>
</ul>
<h3><a id="rest-parameters-as-syntactic-sugar-for-fixed-size-arrays" class="anchor" aria-hidden="true" href="#rest-parameters-as-syntactic-sugar-for-fixed-size-arrays"></a>Rest parameters as syntactic sugar for fixed-size arrays</h3>
<p>It nice to pass temporary arrays as arguments:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>create_config</span><span /class="hl-params"/g>(somearg <span /class="hl-type"/g>int</span>, things &amp;[Thing])</span></span> FooConfig
<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>main</span><span /class="hl-params"/g>()</span></span>
  config = create_config(<span /class="hl-number"/g>42</span>, [Thing(), Thing()])
</code></pre>
<p>A (unimplemented) &quot;rest&quot; parameter syntax could be a nice syntactic sugar:</p>
<pre><code class="language-co"><span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>create_config</span><span /class="hl-params"/g>(somearg <span /class="hl-type"/g>int</span>, things ...&amp;[Thing])</span></span> FooConfig
<span /class="hl-function"/g><span /class="hl-keyword"/g>fun</span> <span /class="hl-title"/g>main</span><span /class="hl-params"/g>()</span></span>
  config = create_config(<span /class="hl-number"/g>42</span>, Thing(), Thing())
</code></pre>

</body>
</html>
