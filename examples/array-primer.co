// Array & slice primer
//
// Types
//       [T N] │ fixed-size array
//   mut&[T N] │ slice of mutable array with comptime size
//      &[T N] │ slice of immutable array with comptime size
//       [T]   │ dynamically-sized array
//   mut&[T]   │ slice of mutable array with runtime size
//      &[T]   │ slice of immutable array with runtime size
//
// C equivalent definitions
//       [T N] │ T mem[N]
//   mut&[T N] │ T*
//      &[T N] │ const T*
//       [T]   │ struct array  {       void* p; uint len; uint cap; }
//   mut&[T]   │ struct slice  {       void* p; uint len; uint cap; }
//      &[T]   │ struct cslice { const void* p; uint len; }
//
// Can always answer these questions for all types listed above
//   x[i]      │ what is the value of item #i?
//   len(x)    │ how many items can be read at x?
//   cap(x)    │ how many items can be stored at x?
//
//───────────────────┬─────────────┬─────────────────────────────────────────────────────
// [T N] examples    │ Co type     │ C equivalent
//───────────────────┼─────────────┼─────────────────────────────────────────────────────
a = [1,2]          //│ [int 2]     │ int a[2] = {1,2}
b = a              //│ ERROR       │
b = &a             //│ mut&[int 2] │ int* b = a
b[1]               //│ int         │ b[1]
b[1] = 3           //│ int         │ b[1] = 3
var c [int 2]      //│ [int 2]     │ int c[2] = {0}
copy(c, a)         //│ ok          │ memcpy(c, a, sizeof(c))
                   //│             │
const d = [1,2]    //│ &[int 2]    │ const int d[2] = {1,2}
e = d              //│ ERROR       │
e = &d             //│ &[int 2]    │ const int* e = d
d[1]               //│ int         │ d[1]
d[1] = 3           //│ ERROR       │
f = a[1:]          //│ mut&[int 1] │ int* f = &a[1]
f = d[1:]          //│ ERROR       │
g = d[1:]          //│ &[int 1]    │ const int* g = &d[1]
//
//───────────────────┬─────────────┬─────────────────────────────────────────────────────
// [T] examples      │ Co type     │ C equivalent
//───────────────────┼─────────────┼─────────────────────────────────────────────────────
h = alloc(int,12)  //│ [int]       │ array h = { calloc(sizeof(int),12) , 0 , 12 }
h[0]               //│ ERROR       │
h.push(1)          //│ uint        │ grow(&h,1); uint i=h.len++; ((int*)h.p)[i] = 1; i
h.push(2)          //│ uint        │ grow(&h,1); uint i=h.len++; ((int*)h.p)[i] = 2; i
h[0]               //│ int         │ h.p[0]
k = h              //│ [int]       │ array k = h; h = (array){NULL,0,0}
l = &k             //│ mut&[int]   │ slice l = { k.p, k.len, k.cap }
m = k[1:]          //│ mut&[int]   │ slice m = { &k.p[1], k.len-1, k.cap-1 }
const n = &k       //│ &[int]      │ cslice n = { k.p, k.len }
const o = k[1:]    //│ &[int]      │ cslice o = { &k.p[1], k.len-1 }
//
//───────────────────┬─────────────┬─────────────────────────────────────────────────────
// Strings           │ Co type     │ C equivalent
//───────────────────┼─────────────┼─────────────────────────────────────────────────────
var s1 = "foo"     //│ &[u8]       │ cslice o = { "foo", 3 }
const s2 = "bar"   //│ &[u8 3]     │ const u8 tmp[3] = {"bar"} ; const u8* s2 = tmp
s2 = s1            //│ ERROR       │
s1 = s2            //│ &[u8]       │ s1 = (cslice){ s2, 3 }
s3 = s1[1:]        //│ &[u8]       │ s3 = (cslice){ &s1[1], s1.len-1 }
s3[1]              //│ u8          │ s3.p[1]
s3[1] = 't'        //│ ERROR       │

