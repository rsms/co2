#include <rbase/rbase.h>
#include "pkg.h"
#include "source.h"

ASSUME_NONNULL_BEGIN

// co filesystem directories. init() from either env (same names) or default values
static const char* COROOT = NULL;  // directory of co itself. default: argv[0]/../..
static const char* COPATH = NULL;  // directory for user files. default: ~/.co
static const char* COCACHE = NULL; // directory for build cache. default: COPATH/cache

bool SourceTranspile(Source* src, FILE* f) {
  //
  // TODO
  // - Extract includes (can we use .d files generated by clang, with -MF<file> maybe?)
  //   See https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-mg
  // - Consider imports (e.g. import "package/path")
  //   Stop-gap solution: #include <package/package.h>
  // - Optional semicolons a la Go
  // - Extract exported public API
  //
  // .h/.c idea:
  //   Infer the API and then generate output that has an ifdef so it can be included
  //   as a header or compiled alone:
  //     #ifdef _PB_AS_HEADER
  //       int twice(int x);
  //     #else
  //       int twice(int x) {
  //         return x * 2;
  //       }
  //     #endif
  //   Then in another file depending on that file:
  //     #define _PB_AS_HEADER
  //     #include "twice.pbc"
  //     #include "something_else.pbc"
  //     #undef _PB_AS_HEADER
  //     #ifdef _PB_AS_HEADER
  //       int main(int argc, const char** argv);
  //     #else
  //       int main(int argc, const char** argv) {
  //         return twice(argc);
  //       }
  //     #endif
  //
  // Another idea:
  //   Generate .h for the entire package.
  //   This is a better than individual header files but is a little trickier
  //   since stuff like this can be cyclic:
  //     struct File {
  //       struct File* next;
  //       Dir*         parent;
  //     };
  //     struct Dir {
  //       File* filelist;
  //     };
  //   File depends on Dir being defined; Dir depends on File being defined.
  //   Normally in C you manually provide a forward declaration.
  //   We can forward-declare all struct types to avoid this!
  //   Note that only structs have this issue. Functions is not an issue since
  //   we'd separate the declaration from their bodies.
  //     struct File;  // fwd declaration
  //     struct Dir;   // fwd declaration
  //     struct File {
  //       struct File* next;
  //       Dir*         parent;
  //     };
  //     struct Dir {
  //       File* filelist;
  //     };
  //   Fixed!
  //
  const char* prologue =
    "#line 1 co:prologue\n"
    "_Pragma(\"clang assume_nonnull begin\")\n"
    ;
  const char* epilogue =
    "#line 1 co:epilogue\n"
    "_Pragma(\"clang assume_nonnull end\")\n"
    ;

  fwrite(prologue, strlen(prologue), 1, f);

  // #line linenum filename
  fprintf(f, "#line 1 %s\n", src->filename);

  // body
  fwrite(src->body, src->len, 1, f);

  return fwrite(epilogue, strlen(epilogue), 1, f) > 0;
}


bool compile_source(const Pkg* pkg, Source* src) {
  if (!SourceOpenBody(src))
    panic(src->filename);

  // compute SHA-1 checksum of file contents
  SourceChecksum(src);

  // outfile = COCACHE "/" checksum ".pbc"
  const char* out_suffix = ".pbc";
  size_t i = strlen(COCACHE);
  size_t outfile_len2 = 1 + strlen(src->filename) + 1 + strlen(out_suffix) + 1;
  char* outfile = memdup2(pkg->mem, COCACHE, i, outfile_len2);
  outfile[i++] = PATH_SEPARATOR;
  sha1_fmt(&outfile[i], src->sha1);
  memcpy(&outfile[i+40], ".pbc\0", 5);
  dlog("%s -> %s", src->filename, outfile);

  // process input -> output if needed
  bool ok = true;
  auto f = fopen(outfile, "wx");
  if (!f) {
    // if file exists already the cache is up to date
    if (errno != EEXIST)
      panic(outfile);
  } else {
    ok = SourceTranspile(src, f);
    ok = fclose(f) == 0 && ok;
  }

  return SourceCloseBody(src) && ok;
}

// ————————————————————————————————————————————————————————————————————————————————

typedef void TFun(void*);

typedef struct Task {
  TFun* f;
  void* arg;
  Chan* inbox;
} Task;

typedef struct Worker {
  Mem       mem;   // memory allocator
  Thread    tread; // lazy; NULL until started
  MPSCQueue q;     // queue of Task items
  Task*     t;     // currently-executing task
} Worker;

static void TaskInit(Mem nullable mem, Task* t, TFun* f, void* arg, size_t inboxcap) {
  t->f = f;
  t->arg = arg;
  t->inbox = ChanNew(mem, sizeof(void*), inboxcap);
}

static void TaskCleanup(Task* t) {
  ChanFree(t->inbox);
}

static thread_local Worker* _curr_w = NULL;

static int WorkerMain(Worker* w) {
  dlog("WorkerMain w=%p", w);
  _curr_w = w;
  while (1) {
    auto t = (Task*)MPSCQueueDequeue(&w->q);
    w->t = t;
    if (!t) {
      dlog("WorkerMain queue drained; exiting");
      // TODO: wait around for work instead of exiting
      MemRecycle(&w->mem);
      break;
    }
    dlog("WorkerMain run job t=%p", t);
    t->f(t->arg);
    // TODO: flush any unread messages from inbox
    w->t = NULL;
    // free task
    TaskCleanup(t);
    memfree(w->mem, t);
  }
  MemFree(w->mem);
  return 0;
}

static void WorkerInit(Worker* w) {
  w->mem = MemNew(0);
  MPSCQueueInit(&w->q, 64);
}

typedef struct TaskMsg {
  Task*  sender;
  size_t size;
  u8     data[0];
} TaskMsg;

void TaskMsgFree(TaskMsg* msg) {
  memfree(NULL, msg); // global allocator
}

typedef struct TP { // thread pool
  uint    tlen; // number of threads alive
  uint    tcap; // capacity of thread array
  Worker* tv;   // array of threads
} TP;

static TP _tp;

static void tp_init() {
  _tp.tlen = 0;
  _tp.tcap = 4;
  _tp.tv = memalloc(NULL, sizeof(Worker) * _tp.tcap);
  for (uint i = 0; i < _tp.tcap; i++) {
    WorkerInit(&_tp.tv[i]);
  }
}

Task* nullable tp_spawn(TFun* f, void* arg, size_t inboxcap) {
  auto w = &_tp.tv[0];
  auto t = memalloct(w->mem, Task);
  TaskInit(w->mem, t, f, arg, inboxcap);
  MPSCQueueEnqueue(&w->q, t);
  if (ThreadStart(&w->tread, (int(*)(void*))WorkerMain, w) != ThreadSuccess) {
    errlog("tp_spawn ThreadStart failed");
    return NULL;
  }
  return t;
}

void tp_send(Task* recipient, const void* data, size_t size) {
  Worker* w = _curr_w;
  auto msg = (TaskMsg*)memalloc_raw(NULL, sizeof(TaskMsg) + size); // global allocator
  msg->sender = w == NULL ? NULL : w->t;
  msg->size = size;
  memcpy(&msg->data[0], data, size);
  ChanSend(recipient->inbox, msg);
}

TaskMsg* tp_recv(int timeout) {
  Worker* w = _curr_w;
  if (!w || !w->t) {
    errlog("called tp_recv from outside task");
    return memalloct(NULL, TaskMsg);
  }
  return ChanRecv(w->t->inbox);
}

static void tp_waitall() {
  dlog("tp_waitall");
  for (uint i = 0; i < _tp.tcap; i++) {
    auto w = &_tp.tv[i];
    if (w->tread) {
      ThreadAwait(w->tread); // ignore result
    }
  }
}

static void tptest1(void* arg) {
  // dlog("tptest1 arg=%p; calling tp_recv(0)", arg);
  for (int i = 1; i <= 4; i++) {
    dlog(">> tptest1 recv %d/4", i);
    auto msg = tp_recv(0);
    if (msg) {
      dlog(">> tptest1 recv => %.*s\n", (int)msg->size, &msg->data[0]);
      TaskMsgFree(msg);
    } else {
      dlog(">> tptest1 recv => (nil)\n");
    }
    // if (i < 4)
    //   msleep(100);
  }
}



int cmd_build(int argc, const char** argv) {
  if (argc < 3) {
    errlog("missing input");
    return 1;
  }

  char abuf[40];
  auto timestart = nanotime();
  Pkg pkg = { .dir = "." };

  // make sure COCACHE exists
  if (!fs_mkdirs(NULL, COCACHE, 0700)) {
    errlog("failed to create directory %s", COCACHE);
    return 1;
  }

  pkg.dir = argv[2];
  if (!PkgScanSources(&pkg))
    panic(pkg.dir);

  // process source files
  bool ok = true;
  Source* src = pkg.srclist;
  while (src && ok) {
    ok = compile_source(&pkg, src);
    src = src->next;
  }

  // print how much (real, wall) time we spent
  auto timeend = nanotime();
  auto buflen = fmtduration(abuf, countof(abuf), timeend-timestart);
  printf("done in %.*s\n", buflen, abuf);
  return ok ? 0 : 1;
}

int main_usage(const char* arg0, int exit_code) {
  fprintf(exit_code == 0 ? stdout : stderr,
    "usage: %s build <srcdir>\n"
    "       %s build <srcfile> <outfile>\n"
    "       %s help\n"
    "",
    arg0,
    arg0,
    arg0
  );
  return exit_code;
}

static bool init(const char* argv0) {
  COROOT = getenv("COROOT");
  COPATH = getenv("COPATH");
  COCACHE = getenv("COCACHE");

  if (!COROOT || strlen(COROOT) == 0) {
    // COROOT is not set; infer from argv[0]
    COROOT = NULL;
    auto dirbase = argv0;
    auto dir = strrchr(dirbase, PATH_SEPARATOR);
    if (!dir && (dirbase = getenv("_")))
      dir = strrchr(dirbase, PATH_SEPARATOR);
    if (dir) {
      char buf[512];
      auto dirlen = (size_t)dir - (size_t)dirbase;
      auto len = MIN(dirlen, sizeof(buf));
      memcpy(buf, dirbase, len + 1);
      buf[len] = '\0';
      auto pch = realpath(buf, NULL);
      if (pch)
        COROOT = path_dir(NULL, pch);
    }
    if (!COROOT) {
      errlog("unable to infer COROOT; set it in env");
      return false;
    }
  }

  if (!COPATH || strlen(COPATH) == 0)
    COPATH = path_join(NULL, user_home_dir(), ".co");

  if (!COCACHE || strlen(COCACHE) == 0)
    COCACHE = path_join(NULL, COPATH, "cache");

  dlog("COROOT=%s", COROOT);
  dlog("COPATH=%s", COPATH);
  dlog("COCACHE=%s", COCACHE);

  tp_init();
  return true;
}

void t_yield();
#define GREEN "\e[1;32m"
#define YELLOW "\e[1;33m"

static void fn2() {
  dlog(YELLOW "fn2 coroutine");
  dlog(YELLOW "calling t_yield()");
  t_yield();
  dlog(YELLOW "back from yield");
  msleep(1000);
  dlog(YELLOW "EXIT");
}

static u8 smolstack[4096];

static void fn1() {
  #define GREEN "\e[1;32m"
  dlog(GREEN "main coroutine");

  dlog(GREEN "spawn fn2");
  //t_spawn_custom(fn2, /*stackmem*/NULL, /*stacksize*/4096*4);
  t_spawn_custom(fn2, &smolstack[1], sizeof(smolstack)-1);

  // msleep(1000);

  dlog(GREEN "calling t_yield()");
  t_yield();
  dlog(GREEN "back from yield; calling t_yield()");
  t_yield();
  dlog(GREEN "back from yield");
  dlog(GREEN "EXIT");
}

int main(int argc, const char* argv[argc+1]) {
  if (!init(argv[0]))
    return 1;
  sched_init();
  sched_main(fn1); // never returns
  return 0;
}

int x_main(int argc, const char* argv[argc+1]) {
  if (!init(argv[0]))
    return 1;

  auto t1 = tp_spawn(tptest1, (void*)&argc, /*inboxcap*/1);
  dlog("<< main send 1/4 ..."); tp_send(t1, "1", 1); dlog("<< main sent 1/4 OK\n");
  dlog("<< main send 2/4 ..."); tp_send(t1, "2", 1); dlog("<< main sent 2/4 OK\n");
  dlog("<< main send 3/4 ..."); tp_send(t1, "3", 1); dlog("<< main sent 3/4 OK\n");
  dlog("<< main send 4/4 ..."); tp_send(t1, "4", 1); dlog("<< main sent 4/4 OK\n");

  atexit(tp_waitall);

  if (argc < 2)
    return main_usage(argv[0], 1);

  if (strcmp(argv[1], "build") == 0)
    return cmd_build(argc, argv);

  // help | -h* | --help
  if (strstr(argv[1], "help") || strcmp(argv[1], "-h") == 0)
    return main_usage(argv[0], 0);

  if (strlen(argv[1]) > 0 && argv[1][0] == '-')
    errlog("unknown option: %s", argv[1]);
  else
    errlog("unknown command: %s", argv[1]);
  return 1;
}

ASSUME_NONNULL_END
