//
// Pratt-style recursive descent parser.
//
// Syntax productions are parsed by functions dubbed "parselets".
// They are defined with a magical comment described by the following eBNF:
//
//   infix  = <LF> "//!Parselet" ( "(" Tok Precedence ")" )+
//   prefix = <LF> "//!PrefixParselet" Tok+
//
// Examples:
//
//   //!Parselet (TPlus ADD) (TMinus ADD) (TStar MULTIPLY) (TSlash MULTIPLY)
//   static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left)
//
//   //!PrefixParselet TPlus TMinus TExcalm
//   static Node* PPrefixOp(Parser* p, PFlag fl)
//
// The parselet dispatch map for all tokens is generated by a script (gen_parselet_map.py)
// which builds the "parselets" table (see end of file.)

// panic() on parse errors
#define DEBUG_PANIC_ON_PARSE_ERROR
//
// enable debug messages for pushScope() and popScope()
//#define DEBUG_SCOPE_PUSH_POP
//
// enable debug dumping of symbol bindings (scope stack)
//#define DEBUG_SCOPE_BINDINGS
//
// enable debug messages for defsym()
//#define DEBUG_DEFSYM
//
// enable debug messages for resolve_id()
//#define DEBUG_LOOKUPSYM
//
#include "../common.h"
#include "parse.h"

ASSUME_NONNULL_BEGIN


// Operator precedence
// Precedence    Operator
//     5             *  /  %  <<  >>  &  &^
//     4             +  -  |  ^
//     3             ==  !=  <  <=  >  >=
//     2             &&
//     1             ||
//
typedef enum Precedence {
  PREC_LOWEST,
  PREC_ASSIGN,
  PREC_COMMA,
  PREC_LOGICAL_OR,
  PREC_LOGICAL_AND,
  PREC_BITWISE_OR,
  PREC_BITWISE_XOR,
  PREC_BITWISE_AND,
  PREC_EQUAL,
  PREC_COMPARE,
  PREC_SHIFT,
  PREC_ADD,
  PREC_MULTIPLY,
  PREC_UNARY_PREFIX,
  PREC_UNARY_POSTFIX,
  PREC_MEMBER,
} Precedence;


typedef enum PFlag {
  PFlagNone   = 0,
  PFlagRValue = 1 << 0, // parsing an rvalue
  PFlagType   = 1 << 1, // parsing a type
} PFlag;


typedef struct Parselet Parselet;

typedef Node* (ParseletPrefixFun)(Parser* p, PFlag fl);
typedef Node* (ParseletFun)      (Parser* p, const Parselet* e, PFlag fl, Node* left);

typedef struct Parselet {
  ParseletPrefixFun* fprefix;
  ParseletFun*       f;
  Precedence         prec;
} Parselet;

typedef struct UnresolvedNode {
  Source* src;
  Node*   n;
} UnresolvedNode;

typedef struct Unresolved {
  Sym            sym;
  u32            nodeslen;
  u32            nodescap;
  UnresolvedNode nodes[];
} Unresolved;


#define nexttok(p) ScannerNext(&(p)->s)


// syntaxerrp reports a source-token related syntax error.
// It will point to the source location of the last-scanned token.
// If n is not NULL, use source location of n instead of current location.
//
static Pos syntaxerrp(Parser* p, Pos pos, const char* format, ...) {
  if (pos == NoPos)
    pos = ScannerPos(&p->s);

  va_list ap;
  va_start(ap, format);
  auto msg = str_new(64);
  if (strlen(format) > 0)
    msg = str_appendfmtv(msg, format, ap);
  va_end(ap);

  const char* tokname;
  if (p->s.tok == TNone) {
    tokname = "end of input";
  } else if (p->s.tok == TSemi && p->s.inp > p->s.src->body && *(p->s.inp - 1) == '\n') {
    // Implicit semicolon from linebreak.
    tokname = "line break";
    // To improve the error message, find the pos of the linebreak
    const u8* prevlinestart = p->s.prevtokend - 1;
    while (prevlinestart > p->s.src->body) {
      if (*prevlinestart == '\n')
        break;
      prevlinestart--;
    }
    u32 col = (u32)(uintptr_t)(p->s.prevtokend - prevlinestart);
    pos = pos_make(p->s.srcposorigin, p->s.lineno - 1, col, /*span*/0);
  } else {
    tokname = TokName(p->s.tok);
  }

  Str stmp = NULL;
  if (str_len(msg) == 0) {
    stmp = msg;
    msg = str_fmt("unexpected %s", tokname);
  } else if (str_hasprefixcstr(msg, "expecting ")) {
    stmp = msg;
    msg = str_fmt("unexpected %s, %s", tokname, msg);
  } else if (
    str_hasprefixcstr(msg, "after ") ||
    str_hasprefixcstr(msg, "in ") ||
    str_hasprefixcstr(msg, "at ")
  ) {
    stmp = msg;
    msg = str_fmt("unexpected %s %s", tokname, msg);
  }
  if (stmp)
    str_free(stmp);

  build_diag(p->build, DiagError, (PosSpan){pos, NoPos}, msg);

  #ifdef DEBUG_PANIC_ON_PARSE_ERROR
  panic("DEBUG_PANIC_ON_PARSE_ERROR %s", msg);
  #endif

  str_free(msg);
  return pos;
}


// syntaxerr = syntaxerrp(p, <srcpos of current token>, ...)
#define syntaxerr(p, format, ...) \
  syntaxerrp((p), NoPos, format, ##__VA_ARGS__)


// toklistHas returns true if t is in list (list is expected to be 0-terminated)
static bool toklistHas(const Tok* list, Tok t) {
  Tok t2;
  while ((t2 = *list++)) {
    if (t2 == t) {
      return true;
    }
  }
  return false;
}


// advance consumes tokens until it finds a token of the followlist.
// It is used to recover from parse errors and is not speed critical.
//
static void advance(Parser* p, const Tok* followlist) {
  nexttok(p); // guarantee progress
  if (followlist == NULL || *followlist == 0) {
    return;
  }
  if (p->fnest > 0) {
    // Stop at keywords that start a statement.
    // They are good synchronization points in case of syntax
    // errors and (usually) shouldn't be skipped over.
    while (!toklistHas(followlist, p->s.tok)) {
      switch (p->s.tok) {
        case TNone:
        case TBreak:
        case TContinue:
        case TDefer:
        case TFor:
        case TIf:
        case TAuto:
        case TReturn:
        case TSelect:
        case TSwitch:
        case TType:
          return;
        default:
          break;
      }
      // dlog("skip %s", TokName(p->s.tok));
      nexttok(p);
    }
  } else {
    while (p->s.tok != TNone && !toklistHas(followlist, p->s.tok)) {
      // dlog("skip %s", TokName(p->s.tok));
      nexttok(p);
    }
  }
  if (p->s.tok == TSemi) {
    nexttok(p);
  }
}


// mknode allocates a new ast node
inline static Node* mknode(Parser* p, NodeKind kind) {
  auto n = NewNode(p->build->mem, kind);
  n->pos = ScannerPos(&p->s);
  return n;
}

ALWAYS_INLINE static Node* set_endpos(Parser* p, Node* n) {
  n->endpos = ScannerPos(&p->s);
  return n;
}

// precedence should match the calling parselet's own precedence
static Node* expr(Parser* p, int precedence, PFlag fl);
static Node* prefixExpr(Parser* p, PFlag fl);

// exprOrTuple = Expr | Tuple
static Node* exprOrTuple(Parser* p, int precedence, PFlag fl);


static void scopestackGrow(Parser* p) {
  p->scopestack.cap *= 2;
  Mem mem = p->build->mem;
  if (p->scopestack.ptr == p->scopestack.storage) {
    p->scopestack.ptr = memalloc(mem, sizeof(void*) * p->scopestack.cap);
    memcpy(p->scopestack.ptr, p->scopestack.storage, sizeof(void*) * p->scopestack.len);
  } else {
    p->scopestack.ptr = memrealloc(mem, p->scopestack.ptr, sizeof(void*) * p->scopestack.cap);
  }
}

#ifdef DEBUG_SCOPE_BINDINGS
  static void scopestackDebugDump(Parser* p) {
    dlog("scope bindings:");
    FILE* fp = stderr;
    // stack is arranged like this: | It can also look like this: (empty current scope)
    // [10] key4                    | [10] -- base=6 --
    // [9]  value4                  | [6]  -- base=0 --
    // [8]  key3                    | [5]  key2
    // [7]  value3                  | [4]  value2
    // [6]  -- base=0 --            | [3]  key1
    // [5]  key2                    | [2]  value1
    // [4]  value2                  |
    // [3]  key1                    |
    // [2]  value1                  |
    uintptr_t i = p->scopestack.len;
    uintptr_t base = p->scopestack.base;
    while (i > 1) {
      i--;
      if (i == base) {
        auto prevbase = (size_t)base;
        base = (uintptr_t)p->scopestack.ptr[i];
        fprintf(fp, "  --------- (base %zu -> %zu)\n", prevbase, (size_t)base);
      } else {
        Sym key = (Sym)p->scopestack.ptr[i];
        i--;
        Node* n = (Node*)p->scopestack.ptr[i];
        fprintf(fp, "  %s => %s %s\n", key, NodeKindName(n->kind), fmtnode(n));
      }
    }
  }
#endif /* DEBUG_SCOPE_BINDINGS */


static void scopestackCheckUnused(Parser* p) {
  assert_debug(p->scopestack.len > 0);
  uintptr_t i = p->scopestack.len;
  uintptr_t base = p->scopestack.base;
  while (--i > base) {
    //Sym key = (Sym)p->scopestack.ptr[i];
    i--;
    Node* n = (Node*)p->scopestack.ptr[i];
    //dlog(">>  %s => %s %s", key, NodeKindName(n->kind), fmtnode(n));
    if (R_UNLIKELY(n->kind == NLet && n->let.nrefs == 0 ||
                   n->kind == NParam && n->field.nrefs == 0))
    {
      build_warnf(p->build, NodePosSpan(n),
        "unused %s %s", n->kind == NParam ? "argument" : "variable", n->let.name);
    }
  }
}


// pushScope adds a new scope to the stack. Returns the new scope.
inline static void pushScope(Parser* p) {
  // add "scope starts here" to scopestack
  if (R_UNLIKELY(p->scopestack.cap - p->scopestack.len == 0))
    scopestackGrow(p);

  #ifdef DEBUG_SCOPE_PUSH_POP
    dlog("push scope; base %zu -> %zu", (size_t)p->scopestack.base, (size_t)p->scopestack.len);
  #endif

  p->scopestack.ptr[p->scopestack.len++] = (void*)p->scopestack.base;
  p->scopestack.base = p->scopestack.len - 1;
}


// popScope removes the topmost scope
inline static void popScope(Parser* p) {
  #ifdef DEBUG_SCOPE_PUSH_POP
  {
    size_t nbindings = (size_t)(p->scopestack.len - p->scopestack.base) / 2;
    dlog("pop scope; base %zu -> %zu (%zu bindings)",
      (size_t)p->scopestack.base,
      (size_t)(uintptr_t)p->scopestack.ptr[p->scopestack.base],
      nbindings);
  }
  #endif

  #ifdef DEBUG_SCOPE_BINDINGS
    scopestackDebugDump(p);
  #endif

  // check for unused variables and parameters
  if (p->build->debug && p->scopestack.len - p->scopestack.base > 1)
    scopestackCheckUnused(p);

  // rewind and restore base of parent scope
  p->scopestack.len = p->scopestack.base;
  p->scopestack.base = (uintptr_t)p->scopestack.ptr[p->scopestack.len];
}


inline static void scopestackPush(Parser* p, Sym key, Node* value) {
  assert_debug(p->scopestack.cap - p->scopestack.len > 1);
  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)value;
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)key;
  p->scopestack.len += 2;
}

// lookupsymPkg looks up node for key in the package scope.
static Node* nullable lookupsymPkg(Parser* p, Sym key) {
  // look in the package's scope (including universe)
  #ifdef DEBUG_LOOKUPSYM
    dlog("lookup %s fallback to pkgscope", key);
  #endif
  Node* n = (Node*)ScopeLookup(p->pkgscope, key);
  if (n && p->scopestack.cap - p->scopestack.len > 1) {
    // Put it on the scopestack if there's space, as this will likely be requested soon again.
    // For example, in this case "int" will lookupsym many times:
    //   fun foo(x, y int) int {
    //     tmp = 3 as int
    //     tmp + x + y
    //   }
    // However, with this optimization lookup of "int" only takes the slow path once
    // (for the first "int" in function params) and is then found in the local scopestack for
    // all remaining lookups of "int".
    scopestackPush(p, key, n);
  }
  return n;
}

// lookupsym looks up node for key in the current scope, searching all parent scopes.
// This function is inline because it's only used in one place.
inline static Node* nullable lookupsym(Parser* p, Sym key) {
  uintptr_t i = p->scopestack.len;
  uintptr_t base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      base = (uintptr_t)p->scopestack.ptr[i];
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      return (Node*)p->scopestack.ptr[i];
    }
  }
  // not found in the current file's scope; look in the package's scope (including universe)
  return lookupsymPkg(p, key);
}

static Node* nullable lookupsymShallow(Parser* p, Sym key) {
  uintptr_t i = p->scopestack.len;
  uintptr_t base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      break;
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      return (Node*)p->scopestack.ptr[i];
    }
  }
  return NULL;
}

static void defsym(Parser* p, Sym s, Node* n) {
  #ifdef DEBUG_DEFSYM
  auto existing = lookupsymShallow(p, s);
  if (existing) {
    dlog("defsym %s => %s (replacing %s)", s, NodeKindName(n->kind), NodeKindName(existing->kind));
  } else {
    dlog("defsym %s => %s", s, NodeKindName(n->kind));
  }
  #endif

  if (R_UNLIKELY(p->scopestack.cap - p->scopestack.len < 2))
    scopestackGrow(p);

  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)n; // value
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)s; // key
  p->scopestack.len += 2;

  if (p->scopestack.base == 0) {
    // top level definition -- add to pkgscope.
    // TODO: For imports, make sure to add to file scope instead of package scope
    //       Lazily create: p->file->array.scope=ScopeNew(p->pkgscope, p->build->mem);
    ScopeAssoc(p->pkgscope, s, n);
  }
}


// If the current token is t, advances scanner and returns true.
inline static bool got(Parser* p, Tok t) {
  if (p->s.tok != t)
    return false;
  nexttok(p);
  return true;
}

// want reports a syntax error if p->s.tok != t.
// In any case, this function will advance the scanner by one token.
inline static void want(Parser* p, Tok t) {
  if (R_UNLIKELY(!got(p, t))) {
    syntaxerr(p, "expecting %s", TokName(t));
    nexttok(p);
  }
}

static Node* bad(Parser* p) {
  return mknode(p, NBad);
}


// tupleTrailingComma = Expr ("," Expr)* ","?
// Used for call arguments.
static Node* tupleTrailingComma(Parser* p, int precedence, PFlag fl, Tok stoptok) {
  auto tuple = mknode(p, NTuple);
  NodeSetConst(tuple);
  do {
    Node* cn = expr(p, precedence, fl);
    NodeArrayAppend(p->build->mem, &tuple->array.a, cn);
    NodeTransferConst(tuple, cn);
  } while (got(p, TComma) && p->s.tok != stoptok);
  return set_endpos(p, tuple);
}


static Node* makeLet(Parser* p, const Node* name, Node* nullable init) {
  asserteq_debug(name->kind, NId);
  auto n = NewNode(p->build->mem, NLet);
  NodeSetConst(n);
  n->pos = name->pos; // TODO: expand pos span to include type?
  n->let.name = name->ref.name;
  if (init) {
    n->let.init = init;
    n->type = init->type;
    NodeTransferUnresolved(n, init);
    NodeTransferConst(n, init);
  }
  defsym(p, name->ref.name, n);
  return n;
}


static Node* useAsRValue(Parser* p, Node* expr);


static Node* simplify_id(Parser* p, Node* id, PFlag fl) {
  asserteq_debug(id->kind, NId);
  assertnotnull_debug(id->ref.target);
  assertnotnull_debug(id->ref.name);

  Node* target = id->ref.target;

  // unwind let targeting a type
  Node* t = target;
  for (; t->kind == NLet && NodeIsConst(t); ) {
    t = t->let.init;
    // Note: no NodeUnrefLet here
    if (NodeIsType(t)) {
      target = t;
      break;
    }
  }

  if (fl & PFlagRValue) {
    id->flags |= NodeFlagRValue;
    target = t;
  }

  if (NodeIsType(target) ||
      ((fl & PFlagRValue) && (!NodeIsExpr(target) || NodeIsConst(target))))
  {
    // The target is a type; short-circuit and return that instead of the id
    return useAsRValue(p, target);
  }

  NodeRef(target);

  // Note: Don't transfer "unresolved" attribute of functions
  if (target->kind != NFun)
    NodeTransferUnresolved(id, target);

  NodeTransferConst(id, target);

  return id;
}


// resolve_id resolves an identifier.
// Its target is assumed to be NULL.
// Returns id or its target
static Node* resolve_id(Parser* p, Node* id, PFlag fl) {
  asserteq_debug(id->kind, NId);
  assertnull_debug(id->ref.target);
  assertnotnull_debug(id->ref.name);

  id->ref.target = lookupsym(p, id->ref.name);

  #ifdef DEBUG_LOOKUPSYM
    if (id->ref.target == NULL) {
      dlog("lookup %s => (not found; unresolved)", id->ref.name);
    } else {
      Node* n = id->ref.target;
      dlog("lookup %s => %s %s", id->ref.name, NodeKindName(n->kind), fmtnode(n));
    }
  #endif

  if (id->ref.target == NULL) {
    // not found
    NodeSetUnresolved(id);
    return id;
  }

  return (id->flags & NodeFlagRValue) ? id : simplify_id(p, id, fl);
}


// useAsRValue is used to lazily resolve identifiers which are used in rvalue position
// that is unknown ahead of time. Returns expr or its effective value.
// For example:
//   fun foo(x, y int) int {
//     x
//     ~ might be the beginning of a let definition
// Scenario 1:
//   fun foo(x, y int) int {
//     x = 4
//     ~~~~~ lvalue in a let definition; defining not resolving.
// Scenario 2:
//   fun foo(x, y int) int {
//     x + y
//     ~~~~~  Used as an rvalue in an op; call useAsRValue(x)
//
static Node* useAsRValue(Parser* p, Node* expr) {
  if (expr->flags & NodeFlagRValue)
    return expr;

  if (expr->kind == NId) {
    if (expr->ref.target) {
      expr = simplify_id(p, expr, PFlagRValue);
    } else {
      expr = resolve_id(p, expr, PFlagRValue);
    }
  }

  expr->flags |= NodeFlagRValue;
  return expr;
}


// nodeTransferUnresolved2 is like NodeTransferUnresolved but takes two inputs which flags
// are combined as a set union.
inline static void nodeTransferUnresolved2(Node* parent, Node* child1, Node* child2) {
  // parent is unresolved if child1 OR child2 is unresolved
  parent->flags |= (child1->flags & NodeFlagUnresolved) | (child2->flags & NodeFlagUnresolved);
}


static Type* nullable set_ctxtype(Parser* p, Type* nullable new_ctxtype) {
  auto old_ctxtype = p->ctxtype;
  p->ctxtype = new_ctxtype && NodeIsType(new_ctxtype) ? new_ctxtype : NULL;
  return old_ctxtype;
}


// ============================================================================================
// ============================================================================================
// Parselets (upper case PName = pratt parselet, lower case pName = helper parselet)


// Type (always rvalue)
inline static Type* pType(Parser* p, PFlag fl) {
  return exprOrTuple(p, PREC_MEMBER, fl | PFlagType | PFlagRValue);
}

inline static Node* pId(Parser* p) {
  assert(p->s.tok == TId);
  auto n = mknode(p, NId);
  n->ref.name = p->s.name;
  NodeSetConst(n);
  nexttok(p);
  return n;
}


//!PrefixParselet TNil
static Node* PNil(Parser* p, PFlag fl) {
  nexttok(p);
  return Const_nil;
}

//!PrefixParselet TAuto
static Node* PAuto(Parser* p, PFlag fl) {
  nexttok(p);
  return Type_auto;
}

// PId -- identifier (as prefix)
// When parsing an rvalue identifier, PFlagRValue is set in fl
//
//!PrefixParselet TId
static Node* PId(Parser* p, PFlag fl) {
  auto n = pId(p);
  // eagerly resolve identifiers in rvalue position
  if ((fl & PFlagRValue) || (p->s.tok != TAssign && p->s.tok != TId))
    return resolve_id(p, n, fl);
  return n;
}


// VarDecl = "var" Id (Type | Type? "=" Expr)
// e.g. "var x int", "var x = 4", "var x int = 4"
//!PrefixParselet TVar
static Node* PVar(Parser* p, PFlag fl) {
  auto n = mknode(p, NLet);
  n->let.ismut = true;
  nexttok(p); // consume "var"

  // name
  // TODO: multi-name e.g. "var x, y, z int", "var x, y, z = 1, 2, 3"
  if (R_UNLIKELY(p->s.tok != TId)) {
    syntaxerr(p, "expecting %s", TokName(TId));
  } else {
    n->let.name = p->s.name;
    n->pos = pos_union(n->pos, ScannerPos(&p->s));
  }
  nexttok(p);

  if (p->s.tok != TAssign) {
    // e.g. "var name type"
    if (R_UNLIKELY(p->s.tok == TSemi)) {
      // improved error message (we'd get a generic one from pType)
      Pos epos = syntaxerr(p, "expecting type or assignment with initial value");
      build_notef(p->build, (PosSpan){epos,epos},
        "Fix by adding a type:\n  var %s TYPE\nor assigning a value:\n  var %s = VALUE\nhere:",
        n->let.name, n->let.name);
    } else {
      n->type = pType(p, fl);
    }
  }
  if (got(p, TAssign)) {
    // e.g. "var name = x" or "var name type = x"
    // TODO: if we have a known type, e.g. "var x int = 5" then use that in PIntLit()
    n->let.init = expr(p, PREC_LOWEST, PFlagRValue);
    if (!n->type)
      n->type = n->let.init->type;
    NodeTransferUnresolved(n, n->let.init);
  }
  defsym(p, n->let.name, n);
  return n;
}


// assignment to fields, e.g. "x.y = 3" -> (assign (Field (Id x) (Id y)) (Int 3))
static Node* pAssignField(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  assert(fl & PFlagRValue);
  auto n = mknode(p, NAssign);
  n->op.op = p->s.tok;
  nexttok(p); // consume '='
  auto right = exprOrTuple(p, e->prec, fl);
  n->op.left = left;
  n->op.right = right;
  nodeTransferUnresolved2(n, left, right);

  // defsym
  if (left->kind == NTuple) {
    if (right->kind != NTuple) {
      syntaxerrp(p, left->pos, "assignment mismatch: %u targets but 1 value", left->array.a.len);
    } else {
      auto lnodes = &left->array.a;
      auto rnodes = &right->array.a;
      if (lnodes->len != rnodes->len) {
        syntaxerrp(p, left->pos, "assignment mismatch: %u targets but %u values",
          lnodes->len, rnodes->len);
      } else {
        for (u32 i = 0; i < lnodes->len; i++) {
          Node* l = lnodes->v[i];
          Node* r = rnodes->v[i];
          if (l->kind == NId) {
            defsym(p, l->ref.name, r);
          } else {
            // e.g. foo.bar = 3
            panic("TODO pAssignField l->kind != NId");
          }
        }
      }
    }
  } else if (right->kind == NTuple) {
    syntaxerrp(p, left->pos, "assignment mismatch: 1 target but %u values", right->array.a.len);
  } else if (left->kind == NId) {
    defsym(p, left->ref.name, right);
  }

  return n;
}


// Infix assignment e.g. "=" in "left = expr"
//!Parselet (TAssign ASSIGN)
static Node* PLetOrAssign(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  fl |= PFlagRValue;

  if (left->kind != NId) {
    // assignment to field
    dlog("assign field %s", fmtnode(left));
    return pAssignField(p, e, fl, left);
  }

  left = resolve_id(p, left, PFlagNone);

  Node* existing = lookupsym(p, left->ref.name);
  if (existing && existing->kind == NLet) {
    dlog("assign %s", fmtnode(existing));
    // assign to existing var and make sure the target is marked as variable
    NodeClearConst(existing);
    auto n = mknode(p, NAssign);
    n->op.op = p->s.tok;
    nexttok(p); // consume '='
    auto right = exprOrTuple(p, e->prec, fl);
    n->op.left = existing; // store NLet instead of NId to simplify IR generation
    n->op.right = right;
    NodeTransferUnresolved(n, right);
    return n;
  }

  // var definition, e.g. "x = 3" -> (let (Id x) (Int 3))
  nexttok(p); // consume '='
  Node* init = expr(p, PREC_LOWEST, PFlagRValue);
  return makeLet(p, left, init); // copies left->ref.name and left->pos
}


// Group = "(" Expr ("," Expr)* ")"
// Groups are used to control precedence.
//!PrefixParselet TLParen
static Node* PGroup(Parser* p, PFlag fl) {
  nexttok(p); // consume "("
  auto n = exprOrTuple(p, PREC_LOWEST, fl);
  want(p, TRParen);
  return n;
}


// ArrayType = arrayType | sliceType
// arrayType = "[" Expr "]" Type
// sliceType = "[]" Type
static Node* pArrayType(Parser* p, PFlag fl) {
  fl |= PFlagType;
  auto n = mknode(p, NArrayType);
  nexttok(p); // consume "["

  // array or slice?
  if (!got(p, TRBrack)) {
    n->t.array.sizeExpr = expr(p, PREC_LOWEST, (fl & ~PFlagType) | PFlagRValue);
    want(p, TRBrack);
  } // else: slice, e.g. "[]int"

  n->t.array.subtype = expr(p, PREC_MEMBER, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->t.array.subtype);

  // if we are parsing in rvalue position it must be a parameter, else it's a let
  if (fl & PFlagRValue) {
    // e.g. fun foo(arg [4]int)
    //              ~~~~~~~~~~
    // TODO: is there anything we'd like to do here, like default value?
  }

  return InternASTType(p->build, n);
}


//!PrefixParselet TLBrack
static Node* PArrayPrefix(Parser* p, PFlag fl) {
  // array type "x [3]int", "x = [3]int(1, 2, 3)"
  return pArrayType(p, fl);
}


// Index = expr "[" expr "]"
static Node* pIndex(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  assert_debug((fl & PFlagType) == 0); // indexing is not valid in type context
  auto n = mknode(p, NIndex);
  NodeSetConst(n);
  nexttok(p); // consume "["
  n->index.operand = left;
  if (R_UNLIKELY(p->s.tok == TRBrack)) {
    syntaxerr(p, "missing index");
    nexttok(p); // consume unexpected "]"
  } else {
    n->index.index = expr(p, PREC_LOWEST, fl | PFlagRValue);
    want(p, TRBrack);
    nodeTransferUnresolved2(n, n->index.operand, n->index.index);
    NodeTransferConst2(n, n->index.operand, n->index.index);
  }
  return n;
}


// ListType  = ArrayType | SliceType
// ArrayType = "[" Expr "]" Type
// SliceType = "[]" Type
// #note: Expr must be of type usize
//
//!Parselet (TLBrack MEMBER)
static Node* PArrayInfix(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  // Two possibilities:
  // x [3]int  -- array type
  // x[3]      -- index (subscript) access

  // if there's no space in between "left" and "[", treat it as index access
  if (p->s.prevtokend == p->s.tokstart)
    return pIndex(p, e, fl, left);

  // else, treat it as an array type following an identifier e.g. "x [3]int"
  if (left->kind != NId) {
    syntaxerr(p, "unexpected array or slice type");
    return left;
  }

  auto type = pArrayType(p, fl);

  // e.g. "foo [4]int" =>
  // (Let
  //   (Id foo)
  //   (ArrayType (IntLit 4) (BasicType int))
  //   Initializer? )

  // optional initializer expression e.g. "foo []int = [1, 2, 3]"
  Node* init = NULL;
  if (got(p, TAssign)) {
    auto ctxtype = set_ctxtype(p, type);
    init = expr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  }

  auto n = makeLet(p, left, init);
  // NodeFree(left); // makeLet copies left->ref.name and left->pos
  n->type = type;

  // TODO: add check to PLetOrAssign and update n->let.init

  return n;
}


// PIdTrailing parses a trailing identifier, e.g. "b" in "a b"
//
//!Parselet (TId ASSIGN)
static Node* PIdTrailing(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto id = pId(p);

  if (R_UNLIKELY((fl & PFlagRValue) || left->kind != NId)) {
    // (fl & PFlagRValue)   Occurs as an expression, e.g. "b" in "x = a b"
    // (left->kind != NId)  Identifier following some expression e.g. "b" in "3 b"
    syntaxerrp(p, id->pos, "unexpected identifier %s", id->ref.name);
    return id;
  }

  Type* typ = resolve_id(p, id, fl | PFlagType);
  Node* init = NULL;
  if (got(p, TAssign)) {
    auto ctxtype = set_ctxtype(p, typ);
    init = expr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  }
  Node* letn = makeLet(p, left, init);
  letn->type = typ;
  return letn;
}


// As = lhs "as" Type
// "as" has the lowest precedence and thus... Examples:
//
//   "9 * 2 as int8"         => (TypeCast int8 (Op * (Int 9) (Int 2)))
//   "9 * (2 as int8)"       => (Op * (Int 9) (TypeCast int8 (Int 2)))
//   "9, 2 as (int8,int8)"   => (Int 9) (TypeCast (Tuple int8 int8) (Int 2))
//   "(9, 2) as (int8,int8)" => (TypeCast (Tuple int8 int8) (Tuple (Int 9) (Int 2)))
//
//!Parselet (TAs LOWEST)
static Node* PAs(Parser* p, const Parselet* e, PFlag fl, Node* lhs) {
  auto n = mknode(p, NTypeCast);
  nexttok(p); // consume "as"
  n->call.receiver = pType(p, fl);
  n->call.args = lhs;
  return n;
}

//!Parselet (TLParen COMMA)
static Node* PCall(Parser* p, const Parselet* e, PFlag fl, Node* receiver) {
  auto n = mknode(p, NCall);
  NodeSetConst(n);
  nexttok(p); // consume "("
  auto ctxtype = p->ctxtype; // save ctxtype

  // receiver
  n->call.receiver = useAsRValue(p, receiver);
  NodeTransferUnresolved(n, n->call.receiver);
  NodeTransferConst(n, n->call.receiver);

  // convert to typecast or type constructor
  if (NodeIsType(n->call.receiver)) {
    n->type = n->call.receiver;
    if (n->call.receiver->kind == NStructType) {
      n->kind = NStructCons;
    } else {
      n->kind = NTypeCast;
      if (n->call.receiver->kind == NArrayType) {
        p->ctxtype = n->call.receiver->t.array.subtype;
      } else {
        p->ctxtype = n->call.receiver;
      }
    }
  }

  // args
  n->call.args = Const_nil;
  if (!got(p, TRParen)) {
    if (n->call.receiver->kind == NBasicType) {
      // fast path for basic types e.g. "i16(123)"
      n->call.args = expr(p, PREC_LOWEST, fl | PFlagRValue);
      if (n->call.receiver == n->call.args->type) {
        // short circuit e.g. "x = i64(3)"
        n = n->call.args;
      }
    } else {
      auto args = tupleTrailingComma(p, PREC_LOWEST, fl | PFlagRValue, TRParen);
      assert_debug(args->kind == NTuple);
      if (n->call.receiver->kind == NArrayType) {
        args->kind = NArray;
        if (!NodeIsUnresolved(args)) {
          want(p, TRParen);
          p->ctxtype = ctxtype; // restore ctxtype
          args->type = n->call.receiver;
          return args;
        }
      }
      // Note: the type of call.args should structually match the type of fun.params.
      // This reduces the work needed by the type resolver.
      if (args->array.a.len > 0) {
        n->call.args = args;
        NodeTransferUnresolved(n, args);
        NodeTransferConst(n, args);
      }
    }
    want(p, TRParen);
  }

  p->ctxtype = ctxtype; // restore ctxtype
  return n;
}


// Field = ( Id Type | NamedType ) ( "=" Expr )?
static Node* pField(Parser* p) {
  asserteq_debug(p->s.tok, TId);
  auto n = mknode(p, NField);
  n->field.name = p->s.name;
  nexttok(p); // consume name
  NodeSetConst(n);

  if (R_UNLIKELY(p->s.tok == TSemi)) {
    // e.g. "type" (implicit name)
    auto typename = mknode(p, NId);
    typename->ref.name = n->field.name;
    NodeSetConst(typename);
    n->type = resolve_id(p, typename, PFlagType);
    n->flags |= NodeFlagBase;
  } else {
    // e.g. "name type"
    p->typename = n->field.name; // use field name for anonymous structs
    n->type = pType(p, PFlagNone);
  }

  // check for duplicate names
  Node* existing = lookupsymShallow(p, n->field.name);
  if (existing) {
    syntaxerrp(p, n->pos, "Duplicate field name \"%s\"", n->field.name);
    build_notef(p->build, NodePosSpan(existing), "Also defined here");
  }

  defsym(p, n->field.name, n);

  if (got(p, TAssign)) {
    // e.g. "field = initval"
    n->field.init = expr(p, PREC_LOWEST, PFlagRValue);
    if (!n->type)
      n->type = n->field.init->type;
    NodeTransferUnresolved(n, n->field.init);
  }

  NodeTransferUnresolved(n, n->type);

  return n;
}


static bool end_block(Parser* p) {
  if (R_UNLIKELY(p->s.tok != TRBrace)) {
    syntaxerr(p, "expecting ; or }");
    return false;
  }
  // following is a dance to look ahead for tokens which when following
  // a block does not warrant an implicit semicolon. E.g. "if { } else ..."
  Scanner scanstate = p->s; // save scanner state
  nexttok(p); // consume '}' and read next token
  if (p->s.tok != TElse && p->s.tok != TSemi) {
    p->s = scanstate; // restore scan state
    p->s.tok = TSemi; // produce semicolon instead of '}'
  }
  return true;
}


// StructType = {" fields? "}"
// fields     = Field ( ";" Field )* ";"?
static Node* pStructTypeBody(Parser* p, PFlag fl, Node* n) {
  asserteq_debug(p->s.tok, TLBrace);
  nexttok(p); // consume "{"
  NodeSetConst(n);

  n->t.struc.name = p->typename;
  p->typename = NULL;

  pushScope(p);

  while (p->s.tok != TNone && p->s.tok != TRBrace) {
    if (R_UNLIKELY(p->s.tok != TId)) {
      syntaxerr(p, "expecting field or type name");
      return n;
    }
    Node* field = pField(p);
    NodeTransferUnresolved(n, field);
    NodeArrayAppend(p->build->mem, &n->t.struc.a, field);
    if (!got(p, TSemi))
      break;
  }

  end_block(p);

  popScope(p);
  // note: we only allow refs to previously defined fields to enforce no cycles.
  // Thus we don't save the scope here.
  return n;
}


// StructTypeDef = "struct" StructType
//!PrefixParselet TStruct
static Node* PStructType(Parser* p, PFlag fl) {
  auto n = mknode(p, NStructType);
  nexttok(p); // consume "struct"

  // TODO: when infix, assign n->t.struc.name

  // name
  if (p->s.tok == TId) {
    p->typename = p->s.name;
    defsym(p, p->s.name, n); // make sure to define the struct before parsing its body
    nexttok(p); // consume name
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // body
  if (R_LIKELY(p->s.tok == TLBrace))
    return pStructTypeBody(p, fl, n);

  syntaxerr(p, "expecting { ... }");
  return n;
}


// TypeDef = "type" Id Type
//
//!PrefixParselet TType
static Node* PTypeDef(Parser* p, PFlag fl) {
  auto n = mknode(p, NLet); // TODO: introduce NTypeAlias
  nexttok(p); // consume "type"
  NodeSetConst(n);

  // name
  if (p->s.tok == TId) {
    n->let.name = p->s.name;
    // make sure to define the type before parsing a potential struct body
    defsym(p, p->s.name, n);
    nexttok(p); // consume name
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
  }

  p->typename = n->let.name;
  n->let.init = pType(p, PFlagNone);
  n->type = n->let.init;
  NodeTransferUnresolved(n, n->let.init);
  return n;
}


// BlockOrStructType = Block | StructType
// Block = "{" Expr* "}"
//!PrefixParselet TLBrace
static Node* PBlockOrStructType(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return pStructTypeBody(p, fl, mknode(p, NStructType));

  auto n = mknode(p, NBlock);
  nexttok(p); // consume "{"
  pushScope(p);
  NodeSetConst(n);

  Node* cn = NULL;
  while (p->s.tok != TNone && p->s.tok != TRBrace) {
    cn = exprOrTuple(p, PREC_LOWEST, fl & ~PFlagRValue);
    NodeArrayAppend(p->build->mem, &n->array.a, cn);
    NodeTransferUnresolved(n, cn);
    NodeTransferConst(n, cn);
    if (!got(p, TSemi))
      break;
  }

  if (end_block(p) && cn) {
    // if last expression is a local, increment its refcount
    NodeRef(cn);

    n->array.a.v[n->array.a.len - 1] = useAsRValue(p, cn);
    // if (fl & PFlagRValue) {
    //   // block is used as an rvalue e.g. "x = { ... }"
    //   if (cn && cn->kind == NLet) {
    //     // last expression is a let binding and will be used/returned, so unwrap it.
    //     n->array.a.v[n->array.a.len - 1] = unwrapLet(cn);
    //   }
    // }
  }

  set_endpos(p, n);
  popScope(p);

  if (n->array.a.len == 1)
    return n->array.a.v[0];

  return n;
}

// PrefixOp = ( "+" | "-" | "!" ) Expr
//!PrefixParselet TPlus TMinus TExcalm
static Node* PPrefixOp(Parser* p, PFlag fl) {
  auto n = mknode(p, NPrefixOp);
  n->op.op = p->s.tok;
  nexttok(p);
  n->op.left = expr(p, PREC_LOWEST, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->op.left);
  return n;
}

// InfixOp = Expr ( "+" | "-" | "*" | "/" ) Expr
//!Parselet (TPlus ADD) (TMinus ADD)
//          (TStar MULTIPLY) (TSlash MULTIPLY)
//          (TLt COMPARE) (TGt COMPARE)
//          (TEq EQUAL) (TNEq EQUAL) (TLEq EQUAL) (TGEq EQUAL)
static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto n = mknode(p, NBinOp);
  NodeSetConst(n);
  n->op.op = p->s.tok;
  n->op.left = useAsRValue(p, left);
  nexttok(p);
  n->op.right = expr(p, e->prec, fl | PFlagRValue);
  // Specialization of NodeTransferConst2:
  n->flags = ((left->flags & NodeFlagConst) & (n->op.right->flags & NodeFlagConst));
  nodeTransferUnresolved2(n, left, n->op.right);
  return n;
}

// PostfixOp = Expr ( "++" | "--" )
//!Parselet (TPlusPlus UNARY_POSTFIX) (TMinusMinus UNARY_POSTFIX)
static Node* PPostfixOp(Parser* p, const Parselet* e, PFlag fl, Node* operand) {
  auto n = mknode(p, NPostfixOp);
  n->op.op = p->s.tok;
  n->op.left = useAsRValue(p, operand);
  nexttok(p); // consume "+"
  n->flags = (n->op.left->flags & NodeFlagConst);
  NodeTransferUnresolved(n, n->op.left);
  return n;
}

// Selector = Expr "." Id
//!Parselet (TDot MEMBER)
static Node* PSelector(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto n = mknode(p, NSelector);
  nexttok(p); // consume "."
  n->sel.operand = left; // note: id already gone through useAsRValue

  // member is a name
  if (R_UNLIKELY(p->s.tok != TId)) {
    syntaxerr(p, "expecting member name");
    return n;
  }
  n->sel.member = p->s.name;
  set_endpos(p, n); // extend n to include member id
  nexttok(p); // consume id

  n->flags = n->sel.operand->flags;
  return n;
}

// IntLit = [0-9]+
//!PrefixParselet TIntLit
static Node* PIntLit(Parser* p, PFlag fl) {
  auto n = mknode(p, NIntLit);
  NodeSetConst(n);
  size_t len = p->s.tokend - p->s.tokstart;
  if (!parseu64((const char*)p->s.tokstart, len, /*base*/10, &n->val.i)) {
    n->val.i = 0;
    syntaxerrp(p, n->pos, "invalid integer literal");
  }
  nexttok(p);
  n->val.ct = CType_int;
  n->type = Type_ideal;
  if (p->ctxtype)
    return convlit(p->build, n, p->ctxtype, ConvlitImplicit | ConvlitRelaxedType);
  return n;
}

// If = "if" Expr Expr
//!PrefixParselet TIf
static Node* PIf(Parser* p, PFlag fl) {
  auto n = mknode(p, NIf);
  NodeSetConst(n);
  nexttok(p);
  n->cond.cond = expr(p, PREC_LOWEST, fl | PFlagRValue);
  n->cond.thenb = expr(p, PREC_LOWEST, fl | PFlagRValue);
  nodeTransferUnresolved2(n, n->cond.cond, n->cond.thenb);
  NodeTransferConst2(n, n->cond.cond, n->cond.thenb);

  if (fl & PFlagRValue)
    n->flags |= NodeFlagRValue;

  if (p->s.tok == TElse) {
    nexttok(p);
    n->cond.elseb = expr(p, PREC_LOWEST, fl);
    NodeTransferUnresolved(n, n->cond.elseb);
    NodeTransferConst(n, n->cond.elseb);
  }

  return n;
}

// Return = "return" Expr?
//!PrefixParselet TReturn
static Node* PReturn(Parser* p, PFlag fl) {
  auto n = mknode(p, NReturn);
  NodeSetConst(n);
  if (R_UNLIKELY(p->fnest == 0)) {
    // return outside a function
    syntaxerrp(p, n->pos, "return outside function body");
  }
  nexttok(p);
  if (p->s.tok != TSemi && p->s.tok != TRBrace) {
    n->op.left = exprOrTuple(p, PREC_LOWEST, fl | PFlagRValue);
    NodeTransferUnresolved(n, n->op.left);
    NodeTransferConst(n, n->op.left);
  }
  return n;
}


// params = "(" param ("," param)* ","? ")"
// param  = Id Type? | Type
//
static Node* params(Parser* p) { // => NTuple
  // examples:
  //
  // (T)
  // (x T)
  // (x, y, z T)
  // (... T)
  // (x  ... T)
  // (x, y, z  ... T)
  // (T1, T2, T3)
  // (T1, T2, ... T3)
  //
  assert_debug(p->s.tok == TLParen);
  const Tok endtok = TRParen;
  auto n = mknode(p, NTuple);
  nexttok(p); // consume "("
  bool hasTypedParam = false; // true when at least one param has type; e.g. "x T"
  NodeArray typeq = Array_INIT_ON_STACK(32);
  PFlag fl = PFlagRValue;

  while (p->s.tok != endtok && p->s.tok != TNone) {
    auto field = mknode(p, NParam);
    if (p->s.tok == TId) {
      field->field.name = p->s.name;
      nexttok(p);
      // TODO: check if "<" follows. If so, this is a type.
      if (p->s.tok != endtok && p->s.tok != TComma && p->s.tok != TSemi) {
        field->type = pType(p, fl);
        hasTypedParam = true;
        // spread type to predecessors
        if (typeq.len > 0) {
          for (u32 i = 0; i < typeq.len; i++) {
            ((Node*)typeq.v[i])->type = field->type;
          }
          typeq.len = 0;
        }
      } else {
        NodeArrayAppend(p->build->mem, &typeq, field);
      }
    } else {
      // definitely just type, e.g. "fun(int)int"
      field->type = pType(p, fl);
    }
    NodeArrayAppend(p->build->mem, &n->array.a, field);
    if (!got(p, TComma)) {
      if (p->s.tok != endtok) {
        syntaxerr(p, "expecting comma or )");
        nexttok(p);
      }
      break;
    }
  }

  if (hasTypedParam) {
    // name-and-type form; e.g. "(x, y T, z Y)"
    if (typeq.len > 0) {
      // at least one param has type, but the last one does not.
      // e.g. "(x, y int, z)"
      syntaxerr(p, "expecting type");
    }
    u32 index = 0;
    for (u32 i = 0; i < n->array.a.len; i++) {
      Node* field = (Node*)n->array.a.v[i];
      field->field.index = index++;
      defsym(p, field->field.name, field);
      NodeTransferUnresolved(field, field->type);
      NodeTransferUnresolved(n, field->type);
    }
  } else {
    // type-only form, e.g. "(T, T, Y)"
    // make ident of each field->field.name where field->type == NULL
    //
    // TODO: for template parameters, this case means "name only without type constraints"
    //
    u32 index = 0;
    for (u32 i = 0; i < n->array.a.len; i++) {
      Node* field = (Node*)n->array.a.v[i];
      if (!field->type) {
        auto t = mknode(p, NId);
        t->ref.name = field->field.name;
        field->type = t;
        field->field.name = sym__;
        field->field.index = index++;
      }
      NodeTransferUnresolved(field, field->type);
      NodeTransferUnresolved(n, field->type);
    }
  }

  ArrayFree(&typeq, p->build->mem);
  want(p, endtok);
  return n;
}

// template parameters, e.g. "<T, R=T>"
static Node* templateParams(Parser* p) {
  assert(p->s.tok == TLt);
  PFlag fl = PFlagNone; // lvalue semantics
  auto tuple = mknode(p, NTuple);
  nexttok(p); // consume "<"
  do {
    if (R_UNLIKELY(p->s.tok != TId)) {
      syntaxerr(p, "expecting %s", TokName(TId));
      break;
    }
    auto name = mknode(p, NId);
    name->ref.name = p->s.name;
    nexttok(p); // consume id
    Node* init = NULL;
    if (got(p, TAssign)) // T=something
      init = prefixExpr(p, fl | PFlagRValue);
    Node* letn = makeLet(p, name, init);
    letn->type = Type_nil;
    NodeArrayAppend(p->build->mem, &tuple->array.a, letn);
  } while (got(p, TComma) && p->s.tok != TGt);
  want(p, TGt);
  set_endpos(p, tuple);
  return tuple;
}


// Fun     = FunDef | FunExpr
// FunDef  = "fun" Id? params? Type? Block?
// FunExpr = "fun" Id? params? Type? "->" Expr
//
// e.g.
//   fun foo (x, y int) int
//   fun foo (x, y int) int { x * y }
//   fun foo { 5 }
//   fun foo -> 5
//   fun (x, y int) int { x * y }
//   fun { 5 }
//   fun -> 5
//
//!PrefixParselet TFun
static Node* PFun(Parser* p, PFlag fl) {
  auto n = mknode(p, NFun);
  nexttok(p); // consume "fun"

  // name
  if (p->s.tok == TId) {
    auto name = p->s.name;
    n->fun.name = name;
    defsym(p, name, n);
    nexttok(p);
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // template parameters, e.g. "fun foo<T, R>(...)"
  if (p->s.tok == TLt) {
    pushScope(p);
    n->fun.tparams = templateParams(p);
    // Note: no NodeTransferUnresolved for params
  } else {
    NodeSetConst(n);
  }

  // function parameters
  pushScope(p);
  if (p->s.tok == TLParen) {
    auto pa = params(p);
    // Note: the type of fun.params should structually match the type of call.args.
    // This reduces the work needed by the type resolver.
    if (pa->array.a.len > 0) {
      n->fun.params = pa;
      NodeTransferUnresolved(n, pa);
    }
  }

  // result type(s)
  if (p->s.tok != TLBrace && p->s.tok != TSemi) {
    if (p->s.tok == TRArr) {
      // e.g. "fun foo() -> 123" => "fun foo() auto { 123 }"
      n->fun.result = Type_auto;
    } else {
      n->fun.result = pType(p, fl);
      NodeTransferUnresolved(n, n->fun.result);
    }
  } else {
    // no result type specified is the same as "nil" (does not return a value)
    n->fun.result = Type_nil;
  }

  // set endpos
  // FIXME: this sets endpos to the next following token, not the last token.
  // Example:
  // 1  fun add(x int, y uint) int
  // 2
  // Gets an endpos of 2:0 (which is invalid since column is zero so formatters will ignore it)
  // It should get endpos 1:24 (for "int")
  set_endpos(p, n);

  // body
  p->fnest++;
  PFlag bodyfl = n->fun.result == Const_nil ? (fl & ~PFlagRValue) : (fl | PFlagRValue);
  if (p->s.tok == TLBrace) {
    // assign body before parsing so that we can check for it in pBlock
    assert_debug((fl & PFlagType) == 0); // needed for PBlockOrStructType
    n->fun.body = PBlockOrStructType(p, bodyfl);
  } else if (got(p, TRArr)) {
    n->fun.body = exprOrTuple(p, PREC_LOWEST, bodyfl);
  }
  p->fnest--;

  if (n->fun.body) {
    NodeTransferUnresolved(n, n->fun.body);
    NodeTransferConst(n, n->fun.body);
  }

  popScope(p); // function parameter scope
  if (n->fun.tparams)
    popScope(p); // template parameter scope

  return n;
}


// end of parselets
// ============================================================================================
// ============================================================================================


//PARSELET_MAP_BEGIN
// automatically generated by misc/gen_parselet_map.py; do not edit
static const Parselet parselets[TMax] = {
  [TNil] = {PNil, NULL, PREC_MEMBER},
  [TAuto] = {PAuto, NULL, PREC_MEMBER},
  [TId] = {PId, PIdTrailing, PREC_ASSIGN},
  [TVar] = {PVar, NULL, PREC_MEMBER},
  [TLParen] = {PGroup, PCall, PREC_COMMA},
  [TLBrack] = {PArrayPrefix, PArrayInfix, PREC_MEMBER},
  [TStruct] = {PStructType, NULL, PREC_MEMBER},
  [TType] = {PTypeDef, NULL, PREC_MEMBER},
  [TLBrace] = {PBlockOrStructType, NULL, PREC_MEMBER},
  [TPlus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TMinus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TExcalm] = {PPrefixOp, NULL, PREC_MEMBER},
  [TIntLit] = {PIntLit, NULL, PREC_MEMBER},
  [TIf] = {PIf, NULL, PREC_MEMBER},
  [TReturn] = {PReturn, NULL, PREC_MEMBER},
  [TFun] = {PFun, NULL, PREC_MEMBER},
  [TAssign] = {NULL, PLetOrAssign, PREC_ASSIGN},
  [TAs] = {NULL, PAs, PREC_LOWEST},
  [TStar] = {NULL, PInfixOp, PREC_MULTIPLY},
  [TSlash] = {NULL, PInfixOp, PREC_MULTIPLY},
  [TLt] = {NULL, PInfixOp, PREC_COMPARE},
  [TGt] = {NULL, PInfixOp, PREC_COMPARE},
  [TEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TNEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TLEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TGEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TPlusPlus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TMinusMinus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TDot] = {NULL, PSelector, PREC_MEMBER},
};
//PARSELET_MAP_END


static Node* prefixExpr(Parser* p, PFlag fl) {
  // find prefix parselet
  assert((u32)p->s.tok < (u32)TMax);
  auto parselet = &parselets[p->s.tok];
  if (!parselet->fprefix) {
    // dlog("prefixExpr NOT found for %s", TokName(p->s.tok));
    syntaxerr(p, "expecting expression");
    auto n = bad(p);
    Tok followlist[] = { TRParen, TRBrace, TRBrack, TSemi, 0 };
    advance(p, followlist);
    return n;
  }
  // dlog("prefixExpr FOUND for %s", TokName(p->s.tok));
  return p->expr = parselet->fprefix(p, fl);
}


static Node* infixExpr(Parser* p, int precedence, PFlag fl, Node* left) {
  // wrap parselets
  // TODO: Should we set fl|PFlagRValue here?
  while (p->s.tok != TNone) {
    auto parselet = &parselets[p->s.tok];
    // if (parselet->f) {
    //   dlog("infix parselet FOUND for %s; parselet->prec=%d < precedence=%d = %s",
    //     TokName(p->s.tok), parselet->prec, precedence,
    //     (int)parselet->prec < precedence ? "Y" : "N");
    // } else {
    //   dlog("infix parselet NOT found for %s", TokName(p->s.tok));
    // }
    if (!parselet->f || (int)parselet->prec < precedence) {
      break;
    }
    assert(parselet);
    left = p->expr = parselet->f(p, parselet, fl, left);
  }
  return left;
}


static Node* expr(Parser* p, int precedence, PFlag fl) {
  // Note: precedence should match the calling parselet's own precedence
  auto left = prefixExpr(p, fl);
  return infixExpr(p, precedence, fl, left);
}


// exprOrTuple = Expr | Tuple
//
// This function has different behavior depending on PFlagRValue:
//
//   PFlagRValue=OFF consumes a prefixExpr, then a possible tuple and finally calls
//   infixExpr to include the tuple in an infix expression like t + y.
//
//   - PFlagRValue=OFF is "conservative" used for lvalues, e.g. (a b c) in a,b,c=1,2,3
//   - PFlagRValue=ON is "greedy" and used for rvalues, e.g. (x (y + z)) in _,_=x,y+z
//
//   Consider the following source code:
//     a, b + c, d
//   Parsing this with the different functions yields:
//   - PFlagRValue=OFF => (+ (a b) c)
//   - PFlagRValue=ON => (a (+ b c) d)
//
//   Explanation of PFlagRValue=OFF:
//   • PFlagRValue=OFF calls prefixExpr => a
//   • PFlagRValue=OFF sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=OFF calls prefixExpr => b
//   • PFlagRValue=OFF end tuple => (a b)
//   • infixExpr with tuple as the LHS:
//     • infixExpr calls '+' parselet
//       • '+' parselet reads RHS by calling expr:
//         • expr calls prefixExpr (which in turn calls 'ident' parselet) => c
//         • expr returns the c identifier (NId)
//       • '+' parselet produces LHS + RHS => (+ (a b) c)
//     • return
//   • return
//
//   Explanation of PFlagRValue=ON:
//   • PFlagRValue=ON calls expr => a
//   • PFlagRValue=ON sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=ON calls expr
//     • expr calls prefixExpr => b
//     • expr calls infixExpr with b as LHS:
//       • infixExpr calls '+' parselet
//         • '+' parselet reads RHS by calling expr:
//           • expr calls prefixExpr => c
//           • expr returns the c identifier (NId)
//         • '+' parselet produces LHS + RHS => (+ b c)
//       • return
//     • return
//   • PFlagRValue=ON calls expr after another comma
//     • calls prefixExpr => b
//   • PFlagRValue=ON see no more comma; ends the tuple => (a (+ b c) d)
//
static Node* exprOrTuple(Parser* p, int precedence, PFlag fl) {
  auto left = (
    fl & PFlagRValue ? expr(p, precedence, fl) :
                       prefixExpr(p, fl) ); // read a prefix expression, like an identifier

  if (got(p, TComma)) {
    // start a tuple
    auto g = mknode(p, fl & PFlagType ? NTupleType : NTuple);
    NodeArrayAppend(p->build->mem, &g->array.a, left);
    NodeTransferUnresolved(g, left);
    g->flags = left->flags & NodeFlagConst;
    if (fl & PFlagRValue) {
      do {
        Node* cn = expr(p, precedence, fl);
        NodeArrayAppend(p->build->mem, &g->array.a, cn);
        NodeTransferUnresolved(g, cn);
        NodeTransferConst(g, cn);
      } while (got(p, TComma));
    } else {
      do {
        Node* cn = prefixExpr(p, fl);
        NodeArrayAppend(p->build->mem, &g->array.a, cn);
        NodeTransferUnresolved(g, cn);
        NodeTransferConst(g, cn);
      } while (got(p, TComma));
    }
    set_endpos(p, g);
    left = g;
  }

  if (fl & PFlagRValue)
    return left;

  // wrap in possible infix expression, e.g. "left + right"
  return infixExpr(p, precedence, fl, left);
}


Node* CreatePkgAST(Build* build, Scope* pkgscope) {
  // Scope* pkgscope
  auto n = NewNode(build->mem, NPkg);
  n->cunit.name = build->pkg->name; // ok if null
  n->cunit.scope = pkgscope;
  // Note: Do not set n->type as it would prevent type resolver from visiting files
  return n;
}


Node* Parse(Parser* p, Build* build, Source* src, ParseFlags fl, Scope* pkgscope) {
  // initialize scanner
  if (!ScannerInit(&p->s, build, src, fl))
    return NULL;

  p->build = build;
  p->pkgscope = pkgscope;
  p->expr = NULL;
  p->fnest = 0;

  // scopestack
  if (p->scopestack.ptr == NULL) {
    p->scopestack.cap = countof(p->scopestack.storage);
    p->scopestack.ptr = p->scopestack.storage;
  } else {
    // reuse already-allocated memory
    p->scopestack.len = 0;
    p->scopestack.base = 0;
  }

  // load first token
  nexttok(p);

  // TODO: ParseFlags, where one option is PARSE_IMPORTS to parse only imports and then stop.

  auto file = mknode(p, NFile);
  file->cunit.name = src->filename; // ok if null

  while (p->s.tok != TNone) {
    Node* n = exprOrTuple(p, PREC_LOWEST, PFlagNone);
    NodeArrayAppend(p->build->mem, &file->cunit.a, n);
    NodeTransferUnresolved(file, n);

    // // print associated comments
    // auto c = p->s.comments;
    // while (c) { printf("#%.*s\n", (int)c->len, c->ptr); c = c->next; }
    // p->s.comments = p->s.comments_tail = NULL;
    // // TODO: Add "comments" to Node struct and if caller requests inclusion of comments,
    // // assign these comments to the node. This should be done in mknode and not here.

    // check that we either got a semicolon or EOF
    if (p->s.tok != TNone && !got(p, TSemi)) {
      syntaxerr(p, "after top level declaration");
      if (n && n->kind == NId) {
        build_notef(p->build, (PosSpan){n->pos, NoPos}, "Did you mean \"var %s\"?", n->ref.name);
      }
      Tok followlist[] = { TType, TFun, TSemi, 0 };
      advance(p, followlist);
    }
  }

  return file;
}


ASSUME_NONNULL_END
