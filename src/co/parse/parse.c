//
// Pratt-style recursive descent parser.
//
// Syntax productions are parsed by functions dubbed "parselets".
// They are defined with a magical comment described by the following eBNF:
//
//   infix  = <LF> "//!Parselet" ( "(" Tok Precedence ")" )+
//   prefix = <LF> "//!PrefixParselet" Tok+
//
// Examples:
//
//   //!Parselet (TPlus ADD) (TMinus ADD) (TStar MULTIPLY) (TSlash MULTIPLY)
//   static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left)
//
//   //!PrefixParselet TPlus TMinus TExcalm
//   static Node* PPrefixOp(Parser* p, PFlag fl)
//
// The parselet dispatch map for all tokens is generated by a script (gen_parselet_map.py)
// which builds the "parselets" table (see end of file.)

// panic() on parse errors
#define DEBUG_PANIC_ON_PARSE_ERROR
//
// enable debug messages for pushScope() and popScope()
//#define DEBUG_SCOPE_PUSH_POP
//
// enable debug dumping of symbol bindings (scope stack)
//#define DEBUG_SCOPE_BINDINGS
//
// enable debug messages for defsym()
//#define DEBUG_DEFSYM
//
// enable debug messages for resolve_id()
//#define DEBUG_LOOKUPSYM
//
#include "../common.h"
#include "parse.h"

ASSUME_NONNULL_BEGIN


// Operator precedence
// Precedence    Operator
//     5             *  /  %  <<  >>  &  &^
//     4             +  -  |  ^
//     3             ==  !=  <  <=  >  >=
//     2             &&
//     1             ||
//
typedef enum Precedence {
  PREC_LOWEST,
  PREC_ASSIGN,
  PREC_COMMA,
  PREC_LOGICAL_OR,
  PREC_LOGICAL_AND,
  PREC_BITWISE_OR,
  PREC_BITWISE_XOR,
  PREC_BITWISE_AND,
  PREC_EQUAL,
  PREC_COMPARE,
  PREC_SHIFT,
  PREC_ADD,
  PREC_MULTIPLY,
  PREC_UNARY_PREFIX,
  PREC_UNARY_POSTFIX,
  PREC_MEMBER,
} Precedence;


typedef enum PFlag {
  PFlagNone   = 0,
  PFlagRValue = 1 << 0, // parsing an rvalue
  PFlagType   = 1 << 1, // parsing a type
} PFlag;


typedef struct Parselet Parselet;

typedef Node* (ParseletPrefixFun)(Parser* p, PFlag fl);
typedef Node* nullable (ParseletFun) (Parser* p, const Parselet* e, PFlag fl, Node* left);
  // if an infix parselet returns null, "left" becomes the result

typedef struct Parselet {
  ParseletPrefixFun* fprefix;
  ParseletFun*       f;
  Precedence         prec;
} Parselet;

typedef struct UnresolvedNode {
  Source* src;
  Node*   n;
} UnresolvedNode;

typedef struct Unresolved {
  Sym            sym;
  u32            nodeslen;
  u32            nodescap;
  UnresolvedNode nodes[];
} Unresolved;


#define nexttok(p) ScannerNext(&(p)->s)


// syntaxerrp reports a source-token related syntax error.
// It will point to the source location of the last-scanned token.
// If n is not NULL, use source location of n instead of current location.
//
static Pos syntaxerrp(Parser* p, Pos pos, const char* format, ...) {
  if (pos == NoPos)
    pos = ScannerPos(&p->s);

  va_list ap;
  va_start(ap, format);
  auto msg = str_new(64);
  if (strlen(format) > 0)
    msg = str_appendfmtv(msg, format, ap);
  va_end(ap);

  const char* tokname;
  if (p->s.tok == TNone) {
    tokname = "end of input";
  } else if (p->s.tok == TSemi && p->s.tokstart == p->s.linestart - 1) {
    // Implicit semicolon from linebreak
    tokname = "line break";
    // To improve the error message, find the pos of the linebreak
    const u8* prevlinestart = p->s.prevtokend - 1;
    while (prevlinestart > p->s.src->body) {
      if (*prevlinestart == '\n')
        break;
      prevlinestart--;
    }
    u32 col = (u32)(uintptr_t)(p->s.prevtokend - prevlinestart);
    pos = pos_make(p->s.srcposorigin, p->s.lineno - 1, col, /*span*/0);
  } else {
    tokname = TokName(p->s.tok);
  }

  Str stmp = NULL;
  if (str_len(msg) == 0) {
    stmp = msg;
    msg = str_fmt("unexpected %s", tokname);
  } else if (str_hasprefixcstr(msg, "expecting ")) {
    stmp = msg;
    const char* sep = tokname[0] == ';' ? " " : ", "; // avoid ";,"
    msg = str_fmt("unexpected %s%s%s", tokname, sep, msg);
  } else if (
    str_hasprefixcstr(msg, "after ") ||
    str_hasprefixcstr(msg, "in ") ||
    str_hasprefixcstr(msg, "at ")
  ) {
    stmp = msg;
    msg = str_fmt("unexpected %s %s", tokname, msg);
  }
  if (stmp)
    str_free(stmp);

  build_diag(p->build, DiagError, (PosSpan){pos, NoPos}, msg);

  #ifdef DEBUG_PANIC_ON_PARSE_ERROR
  panic("DEBUG_PANIC_ON_PARSE_ERROR %s", msg);
  #endif

  str_free(msg);
  return pos;
}


// syntaxerr = syntaxerrp(p, <srcpos of current token>, ...)
#define syntaxerr(p, format, ...) \
  syntaxerrp((p), NoPos, format, ##__VA_ARGS__)


// toklistHas returns true if t is in list (list is expected to be 0-terminated)
static bool toklistHas(const Tok* list, Tok t) {
  Tok t2;
  while ((t2 = *list++)) {
    if (t2 == t)
      return true;
  }
  return false;
}


// advance consumes tokens until it finds a token of the followlist.
// It is used to recover from parse errors and is not speed critical.
//
static void advance(Parser* p, const Tok* followlist) {
  nexttok(p); // guarantee progress
  if (followlist == NULL || *followlist == 0) {
    return;
  }
  if (p->fnest > 0) {
    // Stop at keywords that start a statement.
    // They are good synchronization points in case of syntax
    // errors and (usually) shouldn't be skipped over.
    while (!toklistHas(followlist, p->s.tok)) {
      switch (p->s.tok) {
        case TNone:
        case TBreak:
        case TContinue:
        case TDefer:
        case TFor:
        case TIf:
        case TAuto:
        case TReturn:
        case TSwitch:
        case TType:
          return;
        default:
          break;
      }
      // dlog("skip %s", TokName(p->s.tok));
      nexttok(p);
    }
  } else {
    while (p->s.tok != TNone && !toklistHas(followlist, p->s.tok)) {
      // dlog("skip %s", TokName(p->s.tok));
      nexttok(p);
    }
  }
  if (p->s.tok == TSemi) {
    nexttok(p);
  }
}


// mknode allocates a new ast node
inline static Node* mknode(Parser* p, NodeKind kind) {
  auto n = NewNode(p->build->mem, kind);
  n->pos = ScannerPos(&p->s);
  return n;
}

ALWAYS_INLINE static Node* set_endpos(Parser* p, Node* n) {
  n->endpos = ScannerPos(&p->s);
  return n;
}

// precedence should match the calling parselet's own precedence
static Node* expr(Parser* p, int precedence, PFlag fl);
static Node* prefixExpr(Parser* p, PFlag fl);
static Node* infixExpr(Parser* p, int precedence, PFlag fl, Node* left);

// exprOrTuple = Expr | Tuple
static Node* exprOrTuple(Parser* p, int precedence, PFlag fl);


static void scopestackGrow(Parser* p) {
  p->scopestack.cap *= 2;
  Mem mem = p->build->mem;
  if (p->scopestack.ptr == p->scopestack.storage) {
    p->scopestack.ptr = memalloc(mem, sizeof(void*) * p->scopestack.cap);
    memcpy(p->scopestack.ptr, p->scopestack.storage, sizeof(void*) * p->scopestack.len);
  } else {
    p->scopestack.ptr = memrealloc(mem, p->scopestack.ptr, sizeof(void*) * p->scopestack.cap);
  }
}

#ifdef DEBUG_SCOPE_BINDINGS
  static void scopestackDebugDump(Parser* p) {
    dlog("scope bindings:");
    FILE* fp = stderr;
    // stack is arranged like this: | It can also look like this: (empty current scope)
    // [10] key4                    | [10] -- base=6 --
    // [9]  value4                  | [6]  -- base=0 --
    // [8]  key3                    | [5]  key2
    // [7]  value3                  | [4]  value2
    // [6]  -- base=0 --            | [3]  key1
    // [5]  key2                    | [2]  value1
    // [4]  value2                  |
    // [3]  key1                    |
    // [2]  value1                  |
    uintptr_t i = p->scopestack.len;
    uintptr_t base = p->scopestack.base;
    while (i > 1) {
      i--;
      if (i == base) {
        auto prevbase = (size_t)base;
        base = (uintptr_t)p->scopestack.ptr[i];
        fprintf(fp, "  --------- (base %zu -> %zu)\n", prevbase, (size_t)base);
      } else {
        Sym key = (Sym)p->scopestack.ptr[i];
        i--;
        Node* n = (Node*)p->scopestack.ptr[i];
        fprintf(fp, "  %s => %s %s\n", key, NodeKindName(n->kind), fmtnode(n));
      }
    }
  }
#endif /* DEBUG_SCOPE_BINDINGS */


static void scopestackCheckUnused(Parser* p) {
  // only run when p->build->debug==true
  assert_debug(p->scopestack.len > 0);
  uintptr_t i = p->scopestack.len;
  uintptr_t base = p->scopestack.base;
  while (--i > base) {
    Sym key = (Sym)p->scopestack.ptr[i];
    i--;
    Node* n = (Node*)p->scopestack.ptr[i];
    //dlog(">>  %s => %s %s", key, NodeKindName(n->kind), fmtnode(n));
    if (R_UNLIKELY(key != sym__ && n->kind == NVar && n->var.nrefs == 0)) {
      // TODO: combine the error message with that of package-level reporter
      PosSpan ps = { n->pos, n->endpos };
      build_warnf(p->build, ps, "unused %s %s",
        ( NodeIsParam(n) ? "function parameter" :
          n->var.init && NodeIsType(n->var.init) ? "type" :
          "variable" ),
        n->var.name);
    }
  }
}


// pushScope adds a new scope to the stack. Returns the new scope.
static void pushScope(Parser* p) {
  // add "scope starts here" to scopestack
  if (R_UNLIKELY(p->scopestack.cap - p->scopestack.len == 0))
    scopestackGrow(p);

  #ifdef DEBUG_SCOPE_PUSH_POP
    dlog("push scope; base %zu -> %zu",
      (size_t)p->scopestack.base, (size_t)p->scopestack.len);
  #endif

  p->scopestack.ptr[p->scopestack.len++] = (void*)p->scopestack.base;
  p->scopestack.base = p->scopestack.len - 1;
}


// popScope removes the topmost scope
static void popScope(Parser* p) {
  #ifdef DEBUG_SCOPE_PUSH_POP
  {
    size_t nbindings = (size_t)(p->scopestack.len - p->scopestack.base) / 2;
    dlog("pop scope; base %zu -> %zu (%zu bindings)",
      (size_t)p->scopestack.base,
      (size_t)(uintptr_t)p->scopestack.ptr[p->scopestack.base],
      nbindings);
  }
  #endif

  #ifdef DEBUG_SCOPE_BINDINGS
    scopestackDebugDump(p);
  #endif

  // rewind and restore base of parent scope
  p->scopestack.len = p->scopestack.base;
  p->scopestack.base = (uintptr_t)p->scopestack.ptr[p->scopestack.len];
}


inline static void popScopeAndCheckUnused(Parser* p) {
  // check for unused variables and parameters
  if (p->build->debug && p->scopestack.len - p->scopestack.base > 1)
    scopestackCheckUnused(p);
  popScope(p);
}


inline static void scopestackPush(Parser* p, Sym key, Node* value) {
  assert_debug(p->scopestack.cap - p->scopestack.len > 1);
  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)value;
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)key;
  p->scopestack.len += 2;
}

// lookupsymPkg looks up node for key in the package scope.
static Node* nullable lookupsymPkg(Parser* p, Sym key) {
  // look in the package's scope (including universe)
  #ifdef DEBUG_LOOKUPSYM
    dlog("lookup %s fallback to pkgscope", key);
  #endif
  Node* n = (Node*)ScopeLookup(p->pkgscope, key);
  if (n) {
    if (NodeIsUnused(n)) // must check to avoid editing universe
      NodeClearUnused(n);
    if (p->scopestack.cap - p->scopestack.len > 1) {
      // Put it on the scopestack if there's space, as this will likely be
      // requested soon again.
      // For example, in this case "int" will lookupsym many times:
      //   fun foo(x, y int) int {
      //     tmp = 3 as int
      //     tmp + x + y
      //   }
      // However, with this optimization lookup of "int" only takes the slow path once
      // (for the first "int" in function params) and is then found in the local
      // scopestack for all remaining lookups of "int".
      scopestackPush(p, key, n);
    }
  }
  return n;
}

// lookupsym looks up node for key in the current scope, searching all parent scopes.
// This function is inline because it's only used in one place.
inline static Node* nullable lookupsym(Parser* p, Sym key) {
  uintptr_t i = p->scopestack.len;
  uintptr_t base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      base = (uintptr_t)p->scopestack.ptr[i];
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  // not found in the current file's scope; look in the package's scope (including universe)
  return lookupsymPkg(p, key);
}

static Node* nullable lookupsymShallow(Parser* p, Sym key) {
  uintptr_t i = p->scopestack.len;
  uintptr_t base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      break;
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  return NULL;
}

static void defsym(Parser* p, Sym s, Node* n) {
  #ifdef DEBUG_DEFSYM
  auto existing = lookupsymShallow(p, s);
  if (existing) {
    dlog("defsym %s => %s (replacing %s)", s, NodeKindName(n->kind), NodeKindName(existing->kind));
  } else {
    dlog("defsym %s => %s", s, NodeKindName(n->kind));
  }
  #endif

  if (R_UNLIKELY(p->scopestack.cap - p->scopestack.len < 2))
    scopestackGrow(p);

  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)n; // value
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)s; // key
  p->scopestack.len += 2;

  if (p->scopestack.base == 0) {
    // top level definition -- add to pkgscope.
    // TODO: For imports, make sure to add to file scope instead of package scope
    //       Lazily create: p->file->array.scope=ScopeNew(p->pkgscope, p->build->mem);
    ScopeAssoc(p->pkgscope, s, n);
  }
}


// If the current token is t, advances scanner and returns true.
inline static bool got(Parser* p, Tok t) {
  if (p->s.tok != t)
    return false;
  nexttok(p);
  return true;
}

// want reports a syntax error if p->s.tok != t.
// In any case, this function will advance the scanner by one token.
inline static void want(Parser* p, Tok t) {
  if (R_UNLIKELY(!got(p, t))) {
    syntaxerr(p, "expecting %s", TokName(t));
    nexttok(p);
  }
}

static Node* bad(Parser* p) {
  return mknode(p, NBad);
}


static bool name_is_pub(Sym name) {
  assert_debug(symlen(name) > 0);
  return name[0] != '_';
}


static Node* simplify_id(Parser* p, Node* id, PFlag fl) {
  asserteq_debug(id->kind, NId);
  assertnotnull_debug(id->ref.target);
  assertnotnull_debug(id->ref.name);

  Node* target = id->ref.target;

  // unwind var targeting a type
  Node* t = target;
  while (t->kind == NVar && NodeIsConst(t) && !NodeIsParam(t) && t->var.init) {
    t = t->var.init;
    // // Note: no NodeUnrefVar here
    // if (NodeIsType(t))
    //   return t;
  }

  if (fl & PFlagRValue) {
    target = t;
    id->flags |= NodeFlagRValue;
  }

  if (NodeIsPrimitiveConst(target)) // NNil, NBasicType, NBoolLit
    return target;

  return id;

  // // The target is a type; short-circuit and return that instead of the id
  // if (NodeIsConst(id) &&
  //     (NodeIsType(target) || target->kind == NFun || target->kind == NMacro) )
  // {
  //   return target;
  // }

  // if ((fl & PFlagRValue) == 0)
  //   return id;

  // switch (target->kind) {
  //   case NVar:
  //     NodeRefVar(target);
  //     return target;
  //   case NField:
  //     return target;
  //   default:
  //     return id;
  // }
}


// resolve_id resolves an identifier.
// Its target is assumed to be NULL.
// Returns id or its target
static Node* resolve_id(Parser* p, Node* id, PFlag fl) {
  asserteq_debug(id->kind, NId);
  assertnull_debug(id->ref.target);
  assertnotnull_debug(id->ref.name);

  id->ref.target = lookupsym(p, id->ref.name);

  #ifdef DEBUG_LOOKUPSYM
    if (id->ref.target == NULL) {
      dlog("lookup %s => (not found; unresolved)", id->ref.name);
    } else {
      Node* n = id->ref.target;
      dlog("lookup %s => %s %s", id->ref.name, NodeKindName(n->kind), fmtnode(n));
    }
  #endif

  if (id->ref.target == NULL) {
    // not found
    NodeSetUnresolved(id);
    id->flags |= NodeFlagRValue;
    return id;
  }

  id->type = id->ref.target->type;
  NodeRefAny(id->ref.target);

  switch (id->ref.target->kind) {
    case NMacro:
    case NFun:
      // Note: Don't transfer "unresolved" attribute of functions
      break;
    // case NVar:
    //   if (NodeIsConst(id->ref.target))
    //     NodeSetHasConstVar(id);
    //   FALLTHROUGH;
    default:
      NodeTransferUnresolved(id, id->ref.target);
  }

  // NodeTransferConst(id, id->ref.target);
  id->flags = (id->flags & ~NodeFlagConst) | (id->ref.target->flags & NodeFlagConst);

  R_MUSTTAIL return simplify_id(p, id, fl);
}


// useAsRValue is used to lazily resolve identifiers which are used in rvalue position
// that is unknown ahead of time. Returns expr or its effective value.
// For example:
//   fun foo(x, y int) int {
//     x
//     ~ might be the beginning of a var definition
// Scenario 1:
//   fun foo(x, y int) int {
//     x = 4
//     ~~~~~ lvalue in a var definition; defining not resolving.
// Scenario 2:
//   fun foo(x, y int) int {
//     x + y
//     ~~~~~  Used as an rvalue in an op; call useAsRValue(x)
//
static Node* useAsRValue(Parser* p, Node* expr) {
  switch (expr->kind) {
    case NId:
      if (expr->ref.target)
        return simplify_id(p, expr, PFlagRValue);
      return resolve_id(p, expr, PFlagRValue);

    case NBasicType:
      return expr; // immutable memory, allocated by universe

    default:
      expr->flags |= NodeFlagRValue;
      return expr;
  }
}


// nodeTransferUnresolved2 is like NodeTransferUnresolved but takes two inputs which flags
// are combined as a set union.
inline static void nodeTransferUnresolved2(Node* parent, Node* child1, Node* child2) {
  // parent is unresolved if child1 OR child2 is unresolved
  parent->flags |= (child1->flags & NodeFlagUnresolved) | (child2->flags & NodeFlagUnresolved);
}


static Type* nullable set_ctxtype(Parser* p, Type* nullable new_ctxtype) {
  auto old_ctxtype = p->ctxtype;
  p->ctxtype = new_ctxtype && NodeIsType(new_ctxtype) ? new_ctxtype : NULL;
  return old_ctxtype;
}


// ============================================================================================
// ============================================================================================
// Parselets (upper case PName = pratt parselet, lower case pName = helper parselet)


// Type (always rvalue)
inline static Type* pType(Parser* p, PFlag fl) {
  // return exprOrTuple(p, PREC_MEMBER, fl | PFlagType | PFlagRValue); // "a, b" => "a, b"
  return expr(p, PREC_MEMBER, fl | PFlagType | PFlagRValue); // "a, b" => "a"
}

inline static Node* pId(Parser* p) {
  asserteq_debug(p->s.tok, TId);
  auto n = mknode(p, NId);
  n->ref.name = p->s.name;
  nexttok(p);
  return n;
}


//!PrefixParselet TNil
static Node* PNil(Parser* p, PFlag fl) {
  nexttok(p);
  return Const_nil;
}

//!PrefixParselet TAuto
static Node* PAuto(Parser* p, PFlag fl) {
  nexttok(p);
  return Type_auto;
}

// PId -- identifier (as prefix)
// When parsing an rvalue identifier, PFlagRValue is set in fl
//
//!PrefixParselet TId
static Node* PId(Parser* p, PFlag fl) {
  auto n = pId(p);
  // eagerly resolve identifiers in rvalue position
  //if ((fl & PFlagRValue) || (p->s.tok != TAssign && p->s.tok != TId && p->s.tok != TComma))
  if (fl & PFlagRValue)
    return resolve_id(p, n, fl);
  return n;
}


static Node* make_var(Parser* p, const Node* name, Node* nullable init) {
  asserteq_debug(name->kind, NId);
  auto n = NewNode(p->build->mem, NVar);
  NodeSetConst(n);
  NodeSetUnused(n);
  n->pos = name->pos; // TODO: expand pos span to include type?
  n->var.name = name->ref.name;
  if (p->fnest == 0 && name_is_pub(n->var.name))
    NodeSetPublic(n);
  if (init) {
    n->var.init = init;
    if (init->type != Type_ideal)
      n->type = init->type;
    NodeTransferUnresolved(n, init);
  }
  defsym(p, name->ref.name, n);
  return n;
}


// VarDecl = "var" Id (Type | Type? "=" Expr)
// ConstDecl = "const" Id Type? "=" Expr
//
// e.g. "var x int", "var x = 4", "var x int = 4"
// e.g. "const x int", "const x = 4", "const x int = 4"
//
//!PrefixParselet TVar TConst
static Node* PVar(Parser* p, PFlag fl) {
  auto n = mknode(p, NVar);
  NodeSetConst(n);
  NodeSetUnused(n);
  n->var.isconst = p->s.tok == TConst;
  // Sym defname = p->s.name;
  nexttok(p); // consume "var" or "const"

  // name
  // TODO: multi-name e.g. "var x, y, z int", "var x, y, z = 1, 2, 3"
  if (R_UNLIKELY(p->s.tok != TId)) {
    syntaxerr(p, "expecting %s", TokName(TId));
  } else {
    n->var.name = p->s.name;
    n->pos = pos_union(n->pos, ScannerPos(&p->s));
  }
  nexttok(p);

  if (p->s.tok != TAssign) {
    // e.g. "var name type"
    if (R_UNLIKELY(p->s.tok == TSemi)) {
      // improved error message (we'd get a generic one from pType)
      Pos epos = syntaxerr(p, "expecting type or assignment of value");
      // help message (fixup)
      if (n->var.isconst) {
        // const x
        build_notef(p->build, (PosSpan){epos,epos},
          "Fix by assigning a value \"%s = VALUE\"", n->var.name);
      } else {
        // var x
        build_notef(p->build, (PosSpan){epos,epos},
          "Fix by adding a type \"%s TYPE\" or assigning a value \"%s = VALUE\"",
          n->var.name, n->var.name);
      }
    } else {
      n->type = pType(p, fl);
    }
  }

  if (got(p, TAssign)) {
    // e.g. "var name = x" or "var name type = x"
    // TODO: if we have a known type, e.g. "var x int = 5" then use that in PIntLit()
    n->var.init = expr(p, PREC_LOWEST, PFlagRValue);
    if (!n->type && n->var.init->type != Type_ideal)
      n->type = n->var.init->type;
    NodeTransferUnresolved(n, n->var.init);
  } else if (n->var.isconst) {
    syntaxerr(p, "expecting assignment of value");
  }

  if (p->fnest == 0 && name_is_pub(n->var.name))
    NodeSetPublic(n);

  defsym(p, n->var.name, n);

  return n;
}


// assignment to fields, e.g. "x.y = 3" -> (assign (Selector (Id x) (Id y)) (Int 3))
static Node* pAssignSelector(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  panic("TODO pAssignSelector");
  return bad(p);
}


// e.g. "a = x"
static Node* pAssignId(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  asserteq_debug(left->kind, NId);

  if (!left->ref.target)
    left = resolve_id(p, left, PFlagNone);
  Node* target = left->ref.target;

  if (target && target->kind == NVar) {
    if (R_UNLIKELY(target->var.isconst)) {
      // syntaxerr(p, "assignment to constant %s", target->var.name);
      build_warnf(p->build, NodePosSpan(left),
        "variable definition shadows constant %s", target->var.name);
      build_notef(p->build, NodePosSpan(target),
        "constant %s defined here", target->var.name);
    } else {
      // assign to existing var and make sure the target is marked as variable
      NodeClearConst(target);
      if (target->kind == NVar)
        NodeRefVar(target);
      Node* n = mknode(p, NAssign);
      n->op.op = TAssign;
      nexttok(p); // consume '='
      Node* right = expr(p, PREC_LOWEST, fl);
      n->op.left = target;
        // ^ store target (e.g. NVar) instead of NId to simplify IR generation
      n->op.right = right;
      NodeTransferUnresolved(n, right);
      return n;
    }
  }

  // var definition, e.g. "x = 3" -> (var (Id x) (Int 3))
  nexttok(p); // consume '='
  Node* init = expr(p, PREC_LOWEST, fl);
  return make_var(p, left, init); // copies left->ref.name and left->pos
}


// e.g. "a, b = x, y"
static Node* pAssignTuple(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  asserteq_debug(left->kind, NTuple);
  assert_debug(fl & PFlagRValue);

  Node* n = mknode(p, NAssign);
  n->op.op = p->s.tok;
  nexttok(p); // consume '='
  Node* right = exprOrTuple(p, e->prec, fl);
  n->op.left = left;
  n->op.right = right;
  nodeTransferUnresolved2(n, left, right);

  if (right->kind != NTuple) {
    syntaxerrp(p, left->pos, "assignment mismatch: %u targets but 1 value",
      left->array.a.len);
    return n;
  }

  NodeArray* lnodes = &left->array.a;
  NodeArray* rnodes = &right->array.a;

  if (lnodes->len != rnodes->len) {
    syntaxerrp(p, left->pos, "assignment mismatch: %u targets but %u values",
      lnodes->len, rnodes->len);
    return n;
  }

  for (u32 i = 0; i < lnodes->len; i++) {
    Node* dst = lnodes->v[i];
    Node* src = rnodes->v[i];

    if (dst->kind != NId) {
      // e.g. foo.bar = 3
      panic("TODO assign dst->kind=%s", NodeKindName(dst->kind));
    }

    dst = resolve_id(p, dst, PFlagNone);
    Node* target = dst->ref.target;
    if (target) {
      NodeClearConst(target);
      if (target->kind == NVar)
        NodeRefVar(target);
      NodeTransferUnresolved(n, src);
      lnodes->v[i] = target;
    } else {
      lnodes->v[i] = make_var(p, dst, src);
      rnodes->v[i] = NULL; // indicate that lnodes->v[i]->var.init is to be used
    }
  }

  return n;
}


// Infix assignment e.g. "=" in "left = expr"
//!Parselet (TAssign ASSIGN)
static Node* PAssign(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  fl |= PFlagRValue;
  switch (left->kind) {
    case NId:       R_MUSTTAIL return pAssignId(p, e, fl, left);
    case NTuple:    R_MUSTTAIL return pAssignTuple(p, e, fl, left);
    case NSelector: R_MUSTTAIL return pAssignSelector(p, e, fl, left);
    default:
      syntaxerrp(p, left->pos, "cannot assign to %s", fmtnode(left));
      return left;
  }
}


// Group = "(" Expr ("," Expr)* ")"
// Groups are used to control precedence.
//!PrefixParselet TLParen
static Node* PGroup(Parser* p, PFlag fl) {
  nexttok(p); // consume "("
  auto n = exprOrTuple(p, PREC_LOWEST, fl);
  want(p, TRParen);
  return n;
}


// ArrayType = arrayType | sliceType
// arrayType = "[" Expr "]" Type
// sliceType = "[]" Type
static Node* pArrayType(Parser* p, PFlag fl) {
  fl |= PFlagType;
  auto n = mknode(p, NArrayType);
  nexttok(p); // consume "["

  // array or slice?
  if (!got(p, TRBrack)) {
    n->t.array.sizeExpr = expr(p, PREC_LOWEST, (fl & ~PFlagType) | PFlagRValue);
    want(p, TRBrack);
  } // else: slice, e.g. "[]int"

  n->t.array.subtype = expr(p, PREC_MEMBER, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->t.array.subtype);

  // if we are parsing in rvalue position it must be a parameter, else it's a var
  if (fl & PFlagRValue) {
    // e.g. fun foo(arg [4]int)
    //              ~~~~~~~~~~
    // TODO: is there anything we'd like to do here, like default value?
  }

  return InternASTType(p->build, n);
}


//!PrefixParselet TLBrack
static Node* PArrayPrefix(Parser* p, PFlag fl) {
  // array type "x [3]int", "x = [3]int(1, 2, 3)"
  return pArrayType(p, fl);
}


// Index = expr "[" expr "]"
static Node* pIndex(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  assert_debug((fl & PFlagType) == 0); // indexing is not valid in type context
  auto n = mknode(p, NIndex);
  nexttok(p); // consume "["
  n->index.operand = useAsRValue(p, left);
  if (R_UNLIKELY(p->s.tok == TRBrack)) {
    syntaxerr(p, "missing index");
    nexttok(p); // consume unexpected "]"
  } else {
    n->index.index = expr(p, PREC_LOWEST, fl | PFlagRValue);
    want(p, TRBrack);
    nodeTransferUnresolved2(n, n->index.operand, n->index.index);
  }
  return n;
}


// ListType  = ArrayType | SliceType
// ArrayType = "[" Expr "]" Type
// SliceType = "[]" Type
// #note: Expr must be of type usize
//
//!Parselet (TLBrack MEMBER)
static Node* PArrayInfix(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  // Two possibilities:
  // x [3]int  -- array type
  // x[3]      -- index (subscript) access

  // if there's no space in between "left" and "[", treat it as index access
  if (p->s.prevtokend == p->s.tokstart)
    return pIndex(p, e, fl, left);

  // else, treat it as an array type following an identifier e.g. "x [3]int"
  if (left->kind != NId) {
    syntaxerr(p, "unexpected array or slice type");
    return left;
  }

  auto type = pArrayType(p, fl);

  // e.g. "foo [4]int" =>
  // (Var
  //   (Id foo)
  //   (ArrayType (IntLit 4) (BasicType int))
  //   Initializer? )

  // optional initializer expression e.g. "foo []int = [1, 2, 3]"
  Node* init = NULL;
  if (got(p, TAssign)) {
    auto ctxtype = set_ctxtype(p, type);
    init = expr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  }

  auto n = make_var(p, left, init);
  // NodeFree(left); // make_var copies left->ref.name and left->pos
  n->type = type;

  // TODO: add check to PVarOrAssign and update n->var.init

  return n;
}


// PIdTrailing parses a trailing identifier, e.g. "b" in "a b"
//
//!Parselet (TId ASSIGN)
static Node* PIdTrailing(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto id = pId(p);

  if (R_UNLIKELY((fl & PFlagRValue) || left->kind != NId)) {
    // (fl & PFlagRValue)   Occurs as an expression, e.g. "b" in "x = a b"
    // (left->kind != NId)  Identifier following some expression e.g. "b" in "3 b"
    syntaxerrp(p, id->pos, "unexpected identifier %s", id->ref.name);
    return id;
  }

  Type* typ = resolve_id(p, id, fl | PFlagType);
  Node* init = NULL;
  if (got(p, TAssign)) {
    auto ctxtype = set_ctxtype(p, typ);
    init = expr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  }
  Node* letn = make_var(p, left, init);
  letn->type = typ;
  return letn;
}


// As = lhs "as" Type
// "as" has the lowest precedence and thus... Examples:
//
//   "9 * 2 as int8"         => (TypeCast int8 (Op * (Int 9) (Int 2)))
//   "9 * (2 as int8)"       => (Op * (Int 9) (TypeCast int8 (Int 2)))
//   "9, 2 as (int8,int8)"   => (Int 9) (TypeCast (Tuple int8 int8) (Int 2))
//   "(9, 2) as (int8,int8)" => (TypeCast (Tuple int8 int8) (Tuple (Int 9) (Int 2)))
//
//!Parselet (TAs LOWEST)
static Node* PAs(Parser* p, const Parselet* e, PFlag fl, Node* lhs) {
  auto n = mknode(p, NTypeCast);
  nexttok(p); // consume "as"
  n->call.receiver = pType(p, fl);
  n->call.args = lhs;
  return n;
}


// args = arg (sep arg)* sep?
// arg  = Id "=" Expr | Expr
// sep  = "," | ";"
static Node* pArgs(Parser* p, PFlag fl) { // => NTuple
  fl |= PFlagRValue;
  Node* tuple = mknode(p, NTuple);
  u32 index = 0;
  Node* arg;

  while (1) {
    if (p->s.tok == TId) {
      Node* id = pId(p);
      if (got(p, TAssign)) {
        // named argument
        Sym name = id->ref.name; // tmp
        arg = id;
        arg->kind = NNamedVal;
        arg->namedval.name = name;
        arg->namedval.value = expr(p, PREC_LOWEST, fl);
        tuple->flags |= NodeFlagNamed; // "has named argument"
      } else {
        id = resolve_id(p, id, fl);
        arg = infixExpr(p, PREC_LOWEST, fl, id);
        if (tuple->flags & NodeFlagNamed)
          goto err_pos_after_named;
      }
    } else {
      arg = expr(p, PREC_LOWEST, fl);
      if (tuple->flags & NodeFlagNamed)
        goto err_pos_after_named;
    }

    NodeArrayAppend(p->build->mem, &tuple->array.a, arg);

    switch (p->s.tok) {
      case TComma:
      case TSemi:
        if (nexttok(p) == TRParen) // consume "," or ";"
          goto end; // trailing "," or ";"
        break; // continue reading more
      case TRParen:
        goto end;
      default:
        syntaxerr(p, "expecting , ; or )");
        Tok followlist[] = { TRParen, 0 };
        advance(p, followlist);
        goto end;
    }

    index++;
  }

end:
  return set_endpos(p, tuple);

err_pos_after_named:
  syntaxerrp(p, arg->pos, "positional argument following named argument");
  goto end;
}


//!Parselet (TLParen MEMBER)
static Node* PCall(Parser* p, const Parselet* e, PFlag fl, Node* receiver) {
  auto n = mknode(p, NCall);
  nexttok(p); // consume "("
  auto ctxtype = p->ctxtype; // save ctxtype

  // receiver
  n->call.receiver = useAsRValue(p, receiver);
  NodeTransferUnresolved(n, n->call.receiver);

  // args
  n->call.args = NULL;
  if (!got(p, TRParen)) {
    if (n->call.receiver->kind == NBasicType) {
      // fast path for primitive types e.g. "i16(123)"
      n->kind = NTypeCast;
      p->ctxtype = n->call.receiver;
      n->call.args = expr(p, PREC_LOWEST, fl | PFlagRValue);
      if (n->call.receiver == n->call.args->type) {
        // short circuit e.g. "x = i64(3)"
        n = n->call.args;
      }
    } else {
      auto args = pArgs(p, fl);
      assert_debug(args->kind == NTuple);
      if (args->array.a.len > 0) {
        n->call.args = args;
        NodeTransferUnresolved(n, args);
      }
    }
    want(p, TRParen);
  }

  p->ctxtype = ctxtype; // restore ctxtype
  return n;
}


// Field = ( Id Type | NamedType ) ( "=" Expr )?
static Node* pField(Parser* p) {
  asserteq_debug(p->s.tok, TId);
  auto n = mknode(p, NField);
  n->field.name = p->s.name;
  nexttok(p); // consume name

  if (R_UNLIKELY(p->s.tok == TSemi)) {
    // e.g. "type" (implicit name)
    auto typename = mknode(p, NId);
    typename->ref.name = n->field.name;
    n->type = resolve_id(p, typename, PFlagType);
    n->flags |= NodeFlagBase;
  } else {
    // e.g. "name type"
    // custom error for "field = value"
    if (R_UNLIKELY(p->s.tok == TAssign)) {
      syntaxerr(p, "expecting type");
      n->type = bad(p);
    } else {
      n->type = pType(p, PFlagNone);
    }
  }

  // check for duplicate names
  Node* existing = lookupsymShallow(p, n->field.name);
  if (existing) {
    syntaxerrp(p, n->pos, "Duplicate field name \"%s\"", n->field.name);
    build_notef(p->build, NodePosSpan(existing), "Also defined here");
  }

  defsym(p, n->field.name, n);

  if (got(p, TAssign)) {
    // e.g. "field = initval"
    auto ctxtype = p->ctxtype; // save ctxtype
    p->ctxtype = n->type;
    n->field.init = expr(p, PREC_LOWEST, PFlagRValue);
    p->ctxtype = ctxtype; // restore ctxtype
    NodeTransferUnresolved(n, n->field.init);
    n->flags |= NodeFlagCustomInit; // TODO: only set if n->field.init is not zero/default
  }

  NodeTransferCustomInit(n, n->type);
  NodeTransferUnresolved(n, n->type);

  return n;
}


static bool end_block(Parser* p) {
  if (R_UNLIKELY(p->s.tok != TRBrace)) {
    syntaxerr(p, "expecting ; or }");
    return false;
  }
  // following is a dance to look ahead for tokens which when following
  // a block does not warrant an implicit semicolon. E.g. "if { } else ..."
  Scanner scanstate = p->s; // save scanner state
  nexttok(p); // consume '}' and read next token
  if (p->s.tok != TElse && p->s.tok != TSemi) {
    p->s = scanstate; // restore scan state
    p->s.tok = TSemi; // produce semicolon instead of '}'
  }
  return true;
}


// StructType = {" fields? "}"
// fields     = Field ( ";" Field )* ";"?
static Node* pStructType(Parser* p, PFlag fl, Node* n) {
  asserteq_debug(p->s.tok, TLBrace);
  nexttok(p); // consume "{"

  n->t.kind = TypeKindStruct;
  n->t.struc.name = p->typename;
  p->typename = NULL;

  pushScope(p);

  while (p->s.tok != TNone && p->s.tok != TRBrace) {
    if (R_UNLIKELY(p->s.tok != TId)) {
      syntaxerr(p, "expecting field or type name");
      break;
    }
    Node* field = pField(p);
    NodeTransferUnresolved(n, field);
    NodeTransferCustomInit(n, field);
    NodeArrayAppend(p->build->mem, &n->t.struc.a, field);

    if (R_UNLIKELY(n->t.struc.a.len == 0xFFFFFFFF)) {
      // overflow protection
      syntaxerr(p, "too many stuct fields");
      break;
    }

    if (!got(p, TSemi))
      break;
  }

  end_block(p);

  popScope(p);
  // note: we only allow refs to previously defined fields to enforce no cycles.
  // Thus we don't save the scope here.
  return n;
}


// StructTypeDef = "struct" StructType
//!PrefixParselet TStruct
static Node* PStructType(Parser* p, PFlag fl) {
  auto n = mknode(p, NStructType);
  nexttok(p); // consume "struct"

  // TODO: when infix, assign n->t.struc.name

  // name
  if (p->s.tok == TId) {
    p->typename = p->s.name;
    defsym(p, p->s.name, n); // make sure to define the struct before parsing its body
    nexttok(p); // consume name
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // body
  if (R_LIKELY(p->s.tok == TLBrace))
    return pStructType(p, fl, n);

  syntaxerr(p, "expecting { ... }");
  return n;
}


// TypeDef = "type" Id Type
//
//!PrefixParselet TType
static Node* PTypeDef(Parser* p, PFlag fl) {
  auto n = mknode(p, NVar); // TODO: introduce NTypeAlias
  nexttok(p); // consume "type"
  NodeSetConst(n);
  NodeSetUnused(n);

  // name
  if (p->s.tok == TId) {
    n->var.name = p->s.name;
    // make sure to define the type before parsing a potential struct body
    defsym(p, p->s.name, n);
    n->pos = pos_union(n->pos, ScannerPos(&p->s)); // include name
    nexttok(p); // consume name
    if (p->fnest == 0 && name_is_pub(n->var.name))
      NodeSetPublic(n);
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
  }

  p->typename = n->var.name;
  n->var.init = pType(p, PFlagNone);
  NodeTransferUnresolved(n, n->var.init);

  // struct with custom initializers must be visited by the type resolver,
  // so be conservative with propagating the type here.
  if ((n->var.init->flags & NodeFlagCustomInit) == 0)
    n->type = n->var.init;

  return n;
}


// BlockOrStructType = Block | StructType
// Block = "{" Expr* "}"
//!PrefixParselet TLBrace
static Node* PBlockOrStructType(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return pStructType(p, fl, mknode(p, NStructType));

  auto n = mknode(p, NBlock);
  nexttok(p); // consume "{"
  pushScope(p);

  Node* cn = NULL;
  while (p->s.tok != TNone && p->s.tok != TRBrace) {
    cn = exprOrTuple(p, PREC_LOWEST, fl & ~PFlagRValue);
    NodeArrayAppend(p->build->mem, &n->array.a, cn);
    NodeTransferUnresolved(n, cn);
    if (!got(p, TSemi))
      break;
  }

  if (end_block(p) && cn) {
    // if last expression is a local, increment its refcount
    NodeRefAny(cn);

    n->array.a.v[n->array.a.len - 1] = useAsRValue(p, cn);
    // if (fl & PFlagRValue) {
    //   // block is used as an rvalue e.g. "x = { ... }"
    //   if (cn && cn->kind == NVar) {
    //     // last expression is a var binding and will be used/returned, so unwrap it.
    //     n->array.a.v[n->array.a.len - 1] = unwrapVar(cn);
    //   }
    // }
  }

  set_endpos(p, n);
  popScopeAndCheckUnused(p);

  if (n->array.a.len == 1)
    return n->array.a.v[0];

  return n;
}


// PrefixOp = ( "+" | "-" | "!" ) Expr
//!PrefixParselet TPlus TMinus TExcalm
static Node* PPrefixOp(Parser* p, PFlag fl) {
  auto n = mknode(p, NPrefixOp);
  n->op.op = p->s.tok;
  nexttok(p);
  n->op.left = expr(p, PREC_LOWEST, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->op.left);
  return n;
}

// InfixOp = Expr ( "+" | "-" | "*" | "/" ) Expr
//!Parselet (TPlus ADD) (TMinus ADD)
//          (TStar MULTIPLY) (TSlash MULTIPLY)
//          (TLt COMPARE) (TGt COMPARE)
//          (TEq EQUAL) (TNEq EQUAL) (TLEq EQUAL) (TGEq EQUAL)
static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto n = mknode(p, NBinOp);
  n->op.op = p->s.tok;
  nexttok(p);
  n->op.left = useAsRValue(p, left);
  auto ctxtype = p->ctxtype; // save ctxtype
  p->ctxtype = n->op.left->type;
  n->op.right = expr(p, e->prec, fl | PFlagRValue);
  p->ctxtype = ctxtype; // restore ctxtype
  nodeTransferUnresolved2(n, left, n->op.right);
  return n;
}

// PostfixOp = Expr ( "++" | "--" )
//!Parselet (TPlusPlus UNARY_POSTFIX) (TMinusMinus UNARY_POSTFIX)
static Node* PPostfixOp(Parser* p, const Parselet* e, PFlag fl, Node* operand) {
  auto n = mknode(p, NPostfixOp);
  n->op.op = p->s.tok;
  n->op.left = useAsRValue(p, operand);
  nexttok(p); // consume "+"
  NodeTransferUnresolved(n, n->op.left);
  return n;
}

// Selector = Expr "." Id
//!Parselet (TDot MEMBER)
static Node* PSelector(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto n = mknode(p, NSelector);
  nexttok(p); // consume "."
  n->sel.operand = useAsRValue(p, left);
  TARRAY_INIT(&n->sel.indices);

  // member is a name
  if (R_UNLIKELY(p->s.tok != TId)) {
    syntaxerr(p, "expecting member name");
    return n;
  }
  n->sel.member = p->s.name;
  set_endpos(p, n); // extend n to include member id
  nexttok(p); // consume id

  n->flags = n->sel.operand->flags;
  return n;
}

// IntLit = [0-9]+
//!PrefixParselet TIntLit
static Node* PIntLit(Parser* p, PFlag fl) {
  auto n = mknode(p, NIntLit);
  size_t len = p->s.tokend - p->s.tokstart;
  if (!parseu64((const char*)p->s.tokstart, len, /*base*/10, &n->val.i)) {
    n->val.i = 0;
    syntaxerrp(p, n->pos, "invalid integer literal");
  }
  nexttok(p);
  n->val.ct = CType_int;
  n->type = Type_ideal;
  if (p->ctxtype)
    return convlit(p->build, n, p->ctxtype, ConvlitImplicit | ConvlitRelaxedType);
  return n;
}

// If = "if" Expr Expr
//!PrefixParselet TIf
static Node* PIf(Parser* p, PFlag fl) {
  auto n = mknode(p, NIf);
  nexttok(p);
  n->cond.cond = expr(p, PREC_LOWEST, fl | PFlagRValue);
  n->cond.thenb = expr(p, PREC_LOWEST, fl | PFlagRValue);
  nodeTransferUnresolved2(n, n->cond.cond, n->cond.thenb);

  if (fl & PFlagRValue)
    n->flags |= NodeFlagRValue;

  if (p->s.tok == TElse) {
    nexttok(p);
    n->cond.elseb = expr(p, PREC_LOWEST, fl);
    NodeTransferUnresolved(n, n->cond.elseb);
  }

  return n;
}

// Return = "return" Expr?
//!PrefixParselet TReturn
static Node* PReturn(Parser* p, PFlag fl) {
  auto n = mknode(p, NReturn);
  if (R_UNLIKELY(p->fnest == 0)) {
    // return outside a function
    syntaxerrp(p, n->pos, "return outside function body");
  }
  nexttok(p);
  if (p->s.tok != TSemi && p->s.tok != TRBrace) {
    n->op.left = exprOrTuple(p, PREC_LOWEST, fl | PFlagRValue);
    NodeTransferUnresolved(n, n->op.left);
  }
  return n;
}


// params = "(" param (sep param)* sep? ")"
// param  = Id Type? | Type
// sep    = "," | ";"
//
static Node* pParams(Parser* p) { // => NTuple
  // examples:
  //
  // (T)
  // (x T)
  // (x, y, z T)
  // (... T)
  // (x  ... T)
  // (x, y, z  ... T)
  // (T1, T2, T3)
  // (T1, T2, ... T3)
  //
  assert_debug(p->s.tok == TLParen);
  auto n = mknode(p, NTuple);
  nexttok(p); // consume "("

  // empty params? eg "()"
  if (p->s.tok == TRParen || p->s.tok == TNone) {
    want(p, TRParen);
    return n;
  }

  bool hasTypedParam = false; // true when at least one param has type; e.g. "x T"
  PFlag fl = PFlagRValue;

  void* typeq_st[32];
  NodeArray typeq = Array_INIT_WITH_STORAGE(typeq_st, countof(typeq_st));

  while (1) {
    auto cn = mknode(p, NVar);
    NodeSetConst(cn);
    NodeSetUnused(cn);
    NodeSetParam(cn);
    NodeArrayAppend(p->build->mem, &n->array.a, cn);

    if (p->s.tok == TId) {
      // name eg "x"
      cn->var.name = p->s.name;
      nexttok(p);
      switch (p->s.tok) {
        case TRParen:
        case TComma:
        case TSemi:
          // just a lone name, eg "x" in "(x, y)"
          NodeArrayAppend(p->build->mem, &typeq, cn);
          break;

        default:
          // type follows name, eg "x int"
          cn->type = pType(p, fl);
          hasTypedParam = true;
          // cascade type to predecessors
          for (u32 i = 0; i < typeq.len; i++) {
            ((Node*)typeq.v[i])->type = cn->type;
          }
          typeq.len = 0;
      }
    } else {
      // definitely just type, e.g. "fun([]int,bool)"
      cn->type = pType(p, fl);
    }

    // end loop?
    switch (p->s.tok) {
      case TComma:
      case TSemi:
        if (nexttok(p) == TRParen) // consume "," or ";"
          goto finish; // trailing "," or ";"
        break; // continue reading more
      case TRParen:
        goto finish;
      default:
        syntaxerr(p, "expecting , ; or )");
        Tok followlist[] = { TRParen, 0 };
        advance(p, followlist);
        goto finish;
    }
  }

finish:
  if (hasTypedParam) {
    // name-and-type form; e.g. "(x, y T, z Y)"
    if (typeq.len > 0) {
      // at least one param has type, but the last one does not.
      // e.g. "(x, y int, z)"
      syntaxerr(p, "expecting type");
    }
    u32 index = 0;
    for (u32 i = 0; i < n->array.a.len; i++) {
      Node* cn = (Node*)n->array.a.v[i];
      cn->var.index = index++;
      defsym(p, cn->var.name, cn);
      NodeTransferUnresolved(cn, cn->type);
      NodeTransferUnresolved(n, cn->type);
    }
  } else {
    // type-only form, e.g. "(T, T, Y)"
    // make ident of each cn->var.name where cn->type == NULL
    //
    // TODO: for template parameters, this case means "name only without type constraints"
    //
    u32 index = 0;
    for (u32 i = 0; i < n->array.a.len; i++) {
      Node* cn = (Node*)n->array.a.v[i];
      if (!cn->type) {
        auto t = mknode(p, NId);
        t->ref.name = cn->var.name;
        cn->var.name = sym__;
        cn->var.index = index++;
        cn->type = useAsRValue(p, t);
      }
      NodeTransferUnresolved(cn, cn->type);
      NodeTransferUnresolved(n, cn->type);
    }
  }

  ArrayFree(&typeq, p->build->mem);
  want(p, TRParen);
  return n;
}

// template parameters, e.g. "<T, R=T>"
static Node* templateParams(Parser* p) {
  assert(p->s.tok == TLt);
  PFlag fl = PFlagNone; // lvalue semantics
  auto tuple = mknode(p, NTuple);
  nexttok(p); // consume "<"
  do {
    if (R_UNLIKELY(p->s.tok != TId)) {
      syntaxerr(p, "expecting %s", TokName(TId));
      break;
    }
    auto name = mknode(p, NId);
    name->ref.name = p->s.name;
    nexttok(p); // consume id
    Node* init = NULL;
    if (got(p, TAssign)) // T=something
      init = prefixExpr(p, fl | PFlagRValue);
    Node* var = make_var(p, name, init);
    var->flags |= NodeFlagMacroParam;
    var->type = Type_nil;
    NodeArrayAppend(p->build->mem, &tuple->array.a, var);
  } while (got(p, TComma) && p->s.tok != TGt);
  want(p, TGt);
  set_endpos(p, tuple);
  return tuple;
}


// Fun     = FunDef | FunExpr
// FunDef  = "fun" Id? params? Type? Block?
// FunExpr = "fun" Id? params? Type? "->" Expr
//
// e.g.
//   fun foo (x, y int) int
//   fun foo (x, y int) int { x * y }
//   fun foo { 5 }
//   fun foo -> 5
//   fun (x, y int) int { x * y }
//   fun { 5 }
//   fun -> 5
//
//!PrefixParselet TFun
static Node* PFun(Parser* p, PFlag fl) {
  auto n = mknode(p, NFun);
  nexttok(p); // consume "fun"

  // name
  if (p->s.tok == TId) {
    n->fun.name = p->s.name;
    nexttok(p);
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // template parameters, e.g. "fun foo<T, R>(...)" => NMacro
  Node* macro = NULL;
  if (p->s.tok == TLt) {
    macro = mknode(p, NMacro);
    if (n->fun.name)
      defsym(p, n->fun.name, macro);
    pushScope(p);
    macro->macro.name = n->fun.name;
    macro->macro.params = templateParams(p);
    // Note: no NodeTransferUnresolved for params
  }

  if (n->fun.name)
    defsym(p, n->fun.name, n);

  // function parameters
  pushScope(p);
  if (p->s.tok == TLParen) {
    auto pa = pParams(p);
    // Note: the type of fun.params should structually match the type of call.args.
    // This reduces the work needed by the type resolver.
    if (pa->array.a.len > 0) {
      n->fun.params = pa;
      NodeTransferUnresolved(n, pa);
    }
  }

  // result type(s)
  if (p->s.tok != TLBrace && p->s.tok != TSemi) {
    if (p->s.tok == TRArr) {
      // e.g. "fun foo() -> 123" => "fun foo() auto { 123 }"
      n->fun.result = Type_auto;
    } else {
      n->fun.result = pType(p, fl);
      NodeTransferUnresolved(n, n->fun.result);
    }
  } else {
    // no result type specified is the same as "nil" (does not return a value)
    n->fun.result = Type_nil;
  }

  // set endpos
  // FIXME: this sets endpos to the next following token, not the last token.
  // Example:
  // 1  fun add(x int, y uint) int
  // 2
  // Gets an endpos of 2:0 (which is invalid since column is zero so formatters will ignore it)
  // It should get endpos 1:24 (for "int")
  set_endpos(p, n);

  // body
  p->fnest++;
  PFlag bodyfl = n->fun.result == Const_nil ? (fl & ~PFlagRValue) : (fl | PFlagRValue);
  if (p->s.tok == TLBrace) {
    // assign body before parsing so that we can check for it in pBlock
    assert_debug((fl & PFlagType) == 0); // needed for PBlockOrStructType
    n->fun.body = PBlockOrStructType(p, bodyfl);
  } else if (got(p, TRArr)) {
    n->fun.body = exprOrTuple(p, PREC_LOWEST, bodyfl);
  }
  p->fnest--;

  if (n->fun.body) {
    NodeTransferUnresolved(n, n->fun.body);
    popScopeAndCheckUnused(p); // function parameter scope
  } else {
    popScope(p);
  }

  if (macro) {
    popScopeAndCheckUnused(p); // template parameter scope
    macro->macro.template = n;
    return macro;
  }

  return n;
}


// end of parselets
// ============================================================================================
// ============================================================================================


//PARSELET_MAP_BEGIN
// automatically generated by misc/gen_parselet_map.py; do not edit
static const Parselet parselets[TMax] = {
  [TNil] = {PNil, NULL, PREC_MEMBER},
  [TAuto] = {PAuto, NULL, PREC_MEMBER},
  [TId] = {PId, PIdTrailing, PREC_ASSIGN},
  [TVar] = {PVar, NULL, PREC_MEMBER},
  [TConst] = {PVar, NULL, PREC_MEMBER},
  [TLParen] = {PGroup, PCall, PREC_MEMBER},
  [TLBrack] = {PArrayPrefix, PArrayInfix, PREC_MEMBER},
  [TStruct] = {PStructType, NULL, PREC_MEMBER},
  [TType] = {PTypeDef, NULL, PREC_MEMBER},
  [TLBrace] = {PBlockOrStructType, NULL, PREC_MEMBER},
  [TPlus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TMinus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TExcalm] = {PPrefixOp, NULL, PREC_MEMBER},
  [TIntLit] = {PIntLit, NULL, PREC_MEMBER},
  [TIf] = {PIf, NULL, PREC_MEMBER},
  [TReturn] = {PReturn, NULL, PREC_MEMBER},
  [TFun] = {PFun, NULL, PREC_MEMBER},
  [TAssign] = {NULL, PAssign, PREC_ASSIGN},
  [TAs] = {NULL, PAs, PREC_LOWEST},
  [TStar] = {NULL, PInfixOp, PREC_MULTIPLY},
  [TSlash] = {NULL, PInfixOp, PREC_MULTIPLY},
  [TLt] = {NULL, PInfixOp, PREC_COMPARE},
  [TGt] = {NULL, PInfixOp, PREC_COMPARE},
  [TEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TNEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TLEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TGEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TPlusPlus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TMinusMinus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TDot] = {NULL, PSelector, PREC_MEMBER},
};
//PARSELET_MAP_END


static Node* prefixExpr(Parser* p, PFlag fl) {
  // find prefix parselet
  assert((u32)p->s.tok < (u32)TMax);
  auto parselet = &parselets[p->s.tok];
  if (!parselet->fprefix) {
    // dlog("prefixExpr NOT found for %s", TokName(p->s.tok));
    syntaxerr(p, "expecting expression");
    auto n = bad(p);
    Tok followlist[] = { TRParen, TRBrace, TRBrack, TSemi, 0 };
    advance(p, followlist);
    return n;
  }
  // dlog("prefixExpr FOUND for %s", TokName(p->s.tok));
  return p->expr = parselet->fprefix(p, fl);
}


static Node* infixExpr(Parser* p, int precedence, PFlag fl, Node* left) {
  // wrap parselets
  // TODO: Should we set fl|PFlagRValue here?
  while (p->s.tok != TNone) {
    auto parselet = &parselets[p->s.tok];
    assertnotnull(parselet);
    // if (parselet->f) {
    //   dlog("infix parselet FOUND for %s; parselet->prec=%d < precedence=%d = %s",
    //     TokName(p->s.tok), parselet->prec, precedence,
    //     (int)parselet->prec < precedence ? "Y" : "N");
    // } else {
    //   dlog("infix parselet NOT found for %s", TokName(p->s.tok));
    // }
    if (!parselet->f || (int)parselet->prec < precedence) {
      break;
    }
    p->expr = parselet->f(p, parselet, fl, left);
    if (p->expr == NULL)
      return left;
    assert_debug(left != p->expr); // or else: infinite loop
    left = p->expr;
  }
  return left;
}


static Node* expr(Parser* p, int precedence, PFlag fl) {
  // Note: precedence should match the calling parselet's own precedence
  auto left = prefixExpr(p, fl);
  return infixExpr(p, precedence, fl, left);
}


// exprOrTuple = Expr | Tuple
//
// This function has different behavior depending on PFlagRValue:
//
//   PFlagRValue=OFF consumes a prefixExpr, then a possible tuple and finally calls
//   infixExpr to include the tuple in an infix expression like t + y.
//
//   - PFlagRValue=OFF is "conservative" used for lvalues, e.g. (a b c) in a,b,c=1,2,3
//   - PFlagRValue=ON is "greedy" and used for rvalues, e.g. (x (y + z)) in _,_=x,y+z
//
//   Consider the following source code:
//     a, b + c, d
//   Parsing this with the different functions yields:
//   - PFlagRValue=OFF => (+ (a b) c)
//   - PFlagRValue=ON => (a (+ b c) d)
//
//   Explanation of PFlagRValue=OFF:
//   • PFlagRValue=OFF calls prefixExpr => a
//   • PFlagRValue=OFF sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=OFF calls prefixExpr => b
//   • PFlagRValue=OFF end tuple => (a b)
//   • infixExpr with tuple as the LHS:
//     • infixExpr calls '+' parselet
//       • '+' parselet reads RHS by calling expr:
//         • expr calls prefixExpr (which in turn calls 'ident' parselet) => c
//         • expr returns the c identifier (NId)
//       • '+' parselet produces LHS + RHS => (+ (a b) c)
//     • return
//   • return
//
//   Explanation of PFlagRValue=ON:
//   • PFlagRValue=ON calls expr => a
//   • PFlagRValue=ON sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=ON calls expr
//     • expr calls prefixExpr => b
//     • expr calls infixExpr with b as LHS:
//       • infixExpr calls '+' parselet
//         • '+' parselet reads RHS by calling expr:
//           • expr calls prefixExpr => c
//           • expr returns the c identifier (NId)
//         • '+' parselet produces LHS + RHS => (+ b c)
//       • return
//     • return
//   • PFlagRValue=ON calls expr after another comma
//     • calls prefixExpr => b
//   • PFlagRValue=ON see no more comma; ends the tuple => (a (+ b c) d)
//
static Node* exprOrTuple(Parser* p, int precedence, PFlag fl) {
  auto left = (
    fl & PFlagRValue ? expr(p, precedence, fl) :
                       prefixExpr(p, fl) ); // read a prefix expression, like an identifier

  if (got(p, TComma)) {
    // start a tuple
    auto g = mknode(p, fl & PFlagType ? NTupleType : NTuple);
    NodeArray* array = fl & PFlagType ? &g->t.tuple.a : &g->array.a;
    NodeArrayAppend(p->build->mem, array, left);
    NodeTransferUnresolved(g, left);
    if (fl & PFlagRValue) {
      do {
        Node* cn = expr(p, precedence, fl);
        NodeArrayAppend(p->build->mem, array, cn);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    } else {
      do {
        Node* cn = prefixExpr(p, fl);
        NodeArrayAppend(p->build->mem, array, cn);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    }
    set_endpos(p, g);
    left = g;
  }

  if (fl & PFlagRValue)
    return left;

  // wrap in possible infix expression, e.g. "left + right"
  return infixExpr(p, precedence, fl, left);
}


Node* CreatePkgAST(Build* build, Scope* pkgscope) {
  // Scope* pkgscope
  auto n = NewNode(build->mem, NPkg);
  n->cunit.name = build->pkg->name; // ok if null
  n->cunit.scope = pkgscope;
  // Note: Do not set n->type as it would prevent type resolver from visiting files
  return n;
}


Node* Parse(Parser* p, Build* build, Source* src, ParseFlags fl, Scope* pkgscope) {
  // initialize scanner
  if (!ScannerInit(&p->s, build, src, fl))
    return NULL;

  p->build = build;
  p->pkgscope = pkgscope;
  p->expr = NULL;
  p->fnest = 0;

  // scopestack
  if (p->scopestack.ptr == NULL) {
    p->scopestack.cap = countof(p->scopestack.storage);
    p->scopestack.ptr = p->scopestack.storage;
  } else {
    // reuse already-allocated memory
    p->scopestack.len = 0;
    p->scopestack.base = 0;
  }

  // load first token
  nexttok(p);

  // TODO: ParseFlags, where one option is PARSE_IMPORTS to parse only imports and then stop.

  auto file = mknode(p, NFile);
  file->cunit.name = src->filename; // ok if null

  while (p->s.tok != TNone) {
    Node* n = exprOrTuple(p, PREC_LOWEST, PFlagNone);

    NodeArrayAppend(p->build->mem, &file->cunit.a, n);
    NodeTransferUnresolved(file, n);

    // // print associated comments
    // auto c = p->s.comments;
    // while (c) { printf("#%.*s\n", (int)c->len, c->ptr); c = c->next; }
    // p->s.comments = p->s.comments_tail = NULL;
    // // TODO: Add "comments" to Node struct and if caller requests inclusion of comments,
    // // assign these comments to the node. This should be done in mknode and not here.

    // check that we either got a semicolon or EOF
    if (p->s.tok != TNone && !got(p, TSemi)) {
      syntaxerr(p, "after top level declaration");
      if (n && n->kind == NId) {
        build_notef(p->build, (PosSpan){n->pos, NoPos}, "Did you mean \"var %s\"?", n->ref.name);
      }
      Tok followlist[] = { TType, TFun, TSemi, 0 };
      advance(p, followlist);
    }
  }

  return file;
}


ASSUME_NONNULL_END
