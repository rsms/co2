#include <rbase/rbase.h>
#include "parse.h"
#include "universe.h"

// generated by gen_constants at the end of this file.
// Define to run the generator during program initialization:
//#define RUN_GENERATOR


//-- BEGIN gen_constants() at src/co/parse/universe.c:341

const Sym sym_as = &"\x87\x3D\x7F\xCD\x02\x00\x00\x08""as\0"[8];
const Sym sym_break = &"\xFF\x55\x83\xD2\x05\x00\x00\x10""break\0"[8];
const Sym sym_case = &"\x57\x54\xF8\x63\x04\x00\x00\x18""case\0"[8];
const Sym sym_continue = &"\xB4\xFF\xAB\xF1\x08\x00\x00\x20""continue\0"[8];
const Sym sym_default = &"\x1F\x7D\xAA\x00\x07\x00\x00\x28""default\0"[8];
const Sym sym_defer = &"\xAD\x43\x24\x74\x05\x00\x00\x30""defer\0"[8];
const Sym sym_else = &"\xAD\x2A\x2A\x55\x04\x00\x00\x38""else\0"[8];
const Sym sym_enum = &"\x00\xE0\xE4\xCD\x04\x00\x00\x40""enum\0"[8];
const Sym sym_for = &"\x2E\x77\xA4\x49\x03\x00\x00\x48""for\0"[8];
const Sym sym_fun = &"\x1B\xD7\x8A\x8A\x03\x00\x00\x50""fun\0"[8];
const Sym sym_if = &"\xF5\x8D\x92\xCF\x02\x00\x00\x58""if\0"[8];
const Sym sym_import = &"\xF8\xA4\x4A\xF8\x06\x00\x00\x60""import\0"[8];
const Sym sym_in = &"\x74\x9A\xDF\xDD\x02\x00\x00\x68""in\0"[8];
const Sym sym_interface = &"\x1F\xEF\xC3\x4E\x09\x00\x00\x70""interface\0"[8];
const Sym sym_is = &"\x34\xD0\x1E\xA3\x02\x00\x00\x78""is\0"[8];
const Sym sym_mutable = &"\xAC\xA8\xCB\xD2\x07\x00\x00\x80""mutable\0"[8];
const Sym sym_nil = &"\x8F\x7E\x4F\xEF\x03\x00\x00\x88""nil\0"[8];
const Sym sym_return = &"\xEB\xA6\x08\xA3\x06\x00\x00\x90""return\0"[8];
const Sym sym_select = &"\x3F\x03\x09\xBC\x06\x00\x00\x98""select\0"[8];
const Sym sym_struct = &"\x97\xFC\x80\x50\x06\x00\x00\xA0""struct\0"[8];
const Sym sym_switch = &"\x37\xE0\x68\x4B\x06\x00\x00\xA8""switch\0"[8];
const Sym sym_symbol = &"\xAE\x65\x40\x0A\x06\x00\x00\xB0""symbol\0"[8];
const Sym sym_type = &"\x52\x1E\xB2\xD6\x04\x00\x00\xB8""type\0"[8];
const Sym sym_while = &"\xFF\x98\x03\xFC\x05\x00\x00\xC0""while\0"[8];

const Sym sym_bool = &"\x70\x6D\x7D\x3D\x04\x00\x00\x00""bool\0"[8];
const Sym sym_int8 = &"\xB5\xD1\x1A\x27\x04\x00\x00\x00""int8\0"[8];
const Sym sym_uint8 = &"\x32\x17\xD3\x9B\x05\x00\x00\x00""uint8\0"[8];
const Sym sym_int16 = &"\x7A\x86\x76\x34\x05\x00\x00\x00""int16\0"[8];
const Sym sym_uint16 = &"\xD0\xC9\x18\x7A\x06\x00\x00\x00""uint16\0"[8];
const Sym sym_int32 = &"\x4C\x68\x9C\xA4\x05\x00\x00\x00""int32\0"[8];
const Sym sym_uint32 = &"\x50\xCB\x0E\x1B\x06\x00\x00\x00""uint32\0"[8];
const Sym sym_int64 = &"\x6C\xF1\xA4\xAC\x05\x00\x00\x00""int64\0"[8];
const Sym sym_uint64 = &"\xD0\x02\x0E\x39\x06\x00\x00\x00""uint64\0"[8];
const Sym sym_float32 = &"\x39\xFB\x68\x48\x07\x00\x00\x00""float32\0"[8];
const Sym sym_float64 = &"\x76\x44\x7B\x75\x07\x00\x00\x00""float64\0"[8];
const Sym sym_int = &"\xCD\x9E\x65\xA5\x03\x00\x00\x00""int\0"[8];
const Sym sym_uint = &"\xFA\x0A\xDC\xFB\x04\x00\x00\x00""uint\0"[8];
const Sym sym_str = &"\x12\xAE\x4D\xED\x03\x00\x00\x00""str\0"[8];
const Sym sym_ideal = &"\x5B\xB4\x1C\xC8\x05\x00\x00\x00""ideal\0"[8];
const Sym sym__ = &"\xE7\x52\x89\xD0\x01\x00\x00\x00""_\0"[8];
const Sym sym_true = &"\xA2\x11\x64\xDB\x04\x00\x00\x00""true\0"[8];
const Sym sym_false = &"\xAC\x1C\xED\xD5\x05\x00\x00\x00""false\0"[8];
const Sym sym_b = &"\xBA\x97\x7C\xF4\x01\x00\x00\x00""b\0"[8];
const Sym sym_1 = &"\xC4\xD0\xFC\x8C\x01\x00\x00\x00""1\0"[8];
const Sym sym_2 = &"\xBA\xB3\xD5\x74\x01\x00\x00\x00""2\0"[8];
const Sym sym_3 = &"\x3B\x29\x53\x12\x01\x00\x00\x00""3\0"[8];
const Sym sym_4 = &"\x22\xEF\xF2\x1D\x01\x00\x00\x00""4\0"[8];
const Sym sym_5 = &"\x5C\xCE\x89\xEE\x01\x00\x00\x00""5\0"[8];
const Sym sym_6 = &"\xBE\x2F\xCC\x8D\x01\x00\x00\x00""6\0"[8];
const Sym sym_7 = &"\x3F\xD4\xD9\xA7\x01\x00\x00\x00""7\0"[8];
const Sym sym_8 = &"\x37\x74\x69\x1E\x01\x00\x00\x00""8\0"[8];
const Sym sym_f = &"\xE9\x46\xFD\x9C\x01\x00\x00\x00""f\0"[8];
const Sym sym_F = &"\x5C\x05\x48\xBA\x01\x00\x00\x00""F\0"[8];
const Sym sym_i = &"\x3A\x16\x35\x80\x01\x00\x00\x00""i\0"[8];
const Sym sym_u = &"\x32\x6A\x3E\x41\x01\x00\x00\x00""u\0"[8];
const Sym sym_s = &"\xC0\xB7\x96\x15\x01\x00\x00\x00""s\0"[8];
const Sym sym_$x2a = &"\x9C\x1C\x9F\x3C\x01\x00\x00\x00""*\0"[8];
const Sym sym_0 = &"\xFE\xED\xFA\xA1\x01\x00\x00\x00""0\0"[8];

static Node _Type_bool = {NBasicType,NoPos,NULL,{.t={sym_b,.basic={TypeCode_bool,sym_bool}}}};
static Node _Type_int8 = {NBasicType,NoPos,NULL,{.t={sym_1,.basic={TypeCode_int8,sym_int8}}}};
static Node _Type_uint8 = {NBasicType,NoPos,NULL,{.t={sym_2,.basic={TypeCode_uint8,sym_uint8}}}};
static Node _Type_int16 = {NBasicType,NoPos,NULL,{.t={sym_3,.basic={TypeCode_int16,sym_int16}}}};
static Node _Type_uint16 = {NBasicType,NoPos,NULL,{.t={sym_4,.basic={TypeCode_uint16,sym_uint16}}}};
static Node _Type_int32 = {NBasicType,NoPos,NULL,{.t={sym_5,.basic={TypeCode_int32,sym_int32}}}};
static Node _Type_uint32 = {NBasicType,NoPos,NULL,{.t={sym_6,.basic={TypeCode_uint32,sym_uint32}}}};
static Node _Type_int64 = {NBasicType,NoPos,NULL,{.t={sym_7,.basic={TypeCode_int64,sym_int64}}}};
static Node _Type_uint64 = {NBasicType,NoPos,NULL,{.t={sym_8,.basic={TypeCode_uint64,sym_uint64}}}};
static Node _Type_float32 = {NBasicType,NoPos,NULL,{.t={sym_f,.basic={TypeCode_float32,sym_float32}}}};
static Node _Type_float64 = {NBasicType,NoPos,NULL,{.t={sym_F,.basic={TypeCode_float64,sym_float64}}}};
static Node _Type_int = {NBasicType,NoPos,NULL,{.t={sym_i,.basic={TypeCode_int,sym_int}}}};
static Node _Type_uint = {NBasicType,NoPos,NULL,{.t={sym_u,.basic={TypeCode_uint,sym_uint}}}};
static Node _Type_str = {NBasicType,NoPos,NULL,{.t={sym_s,.basic={TypeCode_str,sym_str}}}};
static Node _Type_ideal = {NBasicType,NoPos,NULL,{.t={sym_$x2a,.basic={TypeCode_ideal,sym_ideal}}}};
static Node _Type_nil = {NBasicType,NoPos,NULL,{.t={sym_0,.basic={TypeCode_nil,sym_nil}}}};

static const Node _Const_true = {NBoolLit,NoPos,(Node*)&_Type_bool,{.val={CType_bool,.i=1}}};
static const Node _Const_false = {NBoolLit,NoPos,(Node*)&_Type_bool,{.val={CType_bool,.i=0}}};
static const Node _Const_nil = {NNil,NoPos,(Node*)&_Type_nil,{.val={CType_nil,.i=0}}};

Node* Type_bool = (Node*)&_Type_bool;
Node* Type_int8 = (Node*)&_Type_int8;
Node* Type_uint8 = (Node*)&_Type_uint8;
Node* Type_int16 = (Node*)&_Type_int16;
Node* Type_uint16 = (Node*)&_Type_uint16;
Node* Type_int32 = (Node*)&_Type_int32;
Node* Type_uint32 = (Node*)&_Type_uint32;
Node* Type_int64 = (Node*)&_Type_int64;
Node* Type_uint64 = (Node*)&_Type_uint64;
Node* Type_float32 = (Node*)&_Type_float32;
Node* Type_float64 = (Node*)&_Type_float64;
Node* Type_int = (Node*)&_Type_int;
Node* Type_uint = (Node*)&_Type_uint;
Node* Type_str = (Node*)&_Type_str;
Node* Type_ideal = (Node*)&_Type_ideal;
Node* Type_nil = (Node*)&_Type_nil;
Node* Const_true = (Node*)&_Const_true;
Node* Const_false = (Node*)&_Const_false;
Node* Const_nil = (Node*)&_Const_nil;

inline static void init_type_nodes() {
  _Type_bool.type = Type_bool;
  _Type_int8.type = Type_int8;
  _Type_uint8.type = Type_uint8;
  _Type_int16.type = Type_int16;
  _Type_uint16.type = Type_uint16;
  _Type_int32.type = Type_int32;
  _Type_uint32.type = Type_uint32;
  _Type_int64.type = Type_int64;
  _Type_uint64.type = Type_uint64;
  _Type_float32.type = Type_float32;
  _Type_float64.type = Type_float64;
  _Type_int.type = Type_int;
  _Type_uint.type = Type_uint;
  _Type_str.type = Type_str;
  _Type_ideal.type = Type_ideal;
  _Type_nil.type = Type_nil;
}

static SymRBNode n_default = { sym_default, false, NULL, NULL };
static SymRBNode n_uint32 = { sym_uint32, true, NULL, NULL };
static SymRBNode n_int8 = { sym_int8, false, &n_uint32, NULL };
static SymRBNode n_symbol = { sym_symbol, true, &n_default, &n_int8 };
static SymRBNode n_uint64 = { sym_uint64, true, NULL, NULL };
static SymRBNode n_float32 = { sym_float32, true, NULL, NULL };
static SymRBNode n_bool = { sym_bool, false, &n_uint64, &n_float32 };
static SymRBNode n_int16 = { sym_int16, false, &n_symbol, &n_bool };
static SymRBNode n_switch = { sym_switch, true, NULL, NULL };
static SymRBNode n_interface = { sym_interface, false, &n_switch, NULL };
static SymRBNode n_else = { sym_else, false, NULL, NULL };
static SymRBNode n_struct = { sym_struct, false, &n_interface, &n_else };
static SymRBNode n_for = { sym_for, true, &n_int16, &n_struct };
static SymRBNode n_defer = { sym_defer, true, NULL, NULL };
static SymRBNode n_uint16 = { sym_uint16, true, NULL, NULL };
static SymRBNode n_float64 = { sym_float64, false, &n_defer, &n_uint16 };
static SymRBNode n_uint8 = { sym_uint8, true, NULL, NULL };
static SymRBNode n_return = { sym_return, false, &n_uint8, NULL };
static SymRBNode n_fun = { sym_fun, true, &n_float64, &n_return };
static SymRBNode n_int32 = { sym_int32, true, NULL, NULL };
static SymRBNode n_int = { sym_int, false, &n_int32, NULL };
static SymRBNode n_select = { sym_select, false, NULL, NULL };
static SymRBNode n_int64 = { sym_int64, true, &n_int, &n_select };
static SymRBNode n_is = { sym_is, false, &n_fun, &n_int64 };
static SymRBNode n_case = { sym_case, false, &n_for, &n_is };
static SymRBNode n_enum = { sym_enum, true, NULL, NULL };
static SymRBNode n__ = { sym__, true, NULL, NULL };
static SymRBNode n_if = { sym_if, false, &n_enum, &n__ };
static SymRBNode n_mutable = { sym_mutable, true, NULL, NULL };
static SymRBNode n_false = { sym_false, false, &n_mutable, NULL };
static SymRBNode n_break = { sym_break, true, &n_if, &n_false };
static SymRBNode n_true = { sym_true, false, NULL, NULL };
static SymRBNode n_type = { sym_type, false, &n_break, &n_true };
static SymRBNode n_str = { sym_str, true, NULL, NULL };
static SymRBNode n_nil = { sym_nil, false, &n_str, NULL };
static SymRBNode n_import = { sym_import, true, NULL, NULL };
static SymRBNode n_while = { sym_while, true, NULL, NULL };
static SymRBNode n_uint = { sym_uint, false, &n_import, &n_while };
static SymRBNode n_continue = { sym_continue, false, &n_nil, &n_uint };
static SymRBNode n_in = { sym_in, false, &n_type, &n_continue };
static SymRBNode n_as = { sym_as, false, &n_case, &n_in };

static SymRBNode* _symroot = &n_as;

Node* const _TypeCodeToTypeNodeMap[TypeCode_CONCRETE_END] = {
  (Node*)&_Type_bool,    // TypeCode_bool
  (Node*)&_Type_int8,    // TypeCode_int8
  (Node*)&_Type_uint8,   // TypeCode_uint8
  (Node*)&_Type_int16,   // TypeCode_int16
  (Node*)&_Type_uint16,  // TypeCode_uint16
  (Node*)&_Type_int32,   // TypeCode_int32
  (Node*)&_Type_uint32,  // TypeCode_uint32
  (Node*)&_Type_int64,   // TypeCode_int64
  (Node*)&_Type_uint64,  // TypeCode_uint64
  (Node*)&_Type_float32, // TypeCode_float32
  (Node*)&_Type_float64, // TypeCode_float64
  (Node*)&_Type_int,     // TypeCode_int
  (Node*)&_Type_uint,    // TypeCode_uint
  NULL,                  // TypeCode_NUM_END
  (Node*)&_Type_str,     // TypeCode_str
  (Node*)&_Type_nil,     // TypeCode_nil
};
#ifndef NDEBUG
__attribute__((used)) static const char* const debugSymCheck =
  "as#101 break#102 case#103 continue#104 default#105 defer#106 else#107 "
  "enum#108 for#109 fun#10a if#10b import#10c in#10d interface#10e "
  "is#10f mutable#110 nil#111 return#112 select#113 struct#114 switch#115 "
  "symbol#116 type#117 while#118 bool int8 uint8 int16 uint16 int32 uint32 "
  "int64 uint64 float32 float64 int uint str true:bool=1 false:bool=0 nil:nil=0 "
  "_ ";
#endif

//-- END gen_constants() at src/co/parse/universe.c:542



const SymPool* universe_syms() {
  static SymPool p = {};
  if (p.root == NULL) {
    init_type_nodes();
    sympool_init(&p, NULL, NULL, _symroot);
  }
  return &p;
}


// ---------------------------------------------------------------------------------------
// test

// R_UNIT_TEST(universe) {
//   auto s = sympool_repr(&_universe_syms, str_new(0));
//   dlog("%s", s);
//   str_free(s);
// }


// ---------------------------------------------------------------------------------------
// sym constant data generator

#if defined(RUN_GENERATOR)

// red-black tree implementation used for interning
// RBKEY must match that in sym.c
#define RBKEY      Sym
#define RBUSERDATA Mem
#include "../util/rbtree.c.h"

static RBNode* RBAllocNode(Mem mem) {
  return (RBNode*)memalloct(mem, RBNode);
}

static void RBFreeNode(RBNode* node, Mem mem) {
}

static int RBCmp(Sym a, Sym b, Mem mem) {
  if (symhash(a) < symhash(b))
    return -1;
  if (symhash(a) > symhash(b))
    return 1;
  int cmp = (int)symlen(a) - (int)symlen(b);
  if (cmp == 0) {
    // hash is identical and length is identical; compare bytes
    cmp = memcmp(a, b, symlen(a));
  }
  return cmp;
}



inline static Str fmt_nodes(const RBNode* n, Str s) {
  // descent first
  if (n->left) {
    s = fmt_nodes(n->left, s);
  }
  if (n->right) {
    s = fmt_nodes(n->right, s);
  }

  s = str_appendcstr(s, "static SymRBNode n_");
  s = str_append(s, n->key, symlen(n->key));
  s = str_appendcstr(s, " = { ");

  // { key, isred, left, right }

  s = str_appendfmt(s, "sym_%s, ", n->key);
  // s = str_appendcstr(s, "NULL, ");

  s = str_appendcstr(s, n->isred ? "true, " : "false, ");
  if (n->left) {
    s = str_appendfmt(s, "&n_%s, ", n->left->key);
  } else {
    s = str_appendcstr(s, "NULL, ");
  }
  if (n->right) {
    s = str_appendfmt(s, "&n_%s ", n->right->key);
  } else {
    s = str_appendcstr(s, "NULL ");
  }
  s = str_appendcstr(s, "};\n");
  return s;
}

// static ConstStr fmtkey(Sym k) { return (ConstStr)k; } // Sym is a type of Str :-)

// is_cident_nth returns true if c is a valid character in a C identifier as the
// 2nd or later character.
static inline bool is_cident_nth(char c) {
  return (
    ('0' <= c && c <= '9') ||
    ('A' <= c && c <= 'Z') ||
    ('a' <= c && c <= 'z') ||
    c == '_' ||
    c == '$'
  );
}

static const char* typecode_cident(char c) {
  static char buf[16];
  buf[0] = c;
  buf[1] = 0;
  if (c == '$' || !is_cident_nth(c))
    snprintf(buf, sizeof(buf), "$x%02x", c);
  return buf;
}

static bool gen_append_symdef(Str* sp, RBNode** rp, Sym sym, const char* name) {
  assert(symlen(sym) < 1000);
  bool added;
  *rp = RBInsert(*rp, sym, &added, NULL);
  if (!added)
    return false;

  auto s = *sp;
  s = str_setlen(s, 0); /* reset */
  s = str_appendfmt(s, "const Sym sym_%s = &\"", name);

  auto h = _SYM_HEADER(sym);
  auto hash = (const u8*)&h->hash;
  auto len  = (const u8*)&h->len;

  // hash, len, cap
  s = str_appendfmt(s, "\\x%02X\\x%02X\\x%02X\\x%02X", hash[0], hash[1], hash[2], hash[3]);
  s = str_appendfmt(s, "\\x%02X\\x%02X\\x%02X\\x%02X", len[0], len[1], len[2], len[3]);

  s = str_appendcstr(s, "\"\""); // in case sym starts with a hex digit
  s = str_appendrepr(s, sym, symlen(sym));
  s = str_appendfmt(s, "\\0\"[%d];\n", (int)sizeof(SymHeader));
  *sp = s;
  return true;
}

static bool gen_append_symdef_lit(Str* sp, RBNode** rp, Sym sym, const char* name, u8 flags) {
  sym_dangerously_set_flags(sym, flags);
  return gen_append_symdef(sp, rp, sym, name);
}

static bool gen_append_symdef_typecode_lit(Str* sp, RBNode** rp, SymPool* syms, char typecode_ch) {
  char buf[2];
  buf[0] = typecode_ch;
  buf[1] = 0;
  auto sym = symadd(syms, buf, 1);
  return gen_append_symdef(sp, rp, sym, typecode_cident(typecode_ch));
}

__attribute__((constructor,used)) static void gen_constants() {
  printf("\n//-- BEGIN gen_constants() at %s:%d\n\n", __FILE__, __LINE__);

  SymPool syms;
  sympool_init(&syms, NULL, NULL, NULL);

  // // define temporary runtime symbols
  // #define SYM_DEF1(name)              symaddcstr(&syms, #name);
  // #define SYM_DEF2(str, tok)          symaddcstr(&syms, #str);
  // #define SYM_DEF1_IGN2(name, _t, _v) symaddcstr(&syms, #name);
  // TOKEN_KEYWORDS(SYM_DEF2)
  // TYPE_SYMS(SYM_DEF1)
  // TYPE_SYMS_PRIVATE(SYM_DEF1)
  // PREDEFINED_CONSTANTS(SYM_DEF1_IGN2)
  // PREDEFINED_IDENTS(SYM_DEF1)
  // #undef SYM_DEF1
  // #undef SYM_DEF2
  // #undef SYM_DEF1_IGN2


  // ---------------------------------------------------------------------------------------------
  // generate symbol constants
  Str tmpstr = str_new(512);
  RBNode* root = NULL;
  bool added;

  #define SYM_GEN_NOFLAGS(name, ...)                                        \
    if (gen_append_symdef_lit(&tmpstr, &root, symgetcstr(&syms, #name), #name, 0)) \
      printf("%s", tmpstr);

  #define SYM_GEN_TYPECODE(name, ...)                                                     \
    if (gen_append_symdef_typecode_lit(&tmpstr, &root, &syms, TypeCodeEncoding(TypeCode_##name))) \
      printf("%s", tmpstr);

  #define SYM_GEN_KEYWORD(name, tok, ...) {                          \
    Sym sym = symgetcstr(&syms, #name);                              \
    u8 flags = (tok - TKeywordsStart);                               \
    if (!gen_append_symdef_lit(&tmpstr, &root, sym, #name, flags)) { \
      errlog("duplicate keyword symbol definition: %s", sym);        \
      exit(1);                                                       \
    }                                                                \
    printf("%s", tmpstr);                                            \
  }

  // keyword symbols must be generated first as they use custom Sym flags
  TOKEN_KEYWORDS(SYM_GEN_KEYWORD)
  printf("\n");

  TYPE_SYMS(SYM_GEN_NOFLAGS)
  TYPE_SYMS_PRIVATE(SYM_GEN_NOFLAGS)
  PREDEFINED_IDENTS(SYM_GEN_NOFLAGS)
  PREDEFINED_CONSTANTS(SYM_GEN_NOFLAGS)

  TYPE_SYMS(SYM_GEN_TYPECODE)
  TYPE_SYMS_PRIVATE(SYM_GEN_TYPECODE)


  #undef SYM_GEN_NOFLAGS
  #undef SYM_GEN_TYPECODE
  #undef SYM_GEN_KEYWORD
  str_free(tmpstr);

  RBClear(root, NULL);


  // ---------------------------------------------------------------------------------------------
  // generate AST nodes

  // TYPE_SYMS
  // TODO: precompute t.id Sym
  // const Node* type_NAME
  printf("\n");
  #define NODE_GEN(name)                                                        \
    printf(                                                                     \
      "static Node _Type_%s = "                                                 \
      "{NBasicType,NoPos,NULL,{.t={sym_%s,.basic={TypeCode_%s,sym_%s}}}};\n",   \
      #name, typecode_cident(TypeCodeEncoding(TypeCode_##name)), #name, #name   \
    );
  TYPE_SYMS(NODE_GEN)
  TYPE_SYMS_PRIVATE(NODE_GEN)
  #undef NODE_GEN


  // PREDEFINED_CONSTANTS
  printf("\n");
  #define NODE_GEN(name, type, value)                                           \
    printf(                                                                     \
      "static const Node _Const_%s = {%s,NoPos,(Node*)&_Type_%s,{.val=%s}};\n", \
      #name,                                                                    \
      strcmp(#type, "bool") == 0 ? "NBoolLit" :                                 \
      strcmp(#type, "nil") == 0 ?  "NNil" :                                     \
                                   "NIntLit",                                   \
      #type,                                                                    \
      /*NVal*/ "{CType_" #type ",.i=" #value "}"                                \
    );
  PREDEFINED_CONSTANTS(NODE_GEN)
  #undef NODE_GEN


  // Generate named pointers
  printf("\n");
  #define NODE_GEN(name) printf("Node* Type_%s = (Node*)&_Type_%s;\n", #name, #name);
  TYPE_SYMS(NODE_GEN)
  TYPE_SYMS_PRIVATE(NODE_GEN)
  #undef NODE_GEN
  #define NODE_GEN(name, ...) printf("Node* Const_%s = (Node*)&_Const_%s;\n", #name, #name);
  PREDEFINED_CONSTANTS(NODE_GEN)
  #undef NODE_GEN


  // generate function "init_type_nodes" to init type nodes, e.g.
  //   _Type_int32.type = Type_int32;
  printf("\n");
  printf("inline static void init_type_nodes() {\n");
  #define NODE_GEN(name) \
    printf("  _Type_%s.type = Type_%s;\n", #name, #name);
  TYPE_SYMS(NODE_GEN)
  TYPE_SYMS_PRIVATE(NODE_GEN)
  #undef NODE_GEN
  printf("}\n");


  // ---------------------------------------------------------------------------------------------
  // generate SymPool tree


  root = NULL;

  #define RB_GEN(symname, ...) root = RBInsert(root, symgetcstr(&syms, #symname), &added, NULL);
  TOKEN_KEYWORDS(RB_GEN)
  TYPE_SYMS(RB_GEN)
  // Note: TYPE_SYMS_PRIVATE are not exported in the global namespace
  PREDEFINED_CONSTANTS(RB_GEN)
  PREDEFINED_IDENTS(RB_GEN)
  #undef RB_GEN

  printf("\n%s\n", fmt_nodes(root, str_new(0)));

  printf("static SymRBNode* _symroot = &n_%s;\n", root->key);


  // ---------------------------------------------------------------------------------------------
  // generate _TypeCodeToTypeNodeMap

  printf("\n");
  printf("Node* const _TypeCodeToTypeNodeMap[TypeCode_CONCRETE_END] = {\n");

  size_t maxnamelen = 0;
  #define I_ENUM(name, _encoding, _flags) \
    if (TypeCode_##name < TypeCode_CONCRETE_END) \
      maxnamelen = MAX(strlen(#name), maxnamelen);
  TYPE_CODES(I_ENUM)
  #undef I_ENUM

  #define I_ENUM(name, _encoding, _flags) { \
    TypeCode tc = TypeCode_##name; \
    if (tc < TypeCode_CONCRETE_END) { \
      if (tc == TypeCode_NUM_END) { \
        printf("  NULL,                 "); \
      } else { \
        printf("  (Node*)&_Type_" #name ","); \
      } \
      printf("%-*s // TypeCode_" #name "\n", (int)(maxnamelen - strlen(#name)), ""); \
    } \
  }
  TYPE_CODES(I_ENUM)
  #undef I_ENUM
  printf("};\n");


  // ---------------------------------------------------------------------------------------------
  // generate a sort of checksum used in debug mode to make sure the generator is updated
  // when keywords change. See the function debug_check() below as well.
  int col = 0;
  printf(
    "#ifndef NDEBUG\n"
    "__attribute__((used)) static const char* const debugSymCheck =\n"
    "  \"");
  #define KW(str, tok)             \
    printf("%s#%03x ", #str, tok); \
    col += strlen(#str) + 6;       \
    if (col > 70) { col = 0; printf("\"\n  \""); }
  #define CONST(name, type, val)               \
    printf("%s:%s=%s ", #name, #type, #val);   \
    col += strlen(#name #type #val) + 3;      \
    if (col > 70) { col = 0; printf("\"\n  \""); }
  #define NAME(name)               \
    printf("%s ", #name);          \
    col += strlen(#name) + 1;      \
    if (col > 70) { col = 0; printf("\"\n  \""); }
  TOKEN_KEYWORDS(KW)
  TYPE_SYMS(NAME)
  PREDEFINED_CONSTANTS(CONST)
  PREDEFINED_IDENTS(NAME)
  #undef KW
  #undef CONST
  #undef NAME
  printf("\";\n#endif\n");


  // ---------------------------------------------------------------------------------------------

  printf("\n//-- END gen_constants() at %s:%d\n\n", __FILE__, __LINE__);
  sympool_dispose(&syms);
  exit(1);
}

#endif /* defined(RUN_GENERATOR) */


// -----------------------------------------------------------------------------------------------


#if !defined(NDEBUG) && !defined(RUN_GENERATOR)
__attribute__((constructor)) static void debug_check() {
  auto s = str_new(0);

  #define KW(str, tok)           s = str_appendfmt(s, "%s#%03x ", #str, tok);
  #define CONST(name, type, val) s = str_appendfmt(s, "%s:%s=%s ", #name, #type, #val);
  #define NAME(name)             s = str_appendcstr(s, #name " ");
  TOKEN_KEYWORDS(KW)
  TYPE_SYMS(NAME)
  PREDEFINED_CONSTANTS(CONST)
  PREDEFINED_IDENTS(NAME)
  #undef KW
  #undef CONST
  #undef NAME

  if (strcmp(debugSymCheck, s) != 0) {
    printf("Keywords changed.\n");
    printf("Define RUN_GENERATOR in %s to run code generator.\n", __FILE__);
    printf("\ndebugSymCheck:\n%s\n\ndetected:\n%s\n", debugSymCheck, s);
    exit(1);
  }
}
#endif
