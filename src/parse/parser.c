// SPDX-License-Identifier: Apache-2.0
// Copyright 2022 Rasmus Andersson. See accompanying LICENSE file for details.
#include "parse.h"

// Pratt-style recursive descent parser.
//
// Syntax productions are parsed by functions dubbed "parselets".
// They are defined with a magical comment described by the following eBNF:
//
//   infix  = <LF> "//!Parselet" ( "(" Tok Precedence ")" )+
//   prefix = <LF> "//!PrefixParselet" Tok+
//
// Examples:
//
//   //!Parselet (TPlus ADD) (TMinus ADD) (TStar MULTIPLY) (TSlash MULTIPLY)
//   static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left)
//
//   //!PrefixParselet TPlus TMinus TExcalm
//   static Node* PPrefixOp(Parser* p, PFlag fl)
//
// The parselet dispatch map for all tokens is generated by a script (parse_gen.py)
// which builds the "parselets" table (see end of file.)

// panic() on parse errors
#define DEBUG_PANIC_ON_PARSE_ERROR
//
// enable debug messages for pushScope() and popScope()
//#define DEBUG_SCOPE_PUSH_POP
//
// enable debug dumping of symbol bindings (scope stack)
//#define DEBUG_SCOPE_BINDINGS
//
// enable debug messages for defsym()
//#define DEBUG_DEFSYM
//
// enable debug messages for presolve_id_expr()
//#define DEBUG_LOOKUPSYM
//

ASSUME_NONNULL_BEGIN


// Operator precedence
// Precedence    Operator
//     5             *  /  %  <<  >>  &  &^
//     4             +  -  |  ^
//     3             ==  !=  <  <=  >  >=
//     2             &&
//     1             ||
//
typedef enum Precedence {
  PREC_LOWEST,
  PREC_ASSIGN,
  PREC_COMMA,
  PREC_LOGICAL_OR,
  PREC_LOGICAL_AND,
  PREC_BITWISE_OR,
  PREC_BITWISE_XOR,
  PREC_BITWISE_AND,
  PREC_EQUAL,
  PREC_COMPARE,
  PREC_SHIFT,
  PREC_ADD,
  PREC_MULTIPLY,
  PREC_UNARY_PREFIX,
  PREC_UNARY_POSTFIX,
  PREC_MEMBER,
} Precedence;


typedef enum PFlag {
  PFlagNone   = 0,
  PFlagRValue = 1 << 0, // parsing an rvalue
  PFlagType   = 1 << 1, // parsing a type
  PFlagMut    = 1 << 2, // "mut" outer
  PFlagVar    = 1 << 3, // "var" outer (explicit mutable local)
} PFlag;


typedef struct Parselet Parselet;

typedef Node* (ParseletPrefixFun)(Parser* p, PFlag fl);
typedef Node* nullable (ParseletFun) (Parser* p, const Parselet* e, PFlag fl, Node* left);
  // if an infix parselet returns null, "left" becomes the result

typedef struct Parselet {
  ParseletPrefixFun* fprefix;
  ParseletFun*       f;
  Precedence         prec;
} Parselet;

typedef struct UnresolvedNode {
  Source* src;
  Node*   n;
} UnresolvedNode;

typedef struct Unresolved {
  Sym            sym;
  u32            nodeslen;
  u32            nodescap;
  UnresolvedNode nodes[];
} Unresolved;


#define nexttok(p) ScannerNext((Scanner*)(p))
#define currpos(p) ScannerPos((Scanner*)(p))

#define FMTNODE(n,bufno) \
  fmtnode(n, p->build->tmpbuf[bufno], sizeof(p->build->tmpbuf[bufno]))


inline static Scanner pscan_state_save(const Parser* p) {
  return *(Scanner*)(p);
}

inline static void pscan_state_restore(Parser* p, Scanner state) {
  *(Scanner*)(p) = state;
}

// const char* type_name(Type* t)
#define type_name(n) _Generic((n), \
  Type*:   _type_name(n), \
  default: _type_name(as_Type(n)))
static const char* _type_name(Type* nullable t) {
  if (t)
    return TypeKindName(TF_Kind(t->tflags));
  return "<unknown type>";
}

// const char* node_type_name(Node* n)
// returns the name of n->type
#define node_type_name(n) _node_type_name(as_Node(n))
static const char* _node_type_name(Node* n) {
  if (!n)
    return _type_name(NULL);
  return type_name(TypeOfNode(n));
}

// syntaxerrp reports a source-token related syntax error.
// It will point to the source location of the last-scanned token.
// If n is not NULL, use source location of n instead of current location.
//
static Pos syntaxerrp(Parser* p, Pos pos, const char* format, ...) {
  bool autopos = pos == NoPos;
  if (autopos)
    pos = currpos(p);

  // select token name
  const char* tokname;
  if (p->tok == TNone) {
    tokname = "end of input";
  } else if (p->tok == TSemi && p->tokstart == p->linestart - 1) {
    // Implicit semicolon from linebreak
    tokname = "line break";
    // To improve the error message, find the pos of the linebreak
    if (autopos) {
      const u8* prevlinestart = p->prevtokend - 1;
      while (prevlinestart > p->src->body) {
        if (*prevlinestart == '\n')
          break;
        prevlinestart--;
      }
      u32 col = (u32)(uintptr)(p->prevtokend - prevlinestart);
      pos = pos_make(p->srcposorigin, p->lineno - 1, col, /*span*/0);
    }
  } else {
    tokname = TokName(p->tok);
  }

  // message buffer starts on the stack and overflows to heap memory if needed
  char msgbuf[512];
  Str msg = str_make(msgbuf, sizeof(msgbuf));

  // add message
  usize formatlen = strlen(format);
  if (formatlen == 0) {
    str_appendfmt(&msg, "unexpected %s", tokname);
  } else {
    if (
      shasprefix(format, formatlen, "expecting ") ||
      shasprefix(format, formatlen, "after ") ||
      shasprefix(format, formatlen, "in ") ||
      shasprefix(format, formatlen, "at ") )
    {
      str_appendfmt(&msg, "unexpected %s", tokname);
      if (tokname[0] == ';' || tokname[0] == ',') {
        str_appendc(&msg, ' ');
      } else {
        str_appendcstr(&msg, ", ");
      }
    }
    va_list ap;
    va_start(ap, format);
    str_appendfmtv(&msg, format, ap);
    va_end(ap);
  }

  // report
  b_diag(p->build, DiagError, (PosSpan){pos, NoPos}, str_cstr(&msg));

  #ifdef DEBUG_PANIC_ON_PARSE_ERROR
  panic("DEBUG_PANIC_ON_PARSE_ERROR %s", msg.v);
  #endif

  str_free(&msg);
  return pos;
}


// syntaxerr = syntaxerrp(p, <srcpos of current token>, ...)
#define syntaxerr(p, format, ...) \
  syntaxerrp((p), NoPos, format, ##__VA_ARGS__)


// toklistHas returns true if t is in list (list is expected to be 0-terminated)
static bool toklistHas(const Tok* list, Tok t) {
  Tok t2;
  while ((t2 = *list++)) {
    if (t2 == t)
      return true;
  }
  return false;
}


// advance consumes tokens until it finds a token of the stoplist.
// It is used to recover from parse errors and is not speed critical.
//
static void advance(Parser* p, const Tok* nullable stoplist) {
  nexttok(p); // guarantee progress
  if (stoplist == NULL || *stoplist == 0)
    return;

  if (p->fnest > 0) {
    // Stop at keywords that start a statement.
    // They are good synchronization points in case of syntax
    // errors and (usually) shouldn't be skipped over.
    while (!toklistHas(stoplist, p->tok)) {
      switch (p->tok) {
        case TNone:
        case TBreak:
        case TContinue:
        case TDefer:
        case TFor:
        case TIf:
        case TAuto:
        case TReturn:
        case TSwitch:
        case TType:
          return;
        default:
          break;
      }
      nexttok(p);
    }
  } else {
    while (p->tok != TNone && !toklistHas(stoplist, p->tok))
      nexttok(p);
  }
  // // slurp a trailing semicolon
  // if (p->tok == TSemi)
  //   nexttok(p);
}

// mknode allocates a new ast node
// T* mknode(Parser*, KIND)
#define mknode(p, KIND) b_mknode((p)->build, KIND, currpos(p))

#define mknode_array(p, KIND, ARRAY_FIELD, count) \
  b_mknode_array((p)->build, KIND, currpos(p), ARRAY_FIELD, (count))

// mktype allocates a new ast Type node
// T* mktype(Parser*, NODE_TYPE, TypeFlags tflags)
#define mktype(p, KIND, TYPE_FLAGS) ({                      \
  assert(NodeKindIsType(N##KIND));                          \
  KIND##Node* n__ = b_mknode((p)->build, KIND, currpos(p)); \
  n__->tflags = (TYPE_FLAGS);                               \
  n__;                                                      \
})

#define mktype_array(p, KIND, TYPE_FLAGS, ARRAY_FIELD, count) ({ \
  assert(NodeKindIsType(N##KIND)); \
  KIND##Node* n__ = b_mknode_array((p)->build, KIND, currpos(p), ARRAY_FIELD, (count)); \
  n__ ? ((n__->tflags = (TYPE_FLAGS)), n__) : NULL; \
})

// mkref_type creates a reference-type node
#define mkref_type(p, elem)     _mkref_type((p),as_Type(elem),false)
#define mkref_type_mut(p, elem) _mkref_type((p),as_Type(elem),true)
static Type* _mkref_type(Parser* p, Type* elem, bool mut) {
  RefTypeNode* t = mktype(p, RefType, TF_KindPointer);
  NodeSetConstCond(t, !mut);
  t->elem = elem;
  return (Type*)t;
}

// mkarray_type creates an array-type node, interning small basic ones.
#define mkarray_type(p, elem, size) _mkarray_type((p),as_Type(elem),(size))
static ArrayTypeNode* _mkarray_type(Parser* p, Type* elem, u64 size) {
  ArrayTypeNode* t = b_mknode(p->build, ArrayType, NoPos);
  t->tflags = TF_KindArray;
  t->elem = elem;
  t->size = size;
  // // intern small array types with basic element type
  // if (is_BasicTypeNode(elem) && size <= 32) {
  //   ArrayTypeNode* t1 = t;
  //   if (b_intern_type(p->build, &t))
  //     b_free_node(p->build, t1, ArrayType);
  // }
  return t;
}

// // strtype returns the common string type [u8]
// static Type* strtype(Parser* p) {
//   return mkref_type(p, mkarray_type(p, kType_u8, 0));
// }


// Node* set_endpos(Parser* p, Node* n)
#define set_endpos(p, n) ({ n->endpos = currpos(p); n; })

// precedence should match the calling parselet's own precedence
static Node* parse_next(Parser* p, int precedence, PFlag fl);
static Node* parse_prefix(Parser* p, PFlag fl);
static Node* parse_infix(Parser* p, int precedence, PFlag fl, Node* left);

// parse_next_tuple = Tuple | Expr
static Expr* parse_next_tuple(Parser* p, int precedence, PFlag fl);

static const char* local_kind_name(LocalNode* n) {
  switch (n->kind) {
    case NConst:         return "constant";
    case NVar:           return "variable";
    case NParam:         return "function parameter";
    case NTemplateParam: return "template parameter";
    default:             assert(0); return "";
  }
}


static void scopestackGrow(Parser* p) {
  u32 newcap = p->scopestack.cap * 2;
  Mem mem = p->build->mem;
  if (p->scopestack.ptr == p->scopestack.storage) {
    p->scopestack.ptr = mem_allocv(mem, sizeof(void*), newcap);
    if UNLIKELY(p->scopestack.ptr) {
      p->err = err_nomem;
    } else {
      memcpy(p->scopestack.ptr, p->scopestack.storage, sizeof(void*) * p->scopestack.len);
    }
  } else {
    void* ptr = mem_resizev(
      mem, p->scopestack.ptr, sizeof(void*), p->scopestack.cap, newcap);
    if UNLIKELY(ptr == NULL) {
      p->err = err_nomem;
    } else {
      p->scopestack.ptr = ptr;
    }
  }
  p->scopestack.cap = newcap;
}

#ifdef DEBUG_SCOPE_BINDINGS
  static void scopestackDebugDump(Parser* p) {
    dlog("scope bindings:");
    FILE* fp = stderr;
    // stack is arranged like this: | It can also look like this: (empty current scope)
    // [10] key4                    | [10] -- base=6 --
    // [9]  value4                  | [6]  -- base=0 --
    // [8]  key3                    | [5]  key2
    // [7]  value3                  | [4]  value2
    // [6]  -- base=0 --            | [3]  key1
    // [5]  key2                    | [2]  value1
    // [4]  value2                  |
    // [3]  key1                    |
    // [2]  value1                  |
    uintptr i = p->scopestack.len;
    uintptr base = p->scopestack.base;
    while (i > 1) {
      i--;
      if (i == base) {
        usize prevbase = (usize)base;
        base = (uintptr)p->scopestack.ptr[i];
        fprintf(fp, "  --------- (base %zu -> %zu)\n", prevbase, (usize)base);
      } else {
        Sym key = (Sym)p->scopestack.ptr[i];
        i--;
        Node* n = (Node*)p->scopestack.ptr[i];
        fprintf(fp, "  %s => %s %s\n", key, nodename(n), FMTNODE(n,0));
      }
    }
  }
#endif /* DEBUG_SCOPE_BINDINGS */


static void scopestackCheckUnused(Parser* p) {
  // only run when p->build->debug==true
  assert(p->scopestack.len > 0);
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (--i > base) {
    Sym key = (Sym)p->scopestack.ptr[i];
    i--;
    Node* n = (Node*)p->scopestack.ptr[i];
    //dlog(">>  %s => %s %s", key, nodename(n), FMTNODE(n,0));
    if UNLIKELY(key != kSym__ && is_LocalNode(n) && ((LocalNode*)n)->nrefs == 0) {
      // TODO: combine the error message with that of package-level reporter
      LocalNode* local = (LocalNode*)n;
      PosSpan ps = { n->pos, n->endpos };
      b_warnf(p->build, ps, "unused %s %s", local_kind_name(local), local->name);
    }
  }
}


// pushScope adds a new scope to the stack. Returns the new scope.
static void pushScope(Parser* p) {
  // add "scope starts here" to scopestack
  if (UNLIKELY(p->scopestack.cap - p->scopestack.len == 0))
    scopestackGrow(p);

  #ifdef DEBUG_SCOPE_PUSH_POP
    dlog("push scope; base %zu -> %zu",
      (usize)p->scopestack.base, (usize)p->scopestack.len);
  #endif

  p->scopestack.ptr[p->scopestack.len++] = (void*)p->scopestack.base;
  p->scopestack.base = p->scopestack.len - 1;
}


// popScope removes the topmost scope
static void popScope(Parser* p) {
  #ifdef DEBUG_SCOPE_PUSH_POP
  {
    usize nbindings = (usize)(p->scopestack.len - p->scopestack.base) / 2;
    dlog("pop scope; base %zu -> %zu (%zu bindings)",
      (usize)p->scopestack.base,
      (usize)(uintptr)p->scopestack.ptr[p->scopestack.base],
      nbindings);
  }
  #endif

  #ifdef DEBUG_SCOPE_BINDINGS
    scopestackDebugDump(p);
  #endif

  // rewind and restore base of parent scope
  p->scopestack.len = p->scopestack.base;
  p->scopestack.base = (uintptr)p->scopestack.ptr[p->scopestack.len];
}


inline static void popScopeAndCheckUnused(Parser* p) {
  // check for unused locals and parameters
  if (p->build->debug && p->scopestack.len - p->scopestack.base > 1)
    scopestackCheckUnused(p);
  popScope(p);
}


inline static void scopestackPush(Parser* p, Sym key, Node* value) {
  assert(p->scopestack.cap - p->scopestack.len > 1);
  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)value;
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)key;
  p->scopestack.len += 2;
}

// lookupsymPkg looks up node for key in the package scope.
static Node* nullable lookupsymPkg(Parser* p, Sym key) {
  // look in the package's scope (including universe)
  #ifdef DEBUG_LOOKUPSYM
    dlog("lookup \"%s\" fallback to pkg.scope", key);
  #endif
  Node* n = (Node*)ScopeLookup(p->build->pkg.scope, key);
  if (n) {
    if (NodeIsUnused(n)) // must check to avoid editing universe
      NodeClearUnused(n);
    if (p->scopestack.cap - p->scopestack.len > 1) {
      // Put it on the scopestack if there's space, as this will likely be
      // requested soon again.
      // For example, in this case "int" will lookupsym many times:
      //   fun foo(x, y int) int {
      //     tmp = 3 as int
      //     tmp + x + y
      //   }
      // However, with this optimization lookup of "int" only takes the slow path once
      // (for the first "int" in function params) and is then found in the local
      // scopestack for all remaining lookups of "int".
      scopestackPush(p, key, n);
    }
  }
  return n;
}

// lookupsym looks up node for key in the current scope, searching all parent scopes.
static Node* nullable lookupsym(Parser* p, Sym key) {
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      base = (uintptr)p->scopestack.ptr[i];
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  // not found in the current file's scope; look in the package's scope (including universe)
  return lookupsymPkg(p, key);
}


static Node* nullable lookupsymShallow(Parser* p, Sym key) {
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      break;
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  return NULL;
}


#ifdef DEBUG_LOOKUPSYM
  static Node* nullable lookupsym_debug(Parser* p, Sym key) {
    dlog("lookup \"%s\" ...", key);
    Node* n = lookupsym(p, key);
    if (n) {
      dlog("lookup \"%s\" => %s %s (%p)", key, nodename(n), FMTNODE(n,0), n);
    } else {
      dlog("lookup \"%s\" => (not found)", key);
    }
    return n;
  }
  #define lookupsym lookupsym_debug
#endif


#define defsym(p, s, n) _defsym((p), (s), as_Node(assertnotnull(n)))

static void _defsym(Parser* p, Sym s, Node* n) {
  assertf(is_Type(n)
       || is_LocalNode(n)
       || is_FieldNode(n)
       || is_FunNode(n)
       || is_TemplateNode(n)
       ,"%s !=", nodename(n));

  #ifdef DEBUG_DEFSYM
  Node* existing = lookupsymShallow(p, s);
  if (existing) {
    dlog("defsym %s => %s (replacing %s)", s, nodename(n), nodename(existing));
  } else {
    dlog("defsym %s => %s", s, nodename(n));
  }
  #endif

  if (UNLIKELY(p->scopestack.cap - p->scopestack.len < 2))
    scopestackGrow(p);

  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)n; // value
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)s; // key
  p->scopestack.len += 2;

  if (p->scopestack.base == 0) {
    // top level definition -- add to pkg.scope.
    // TODO: For imports, make sure to add to file scope instead of package scope
    //       Lazily create: p->file->array.scope=ScopeNew(p->pkg.scope, p->build->mem);
    p->err = ScopeAssign(p->build->pkg.scope, s, n, p->build->mem);
  }
}


// If the current token is t, advances scanner and returns true.
inline static bool got(Parser* p, Tok t) {
  if (p->tok != t)
    return false;
  nexttok(p);
  return true;
}

// want reports a syntax error if p->tok != t.
// In any case, this function will advance the scanner by one token.
inline static void want(Parser* p, Tok t) {
  if (UNLIKELY(!got(p, t))) {
    syntaxerr(p, "expecting %s", TokName(t));
    nexttok(p);
  }
}

static Node* bad(Parser* p) {
  return (Node*)mknode(p, Bad);
}


static bool name_is_pub(Sym name) {
  assert(symlen(name) > 0);
  return name[0] != '_';
}


// presolve_id_expr resolves an identifier, returning the effective node which may be
// either id or a simplification, like kExpr_true instead of (Id "true" -> kExpr_true)
static Expr* presolve_id_expr(Parser* p, IdNode* id) {
  assertnull(id->target);
  Node* target = lookupsym(p, assertnotnull(id->name));

  if LIKELY(target && is_Expr(target))
    return resolve_id_expr(id, (Expr*)target);

  if (!target) {
    NodeSetUnresolved(id);
  } else if (is_Type(target)) {
    const char* tkindname = TypeKindName(TF_Kind(as_Type(target)->tflags));
    syntaxerrp(p, id->pos, "%s is a %s, expected an expression", id->name, tkindname);
  } else {
    syntaxerrp(p, id->pos, "%s (%s) is not an expression", FMTNODE(target,0), id->name);
  }

  return (Expr*)id;
}


// presolve_id_type resolves a type identifier
static Type* presolve_id_type(Parser* p, IdTypeNode* id) {
  assertnull(id->target);
  Node* target = lookupsym(p, assertnotnull(id->name));

  // special case for nil since "nil" in universe is kExpr_nil
  if (target == (Node*)kExpr_nil)
    target = (Node*)kType_nil;

  if LIKELY(target && is_Type(target))
    return resolve_id_type(id, (Type*)target);

  if (!target) {
    NodeSetUnresolved(id);
  } else if (is_TemplateParamNode(target)) {
    dlog("TODO template param used as type");
    NodeSetUnresolved(id);
  } else if (is_Expr(target) && ((Expr*)target)->type) {
    // target is an expression with a type
    const char* tkindname = TypeKindName(TF_Kind(((Expr*)target)->type->tflags));
    syntaxerrp(p, id->pos, "%s is a %s, expected a type", id->name, tkindname);
  } else {
    syntaxerrp(p, id->pos, "%s (%s) is not a type", FMTNODE(target,0), id->name);
  }

  return (Type*)id;
}


static Type* nullable set_ctxtype(Parser* p, Type* nullable ctxtype) {
  Type* prev = p->ctxtype;
  p->ctxtype = ctxtype != kType_ideal ? unbox_id_type(ctxtype) : NULL;
  return prev;
}

static Type* expectType(Parser* p, Node* nullable n) {
  if (LIKELY(n == NULL || is_Type(n)))
    return (Type*)n;
  #ifdef DEBUG
    syntaxerrp(p, n->pos, "expected a type; got %s (N%s)", FMTNODE(n,0), nodename(n));
  #else
    syntaxerrp(p, n->pos, "expected a type; got %s", FMTNODE(n,0));
  #endif
  return (Type*)(n ? n : bad(p));
}

static Expr* expectExpr(Parser* p, Node* nullable n) {
  if (LIKELY(is_Expr(n) || n == NULL))
    return (Expr*)n;
  syntaxerrp(p, n->pos, "expected an expression (got %s)", FMTNODE(n,0));
  return (Expr*)(n ? n : bad(p));
}


// use_as_rvalue is used to lazily resolve identifiers which are used in rvalue position
// that is unknown ahead of time. Returns expr or its effective value.
// For example:
//   fun foo(x, y int) int {
//     x
//     ~ might be the beginning of a local definition
// Scenario 1:
//   fun foo(x, y int) int {
//     x = 4
//     ~~~~~ lvalue in a local definition; defining not resolving.
// Scenario 2:
//   fun foo(x, y int) int {
//     x + y
//     ~~~~~  Used as an rvalue in an op; call use_as_rvalue(x)
//
#define use_as_rvalue(p, n) _use_as_rvalue((p),as_Expr(n))
static Expr* _use_as_rvalue(Parser* p, Expr* n) {
  if (!NodeIsRValue(n)) // avoid mutating global constants from universe
    NodeSetRValue(n);
  if (n->kind == NId) {
    IdNode* id = as_IdNode(n);
    if (!id->target)
      presolve_id_expr(p, id);
  }
  return n;
}


// ============================================================================================
// ============================================================================================
// Parselets (upper case PName = pratt parselet, lower case pName = helper parselet)


// Type or Id (always rvalue)
inline static Type* pType(Parser* p, PFlag fl) {
  Node* n = parse_next(p, PREC_MEMBER, fl | PFlagType | PFlagRValue);
  return expectType(p, n);
}

// Expr
static Expr* pExpr(Parser* p, int precedence, PFlag fl) {
  Node* n = parse_next(p, precedence, fl);
  return expectExpr(p, n);
}


//!PrefixParselet TNil
static Node* PNil(Parser* p, PFlag fl) {
  nexttok(p);
  return as_Node(kExpr_nil);
}

//!PrefixParselet TAuto
static Node* PAuto(Parser* p, PFlag fl) {
  nexttok(p);
  return as_Node(kType_auto);
}


// PId -- identifier (as prefix)
// When parsing an rvalue identifier, PFlagRValue is set in fl
//
//!PrefixParselet TId
static Node* PId(Parser* p, PFlag fl) {
  Node* target = (fl & PFlagRValue) ? lookupsym(p, p->name) : NULL;
  Node* n;
  if (target) {
    // existing identifier
    if (is_TemplateParamNode(target) && (fl & PFlagType)) {
      TemplateParamNode* tparam = (TemplateParamNode*)target;
      auto tparamt = mknode(p, TemplateParamType);
      tparamt->param = tparam;
      NodeRefLocal(as_LocalNode(target));
      n = (Node*)tparamt;
    } else if (p->flags & ParseOpt) {
      // shortcut; return the target, skipping Id node indirection
      if (fl & PFlagType)
        expectType(p, target);
      n = target;
    } else if (is_Type(target)) {
      auto id = mknode(p, IdType);
      id->name = p->name;
      n = (Node*)resolve_id_type(id, (Type*)target);
    } else {
      assert_is_Expr(target);
      auto id = mknode(p, Id);
      id->name = p->name;
      n = (Node*)resolve_id_expr(id, (Expr*)target);
    }
  } else {
    // new identifier
    if (fl & PFlagType) {
      IdTypeNode* id = mknode(p, IdType);
      id->name = p->name;
      n = (Node*)id;
    } else {
      IdNode* id = mknode(p, Id);
      id->name = p->name;
      n = (Node*)id;
    }
    NodeSetUnresolved(n);
  }
  nexttok(p); // consume TId
  return n;
}


static void set_local_init(Parser* p, LocalNode* n, Expr* init) {
  init = use_as_rvalue(p, init);
  NodeTransferUnresolved(n, init);
  SetLocalInitField(n, init);

  if (!n->type) {
    // infer local's type from initializer
    if (init->type != kType_ideal)
      n->type = unbox_id_type(init->type);
    return;
  }

  if (!init->type || init->type == kType_ideal) {
    n->flags |= NF_PartialType;
    return;
  }

  if (!b_typelteq(p->build, n->type, init->type))
    n->flags |= NF_PartialType;

  if (is_RefTypeNode(n->type)) {
    // check refs
    if UNLIKELY( !is_RefTypeNode(init->type) ) {
      // e.g. "x &Foo = a"  (fix: "x &Foo = &a")
      syntaxerrp(p, init->pos, "cannot initialize reference with value");
      b_notef(p->build, NodePosSpan(init),
        "try referencing the value: &%s", FMTNODE(init,0));
    }
    return;
  }

  if UNLIKELY(init->type->kind == NRefType) {
    syntaxerrp(p, init->pos,
      "cannot initialize %s of type %s with value of type %s",
      local_kind_name(n), FMTNODE(n->type,0), FMTNODE(init->type,1));
  }
}


static LocalNode* make_local(
  Parser* p, NodeKind kind, IdNode* name, Expr* nullable init, Type* nullable t, Pos pos)
{
  assert(NodeKindIsLocal(kind));
  asserteq(name->kind, NId);

  LocalNode* n = b_mknode_union((p)->build, Local, pos);
  NodeSetConst(n);
  NodeSetUnused(n);
  NodeSetPublic(n, (p->fnest == 0 && name_is_pub(name->name)));
  n->kind = kind;
  n->pos = name->pos; // TODO: expand pos span to include type?
  n->name = name->name;
  n->type = unbox_id_type(t);

  if (init)
    set_local_init(p, n, init);

  if (n->name == kSym__) // "_" is the "ignore" name
    return n;

  Node* existing = lookupsymShallow(p, n->name);
  if UNLIKELY(existing) {
    b_warnf(p->build, NodePosSpan(name),
      "%s definition shadows %s",
      local_kind_name(n),
      is_LocalNode(existing) ? local_kind_name((LocalNode*)existing)
                             : nodename(existing) );
    b_notef(p->build, NodePosSpan(existing), "previous definition");
  }

  defsym(p, name->name, n);
  return n;
}


static void promote_local_to_mut(Parser* p, LocalNode* n) {
  if (n->kind == NParam)
    return;
  Type* t = n->type;
  // &[T N] => &[T]
  if (t && is_RefTypeNode(t) && is_ArrayTypeNode(((RefTypeNode*)t)->elem)) {
    ArrayTypeNode* at = (ArrayTypeNode*)((RefTypeNode*)t)->elem;
    if (at->size || at->sizeexpr)
      n->type = mkref_type(p, mkarray_type(p, at->elem, 0));
  }
}


static RefTypeNode* pRefType(Parser* p, PFlag fl) {
  auto n = mktype(p, RefType, TF_KindPointer);
  nexttok(p); // consume "&"
  // TODO: parse optional trailing "mut" kw?
  NodeSetConstCond(n, (fl & PFlagMut) == 0);
  n->elem = pType(p, fl | PFlagRValue);
  // n->flags = n->elem->flags & NF_Const;
  n->pos = pos_union(n->pos, n->elem->pos);
  NodeTransferUnresolved(n, n->elem);
  return n;
}


// MutType = "mut" Type
//!PrefixParselet TMut
static Node* PMut(Parser* p, PFlag fl) {
  Pos mut_pos = currpos(p);
  nexttok(p); // consume "mut"

  // expect "&"
  if (p->tok != TAnd) {
    syntaxerr(p, "expecting &");
    return bad(p);
  }
  auto t = pRefType(p, fl | PFlagMut);
  t->pos = pos_union(mut_pos, t->pos);
  return as_Node(t);
}


// LocalDef = ConstDef | VarDef
// ConstDef = "const" Id Type? "=" Expr
// VarDef   = "var" Id (Type | Type? "=" Expr)
//
// e.g. "var x int", "var x = 4", "var x int = 4"
// e.g. "const x int", "const x = 4", "const x int = 4"
//
//!PrefixParselet TVar TConst
static Node* PVarOrConst(Parser* p, PFlag fl) {
  bool isconst = p->tok == TConst;
  Pos pos = currpos(p);
  nexttok(p); // consume "var" or "const"

  IdNode* name = mknode(p, Id);
  name->name = p->name;
  if UNLIKELY(!got(p, TId))
    syntaxerr(p, "expecting identifier");

  SET_FLAG(fl, PFlagVar, !isconst);

  // type
  Type* typ = NULL;
  if (p->tok != TAssign) {
    // improved error message (we'd get a generic one from pType)
    if (UNLIKELY(p->tok == TSemi)) {
      Pos epos = syntaxerr(p, "expecting type or assignment of value");
      // help message (fixup)
      if (isconst) {
        // const x
        b_notef(p->build, (PosSpan){epos,epos},
          "Fix by assigning a value \"%s = VALUE\"", name->name);
      } else {
        // var x
        b_notef(p->build, (PosSpan){epos,epos},
          "Fix by adding a type \"%s TYPE\" or assigning a value \"%s = VALUE\"",
          name->name, name->name);
      }
    } else {
      typ = pType(p, fl);
      if (isconst && !is_BasicTypeNode(typ))
        NodeSetConst(typ);
    }
  }

  // init
  Expr* init = NULL;
  if (got(p, TAssign)) {
    // e.g. "var name = x"
    Type* ctxtype = set_ctxtype(p, typ);
    init = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
    if (typ == NULL)
      typ = init->type;
  } else if (isconst) {
    syntaxerr(p, "expecting assignment of value");
  }

  LocalNode* local = make_local(p, isconst ? NConst : NVar, name, init, typ, pos);
  return as_Node(local);
}


// e.g. "a = x"
// returns LocalNode or AssignNode
static Node* pAssignToId(Parser* p, const Parselet* e, PFlag fl, Node* idn) {
  IdNode* id = as_IdNode(idn);
  Expr* target = id->target;

  if (!target) {
    presolve_id_expr(p, id);
    target = id->target;
  }

  if (!target || !is_LocalNode(target)) {
    // local definition, e.g. "x = 3" -> (Local (Id x) (Int 3))
    nexttok(p); // consume '='
    Type* ctxtype = set_ctxtype(p, NULL);

    Node* n = parse_next(p, PREC_LOWEST, fl | PFlagRValue);
    Expr* init;
    if (is_Type(n)) {
      TypeExprNode* texpr = mknode(p, TypeExpr);
      texpr->elem = (Type*)n;
      texpr->type = kType_type;
      init = as_Expr(texpr);
    } else {
      init = expectExpr(p, n);
    }

    p->ctxtype = ctxtype;
    // note: make_local copies id->name & id->pos
    return as_Node(make_local(p, NVar, id, init, init->type, id->pos));
  }

  // assignment
  LocalNode* targetlocal = (LocalNode*)target;
  if UNLIKELY(is_ConstNode(targetlocal)) {
    b_errf(p->build, NodePosSpan(id),
      "cannot assign to constant %s", targetlocal->name);
    b_notef(p->build, NodePosSpan(targetlocal),
      "constant %s defined here", targetlocal->name);
    b_notef(p->build, NodePosSpan(id),
      "to define a new shadowing variable, use explicit mutability keyword"
      " mut or const. For example: mut %s = ...",
      targetlocal->name);
  }

  // assign to existing local and make sure the target is marked as variable
  NodeClearConst(targetlocal);
  NodeRefLocal(targetlocal);

  auto n = mknode(p, Assign);
  nexttok(p); // consume '='
  n->dst = as_Expr(targetlocal); // store target instead of NId to simplify IR generation

  Type* ctxtype = set_ctxtype(p, n->dst->type);
  n->val = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
  p->ctxtype = ctxtype;

  NodeTransferUnresolved(n, n->val);

  if (n->dst->type && n->val->type && b_typeeq(p->build, n->dst->type, n->val->type)) {
    NodeTransferPartialType2(n, n->dst, n->val);
    n->type = unbox_id_type(n->dst->type);
  }

  promote_local_to_mut(p, targetlocal);

  return as_Node(n);
}


// // PIdTrailing parses a trailing identifier, e.g. "b" in "a b"
// //
// //!Parselet (TId ASSIGN)
// static Node* PIdTrailing(Parser* p, const Parselet* e, PFlag fl, Node* left) {
//   dlog("TODO consider this syntax for calls");
//   syntaxerr(p, "unexpected identifier");
//   nexttok(p);
//   return bad(p);
// }


// assignment to fields, e.g. "x.y = 3" -> (assign (Selector (Id x) (Id y)) (Int 3))
static Node* pAssignToSelector(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  // auto dst = as_SelectorNode(dstn);
  panic("TODO pAssignToSelector");
  return bad(p);
}


// parse assignment of any right-hand-side expression
static Node* pAssignToBase(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  auto n = mknode(p, Assign);
  nexttok(p); // consume '='
  n->dst = as_Expr(dstn);
  n->val = parse_next_tuple(p, e->prec, fl | PFlagRValue);

  NodeTransferUnresolved2(n, n->dst, n->val);

  if (n->dst->type && n->dst->type == n->val->type) {
    NodeTransferPartialType2(n, n->dst, n->val);
    n->type = unbox_id_type(n->dst->type);
  }

  return as_Node(n);
}


// e.g. "a, b = x, y"
static Node* pAssignToTuple(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  assert(fl & PFlagRValue);
  AssignNode* n = as_AssignNode(pAssignToBase(p, e, fl, dstn));
  TupleNode* dst = as_TupleNode(dstn);

  TupleNode* val = maybe_TupleNode(n->val);
  if (!val) {
    syntaxerrp(p, dst->pos, "assignment mismatch: %u targets but 1 value", dst->a.len);
    return as_Node(n);
  }

  ExprArray* lnodes = &dst->a;
  ExprArray* rnodes = &val->a;

  if (lnodes->len != rnodes->len) {
    syntaxerrp(p, dst->pos, "assignment mismatch: %u targets but %u values",
      lnodes->len, rnodes->len);
    return as_Node(n);
  }

  for (u32 i = 0; i < lnodes->len; i++) {
    IdNode* dst = as_IdNode(lnodes->v[i]); // TODO: non-Id dst, e.g. "foo.bar = 3"
    Expr* init = rnodes->v[i];

    Expr* target = presolve_id_expr(p, dst);
    if (target) {
      NodeClearConst(target);
      if (is_LocalNode(target)) {
        LocalNode* targetlocal = (LocalNode*)target;
        NodeRefLocal(targetlocal);
        promote_local_to_mut(p, targetlocal);
      }
      NodeTransferUnresolved(n, init);
      lnodes->v[i] = target;
    } else {
      lnodes->v[i] = as_Expr(make_local(p, NVar, dst, init, init->type, dst->pos));
      rnodes->v[i] = NULL; // indicate that lnodes->v[i]->init is to be used
    }
  }

  return as_Node(n);
}


// Infix assignment e.g. "=" in "left = expr"
//!Parselet (TAssign ASSIGN)
static Node* nullable PAssign(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  fl |= PFlagRValue;
  switch (left->kind) {
    case NId:       MUSTTAIL return pAssignToId(p, e, fl, left);
    case NTuple:    MUSTTAIL return pAssignToTuple(p, e, fl, left);
    case NSelector: MUSTTAIL return pAssignToSelector(p, e, fl, left);
    case NIndex:    MUSTTAIL return pAssignToBase(p, e, fl, left);
    default:
      b_errf(p->build, NodePosSpan(left), "cannot assign to %s", FMTNODE(left,0));
      advance(p, (Tok[]){ TSemi, 0 });
      return NULL;
  }
}


// Group = "(" Expr ("," Expr)* ")"
// Groups are used to control precedence.
//!PrefixParselet TLParen
static Node* PGroup(Parser* p, PFlag fl) {
  nexttok(p); // consume "("
  Expr* n = parse_next_tuple(p, PREC_LOWEST, fl);
  want(p, TRParen);
  return as_Node(n);
}


// ArrayType = "[" Type size? "]"
// size      = Expr?
static Node* pArrayType(Parser* p, PFlag fl) {
  fl |= PFlagType;

  auto n = mktype(p, ArrayType, TF_KindArray);
  nexttok(p); // consume "["

  // Type
  n->elem = pType(p, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->elem);

  // size?
  if (p->tok != TRBrack) {
    n->sizeexpr = pExpr(p, PREC_LOWEST, (fl & ~PFlagType) | PFlagRValue);
    IntLitNode* zn = NodeEvalUint(p->build, n->sizeexpr);
    if (zn) {
      if (UNLIKELY(zn->ival > 0xFFFFFFFF))
        syntaxerrp(p, n->sizeexpr->pos, "array size too large");
      n->size = (u32)zn->ival;
    } else {
      // likely referencing a global constant yet to be parsed.
      // the type resolver will resolve its size when sizeexpr is known.
      NodeTransferUnresolved(n, n->sizeexpr);
      n->flags |= NF_PartialType;
    }
  }

  n->endpos = currpos(p);
  want(p, TRBrack);
  // return InternASTType(p->build, n);
  return as_Node(n);
}


// ArrayLit = "[" [ Expr (sep Expr)* sep? ] "]"
// sep      = "," | ";"
static Node* pArrayLit(Parser* p, PFlag fl) {
  fl |= PFlagRValue;
  auto n = mknode_array(p, Array, a, 8);
  if UNLIKELY(!n) return bad(p);
  nexttok(p); // consume "["

  // is there an array type context?
  Type* ctxtype = set_ctxtype(p, NULL); // save & set
  bool set_type = false;
  if (ctxtype && is_ArrayTypeNode(ctxtype)) {
    set_ctxtype(p, as_ArrayTypeNode(ctxtype)->elem);
    set_type = true;
  }

  // parse elements
  while (p->tok != TRBrack) {
    Expr* v = as_Expr(parse_next(p, PREC_LOWEST, fl));
    array_push(&n->a, v);
    if (set_type && (!v->type || !b_typeeq(p->build, p->ctxtype, v->type)))
      set_type = false;
    switch (p->tok) {
      case TComma:
      case TSemi:
        nexttok(p); // consume "," or ";"
        break; // continue reading more
      case TRBrack:
        break;
      default:
        syntaxerr(p, "expecting , ; or ]");
        advance(p, (Tok[]){ TRBrack, 0 });
        want(p, TRBrack);
        return as_Node(n);
    }
  }
  n->endpos = currpos(p);
  want(p, TRBrack);
  if (set_type) {
    // all elements are typed and of equal type (common case, e.g. "[1,2,3]")
    auto t = mktype(p, ArrayType, TF_KindArray);
    t->elem = p->ctxtype;
    t->size = n->a.len;
    n->type = as_Type(t);
  }
  p->ctxtype = ctxtype; // restore
  return as_Node(n);
}


//!PrefixParselet TLBrack
static Node* PLBrackPrefix(Parser* p, PFlag fl) {
  // array type "[T]"
  if (fl & PFlagType)
    return pArrayType(p, fl);
  // array literal "[1, 2, 3]"
  return pArrayLit(p, fl);
}


// Index | Slice
// Index = expr "[" expr "]"
// Slice = expr "[" expr? ":" expr? "]"
//
//!Parselet (TLBrack MEMBER)
static Node* PLBrackInfix(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  assert((fl & PFlagType) == 0); // indexing is not valid in type context
  auto n = mknode(p, Index);

  // warn if there's space in between "left" and "[" (e.g. "x [i]")
  if (UNLIKELY(p->prevtokend < p->tokstart)) {
    PosSpan pos = {0};
    u32 nspace = p->tokstart - p->prevtokend;
    pos.start = pos_with_adjusted_start(n->pos, -(i32)nspace);
    pos_set_width(&pos.start, nspace);
    b_warnf(p->build, pos, "misleading whitespace in subscript expression");
  }

  nexttok(p); // consume "["

  if (!is_Expr(left)) {
    syntaxerr(p, "can not index %s (%s)", FMTNODE(left,0), node_type_name(left));
    advance(p, (Tok[]){ TRBrack, 0 });
    want(p, TRBrack);
    return as_Node(n);
  }

  n->index = 0xffffffff; // not a compile-time constant (for now)
  n->operand = use_as_rvalue(p, left);
  NodeTransferUnresolved(n, n->operand);

  if (p->tok == TRBrack) { // "[]"
    syntaxerr(p, "missing index");
    nexttok(p); // consume unexpected "]"
    return as_Node(n);
  }

  if (p->tok != TColon) {
    n->indexexpr = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
    NodeTransferUnresolved(n, n->indexexpr);
  }

  if (p->tok == TColon) {
    // "[:" -- slice
    nexttok(p); // consume ":"
    // convert IndexNode to SliceNode
    static_assert(sizeof(SliceNode) <= sizeof(IndexNode), "");
    Expr* operand = n->operand;
    Expr* start = n->indexexpr;
    SliceNode* slice = CONVERT_NODE_KIND(n, Slice);
    slice->operand = operand;
    slice->start = start;
    if (p->tok != TRBrack) {
      slice->end = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
      NodeTransferUnresolved(slice, slice->end);
    } else {
      slice->end = NULL; // since we converted n kind
    }
  }

  want(p, TRBrack);
  return as_Node(n);
}


// Ref | RefType
// Ref     = "&" Expr
// RefType = "&" Type
//!PrefixParselet TAnd
static Node* PRefPrefix(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return as_Node(pRefType(p, fl));

  auto ref = mknode(p, Ref);
  nexttok(p); // consume "&"

  // reference target
  Expr* target = ref->target = pExpr(p, PREC_LOWEST, PFlagRValue);
  NodeTransferUnresolved(ref, target);

  // if the target is an id, use the id's target
  if (is_IdNode(target) && ((IdNode*)target)->target)
    target = ((IdNode*)target)->target;

  // mutability
  if (
    // e.g. "somefun(&y)"
    p->ctxtype ? ((fl & PFlagMut) == 0) :
    // e.g. "x = &y"
    !NodeIsUnresolved(target) && (
      // if the target is a "const name T = ..." then the ref is const too: "&T"
      // but for locals we leave the ref mutable.
      is_LocalNode(target) ? is_ConstNode(target) : NodeIsConst(target)
    )
    // else: target is a global (or undefined)
  ) {
    NodeSetConst(ref);
  } else if (is_LocalNode(target) && !is_ConstNode(target)) {
    // since we're making a mutable ref, treat it as a local store,
    // making sure the target local is upgraded to "mut".
    NodeClearConst(target);
    promote_local_to_mut(p, (LocalNode*)target);
  }

  // element type of our reference (e.g. "int" in "x = 1; typeof(&x) // &int")
  Type* elemtype = unbox_id_type(target->type);
  if (elemtype == NULL || elemtype == kType_ideal) {
    // target is not yet typed; type will be resolved and checked post parsing
    return as_Node(ref);
  }

  // TODO: consider moving the rest of this function into the type resolver and
  // use it both here and there, as we need to perform the same logic in both places.

  // check compatibility with any current context type, e.g. for local initializer
  if (p->ctxtype) {
    if (UNLIKELY(
      !is_RefTypeNode(p->ctxtype) ||
      !b_typeeq(p->build, ((RefTypeNode*)p->ctxtype)->elem, elemtype)) )
    {
      // not a ref type or a ref type of incompatible element type
      syntaxerrp(p, ref->pos,
        "cannot use expression of type %s&%s; expected type %s",
        NodeIsConst(ref) ? "" : "mut", FMTNODE(elemtype,0), FMTNODE(p->ctxtype,1) );
      return as_Node(ref);
    }
    // context type matches; can we use it?
    if (NodeIsConst(((RefTypeNode*)p->ctxtype)->elem) == NodeIsConst(elemtype)) {
      // Note: this saves us from the mknode call later on but apart from that
      // yields an equivalent type and return value.
      ref->type = p->ctxtype;
      return as_Node(ref);
    }
  } else if (UNLIKELY( is_RefTypeNode(elemtype) )) {
    // Target is a reference itself -- can't reference a reference!
    // Note: in C, the equivalent would be to take the address of a pointer, which in Co is
    // not a thing (even if it was, it would lead to too much confusion w/ eg "T&&" types.)
    syntaxerrp(p, ref->pos, "cannot reference a reference (type %s)", FMTNODE(elemtype,0));
    return as_Node(ref);
  }

  // create ref type using the target type as our element type
  RefTypeNode* t = mknode(p, RefType);
  t->elem = elemtype;
  NodeTransferUnresolved(t, elemtype);
  NodeTransferConst(t, ref);
  ref->type = as_Type(t);

  return as_Node(ref);
}


// As = lhs "as" Type
// "as" has the lowest precedence and thus... Examples:
//
//   "9 * 2 as int8"         => (TypeCast int8 (Op * (Int 9) (Int 2)))
//   "9 * (2 as int8)"       => (Op * (Int 9) (TypeCast int8 (Int 2)))
//   "9, 2 as (int8,int8)"   => (Int 9) (TypeCast (Tuple int8 int8) (Int 2))
//   "(9, 2) as (int8,int8)" => (TypeCast (Tuple int8 int8) (Tuple (Int 9) (Int 2)))
//
//!Parselet (TAs LOWEST)
static Node* PAs(Parser* p, const Parselet* e, PFlag fl, Node* lhs) {
  auto n = mknode(p, TypeCast);
  nexttok(p); // consume "as"
  n->expr = expectExpr(p, lhs);
  n->type = pType(p, fl);
  if (NodeIsUnresolved(n->expr))
    n->type->tflags |= NF_PartialType;
  return as_Node(n);
}


// args = arg (sep arg)* sep?
// arg  = Id "=" Expr | Expr
// sep  = "," | ";"
static NodeFlags pArgs(Parser* p, ExprArray* args, PFlag fl) {
  fl |= PFlagRValue;
  NodeFlags flags = 0;
  u32 index = 0;
  Expr* arg;

  for (;;) {
    if (p->tok == TId) {
      // save position and consume identifier token
      Pos pos = currpos(p);
      Sym name = p->name;
      nexttok(p);
      // next token decides argument node type
      if (got(p, TAssign)) {
        // named argument (e.g. "name = expr")
        NamedArgNode* namedarg = b_mknode(p->build, NamedArg, pos);
        namedarg->name = name;
        namedarg->value = pExpr(p, PREC_LOWEST, fl);
        flags |= NF_Named; // "has named argument"
        arg = as_Expr(namedarg);
      } else {
        // plain identifier.
        // Since we look ahead and consume the TId token up front,
        // emulate pExpr with PId prefix by continue parsing with parse_infix.
        IdNode* id = b_mknode(p->build, Id, pos);
        id->name = name;
        arg = presolve_id_expr(p, id);
        arg = expectExpr(p, parse_infix(p, PREC_LOWEST, fl, as_Node(arg)));
        if (flags & NF_Named)
          goto err_pos_after_named;
      }
    } else {
      arg = pExpr(p, PREC_LOWEST, fl);
      if (flags & NF_Named)
        goto err_pos_after_named;
    }

    NodeSetRValue(arg);
    flags |= arg->flags & NF_Unresolved;
    array_push(args, arg);

    switch (p->tok) {
      case TComma:
      case TSemi:
        nexttok(p);
        if (p->tok == TRParen)
          break; // trailing "," or ";"
        // continue reading more
        index++;
        break;
      case TRParen: // ")" ends argument list
        goto end;
      default:
        syntaxerr(p, "expecting , ; or )");
        advance(p, (Tok[]){ TRParen, 0 });
        want(p, TRParen);
        goto end;
    }
  }
end:
  return flags;

err_pos_after_named:
  // e.g. "(a, b=3, c)" -- positional arg c follows named arg b
  syntaxerrp(p, arg->pos, "positional argument following named argument");
  return flags;
}


//!Parselet (TLParen MEMBER)
static Node* PCall(Parser* p, const Parselet* e, PFlag fl, Node* receiver) {
  auto call = mknode_array(p, Call, args, 8);
  if UNLIKELY(!call) return bad(p);
  nexttok(p); // consume "("

  // receiver
  if (is_Expr(receiver)) {
    receiver = as_Node(use_as_rvalue(p, receiver));
  } else if (is_IdTypeNode(receiver)) {
    receiver = (Node*)unbox_id_type1((IdTypeNode*)receiver);
  }
  NodeTransferUnresolved(call, receiver);
  call->receiver = receiver;
  call->args_pos = call->pos;

  if (p->tok == TRParen) { // e.g. "()"
    call->endpos = currpos(p);
    nexttok(p); // consume ")"
    return as_Node(call);
  }

  // args
  if (is_BasicTypeNode(receiver)) {
    // fast path for primitive types e.g. "i16(123)".
    // convert Call to TypeCast
    TypeCastNode* tcast = CONVERT_NODE_KIND(call, TypeCast);
    tcast->type = (Type*)receiver;

    // save & alter ctxtype
    bool is_explicit_ctxtype = p->is_explicit_ctxtype;
    p->is_explicit_ctxtype = true;
    Type* ctxtype = set_ctxtype(p, (Type*)receiver);

    tcast->expr = pExpr(p, PREC_LOWEST, fl | PFlagRValue);

    // restore ctxtype
    p->is_explicit_ctxtype = is_explicit_ctxtype;
    p->ctxtype = ctxtype;

    if (tcast->type == tcast->expr->type) {
      // short circuit e.g. "x = i64(3)"
      // TODO: expand pos & endpos to include "type(3)"
      call = (CallNode*)as_Node(tcast->expr);
    }
  } else {
    call->flags |= pArgs(p, &call->args, fl);
  }

  call->endpos = currpos(p);
  want(p, TRParen);
  return as_Node(call);
}


// Field = ( Id Type | IdType ) ( "=" Expr )?
static FieldNode* pField(Parser* p) {
  asserteq(p->tok, TId);
  auto field = mknode(p, Field);
  field->name = p->name;
  nexttok(p);

  if (UNLIKELY(p->tok == TSemi)) {
    // e.g. just "type" (name is implicit)
    auto typename = mknode(p, IdType);
    typename->name = field->name;
    field->type = presolve_id_type(p, typename);
    field->flags |= NF_Base;
  } else {
    // e.g. "name type"
    // custom error for "field = value"
    if (UNLIKELY(p->tok == TAssign)) {
      syntaxerr(p, "expecting type");
      field->type = kType_nil;
    } else {
      field->type = pType(p, PFlagNone);
    }
  }

  if (UNLIKELY(field->name == kSym__))
    syntaxerrp(p, field->pos, "invalid field name; all fields must be named");

  // check for duplicate names
  Node* existing = lookupsymShallow(p, field->name);
  if (existing) {
    syntaxerrp(p, field->pos, "Duplicate field name \"%s\"", field->name);
    b_notef(p->build, NodePosSpan(existing), "Also defined here");
  }

  defsym(p, field->name, field);

  if (got(p, TAssign)) {
    // e.g. "field = initval"
    Type* ctxtype = set_ctxtype(p, field->type);
    field->init = pExpr(p, PREC_LOWEST, PFlagRValue);
    p->ctxtype = ctxtype; // restore ctxtype
    NodeTransferUnresolved(field, field->init);
    field->flags |= NF_CustomInit; // TODO: only set if field->init is not zero/default
    field->flags |= NF_PartialType;
  }

  NodeTransferCustomInit(field, field->type);
  NodeTransferUnresolved(field, field->type);

  return field;
}


static bool end_block(Parser* p) {
  if (UNLIKELY(p->tok != TRBrace)) {
    syntaxerr(p, "expecting ; or }");
    return false;
  }
  // following is a dance to look ahead for tokens which when following
  // a block does not warrant an implicit semicolon. E.g. "if { } else ..."
  auto scanstate = pscan_state_save(p);
  nexttok(p); // consume '}' and read next token
  if (p->tok != TElse && p->tok != TSemi) {
    pscan_state_restore(p, scanstate);
    p->tok = TSemi; // produce semicolon instead of '}'
  }
  return true;
}


// StructType = {" fields? "}"
// fields     = Field ( ";" Field )* ";"?
static Node* pStructType(Parser* p, PFlag fl, StructTypeNode* stype) {
  asserteq(p->tok, TLBrace);
  nexttok(p); // consume "{"

  stype->name = p->typename;
  p->typename = NULL;

  pushScope(p);

  while (p->tok != TNone && p->tok != TRBrace) {
    if (UNLIKELY(p->tok != TId)) {
      syntaxerr(p, "expecting field or type name");
      break;
    }
    if (UNLIKELY(stype->fields.len == 0xFFFFFFFF)) {
      // overflow protection
      syntaxerr(p, "too many stuct fields");
      advance(p, (Tok[]){ TRBrace, 0 });
      break;
    }

    auto field = pField(p);
    NodeTransferUnresolved(stype, field);
    NodeTransferCustomInit(stype, field);
    array_push(&stype->fields, field);

    if (!got(p, TSemi))
      break;
  }

  end_block(p);

  popScope(p);
  // note: we only allow refs to previously defined fields to enforce no cycles.
  // Thus we don't save the scope here.
  return as_Node(stype);
}


// StructTypeDef = "struct" StructType
//!PrefixParselet TStruct
static Node* PStructType(Parser* p, PFlag fl) {
  auto stype = mktype_array(p, StructType, TF_KindStruct, fields, 4);
  if UNLIKELY(!stype) return bad(p);
  nexttok(p); // consume "struct"

  // TODO: when infix, assign stype->name

  // name
  if (p->tok == TId) {
    p->typename = p->name;
    // make sure to define the struct before parsing its body
    defsym(p, p->name, stype);
    nexttok(p); // consume name
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // body
  if (UNLIKELY(p->tok != TLBrace)) {
    syntaxerr(p, "expecting { ... }");
    return as_Node(stype);
  }

  return pStructType(p, fl, stype);
}


// TypeAlias = "type" Id Type
//
//!PrefixParselet TType
static Node* PAliasType(Parser* p, PFlag fl) {
  auto alias = mknode(p, AliasType);
  nexttok(p); // consume "type"
  NodeSetConst(alias);
  NodeSetUnused(alias);

  if (UNLIKELY( p->tok != TId )) {
    syntaxerr(p, "expecting name");
    return as_Node(alias);
  }

  alias->name = p->name;
  // make sure to define the type before parsing a potential struct body
  defsym(p, p->name, alias);
  alias->pos = pos_union(alias->pos, currpos(p)); // include name
  nexttok(p); // consume name

  NodeSetPublic(alias, (p->fnest == 0 && name_is_pub(alias->name)));

  p->typename = alias->name;
  alias->elem = pType(p, PFlagNone);
  NodeTransferUnresolved(alias, alias->elem);

  // struct with custom initializers must be visited by the type resolver,
  // so be conservative with propagating the type here.
  if (alias->elem->flags & (NF_CustomInit | NF_PartialType))
    alias->flags |= NF_PartialType;

  return as_Node(alias);
}


// Block = "{" Expr* "}"
// NOTE: it's the callers responsibility to call pushScope & popScope
static Expr* pBlock(Parser* p, PFlag fl, bool may_simplify) {
  auto block = mknode_array(p, Block, a, 4);
  if UNLIKELY(!block) return (Expr*)bad(p);
  nexttok(p); // consume "{"

  Expr* cn = NULL;
  while (p->tok != TNone && p->tok != TRBrace) {
    cn = parse_next_tuple(p, PREC_LOWEST, fl & ~PFlagRValue);
    array_push(&block->a, cn);
    NodeTransferUnresolved(block, cn);
    if (!got(p, TSemi))
      break;
  }

  // Note: if end_block(p) fails, a syntax error is logged
  if (end_block(p) && cn) {
    // if last expression is a local, increment its refcount
    if (is_LocalNode(cn))
      NodeRefLocal(as_LocalNode(cn));

    // last expression is used as rvalue
    block->a.v[block->a.len - 1] = use_as_rvalue(p, cn);
  }

  set_endpos(p, block);

  // simplify a block with a single expression to just that expression
  if (may_simplify && block->a.len == 1 && is_Expr(block->a.v[0])) {
    Expr* n = block->a.v[0];
    b_free_node(p->build, block, Block);
    return n;
  }

  return as_Expr(block);
}


// BlockOrStructType = Block | StructType
// Block = "{" Expr* "}"
//!PrefixParselet TLBrace
static Node* PBlockOrStructType(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return pStructType(p, fl, mktype(p, StructType, TF_KindStruct));
  pushScope(p);
  Expr* block = pBlock(p, fl, /*may_simplify*/false);
  popScopeAndCheckUnused(p);
  return as_Node(block);
}


// PrefixOp = ( "+" | "-" | "!" | "*" ) Expr
//!PrefixParselet TPlus TMinus TExcalm TStar
static Node* PPrefixOp(Parser* p, PFlag fl) {
  auto op = mknode(p, PrefixOp);
  op->op = p->tok;
  nexttok(p);
  op->expr = pExpr(p, PREC_MEMBER, fl | PFlagRValue);
  NodeTransferUnresolved(op, op->expr);
  return as_Node(op);
}


// InfixOp = Expr ( "+" | "-" | "*" | "/" ) Expr
//!Parselet (TPipePipe LOGICAL_OR)
//          (TAndAnd LOGICAL_AND)
//          (TPipe BITWISE_OR)
//          (THat BITWISE_XOR)
//          (TAnd BITWISE_AND)
//          (TEq EQUAL) (TNEq EQUAL)
//          (TLt COMPARE) (TGt COMPARE) (TLEq COMPARE) (TGEq COMPARE)
//          (TPlus ADD) (TMinus ADD)
//          (TStar MULTIPLY) (TSlash MULTIPLY)
static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto op = mknode(p, BinOp);
  op->op = p->tok;
  nexttok(p); // consume "+"
  op->left = use_as_rvalue(p, left);
  Type* ctxtype = set_ctxtype(p, op->left->type);
  op->right = pExpr(p, e->prec, fl | PFlagRValue);
  p->ctxtype = ctxtype; // restore ctxtype
  NodeTransferUnresolved2(op, op->left, op->right);
  return as_Node(op);
}


// PostfixOp = Expr ( "++" | "--" )
//!Parselet (TPlusPlus UNARY_POSTFIX) (TMinusMinus UNARY_POSTFIX)
static Node* PPostfixOp(Parser* p, const Parselet* e, PFlag fl, Node* operand) {
  auto op = mknode(p, PostfixOp);
  op->op = p->tok;
  nexttok(p); // consume "++"
  op->expr = use_as_rvalue(p, operand);
  NodeTransferUnresolved(op, op->expr);
  return as_Node(op);
}


// Selector = Expr "." Id
//!Parselet (TDot MEMBER)
static Node* PSelector(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto sel = mknode_array(p, Selector, indices, 4);
  if UNLIKELY(!sel) return bad(p);
  nexttok(p); // consume "."

  sel->operand = use_as_rvalue(p, left);

  // member is a name
  if (UNLIKELY(p->tok != TId)) {
    syntaxerr(p, "expecting member name");
    return as_Node(sel);
  }
  sel->member = p->name;
  set_endpos(p, sel); // extend sel to include member id
  nexttok(p); // consume id

  sel->flags = sel->operand->flags;
  return as_Node(sel);
}


// IntLit = [0-9]+
//!PrefixParselet TIntLit
static Node* PIntLit(Parser* p, PFlag fl) {
  auto lit = mknode(p, IntLit);
  usize len = p->tokend - p->tokstart;

  error err = sparse_u64((const char*)p->tokstart, len, /*base*/10, &lit->ival);
  if UNLIKELY(err) {
    syntaxerrp(p, lit->pos,
      (err == err_overflow) ? "integer literal too large" : "invalid integer literal");
  }

  nexttok(p);

  lit->type = kType_ideal;
  if (!p->ctxtype)
    return as_Node(lit);

  CTypecastFlags tcfl = p->is_explicit_ctxtype ? CTypecastFExplicit : 0;
  return as_Node(ctypecast(p->build, lit, p->ctxtype, NULL, NULL, tcfl));
}


// StrLit = " ... "   TODO syntax
//!PrefixParselet TStrLit
static Node* PStrLit(Parser* p, PFlag fl) {
  auto n = b_mknodev((p)->build, StrLit, p->tokpos, p, p->sval.len);
  nexttok(p); // consume

  NodeSetConst(n);
  NodeSetRValue(n);
  n->len = p->sval.len;
  memcpy(n->p, p->sval.p, (usize)p->sval.len);

  // typeof("foo") => &[u8 3]
  auto arrayt = mkarray_type(p, kType_u8, (u64)p->sval.len);
  n->type = mkref_type(p, arrayt);
  n->type->pos = pos_with_width(n->pos, 0);

  return as_Node(n);
}


// If = "if" Expr Expr
//!PrefixParselet TIf
static Node* PIf(Parser* p, PFlag fl) {
  auto ifn = mknode(p, If);
  nexttok(p);
  ifn->cond = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
  ifn->thenb = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
  NodeTransferUnresolved2(ifn, ifn->cond, ifn->thenb);
  NodeSetRValueCond(ifn, (fl & PFlagRValue));
  if (p->tok == TElse) {
    nexttok(p);
    ifn->elseb = pExpr(p, PREC_LOWEST, fl);
    NodeTransferUnresolved(ifn, ifn->elseb);
  }
  return as_Node(ifn);
}


// Return = "return" Expr?
//!PrefixParselet TReturn
static Node* PReturn(Parser* p, PFlag fl) {
  auto ret = mknode(p, Return);
  if (UNLIKELY(p->fnest == 0)) {
    // return outside a function
    syntaxerrp(p, ret->pos, "return outside function body");
  }
  nexttok(p);
  if (p->tok != TSemi && p->tok != TRBrace) {
    // parse_next_tuple to allow "return 1, 2, 3" in addition to "return (1, 2, 3)"
    ret->expr = parse_next_tuple(p, PREC_LOWEST, fl | PFlagRValue);
    NodeTransferUnresolved(ret, ret->expr);
  }
  return as_Node(ret);
}


// params = "(" param (sep param)* sep? ")"
// param  = Id Type? | Type
// sep    = "," | ";"
//
static void pFunParams(Parser* p, FunNode* fn) {
  // examples:
  //
  // (T)
  // (x T)
  // (x, y, z T)
  // (... T)
  // (x  ... T)
  // (x, y, z  ... T)
  // (T1, T2, T3)
  // (T1, T2, ... T3)
  //
  fn->params_pos.start = currpos(p);
  assert(p->tok == TLParen);
  nexttok(p); // consume "("

  // empty params? eg "()"
  if (got(p, TRParen))
    return;

  bool hasTypedParam = false; // true when at least one param has type; e.g. "x T"
  PFlag fl = PFlagRValue;

  // typeq: temporary storage for LocalNodes to support "typed groups" of parameters,
  // e.g. "x, y int" -- "x" does not have a type until we parsed "y" and "int", so when
  // we parse "x" we put it in typeq. Also, "x" might be just a type and not a name in
  // the case all args are just types e.g. "T1, T2, T3".
  Node* typeq_st[32];
  auto typeq = array_make(NodeArray, typeq_st, sizeof(typeq_st));

  while (1) {
    auto param = mknode(p, Param);
    NodeSetConst(param);
    NodeSetUnused(param);
    array_push(&fn->params, param);

    if (p->tok == TId) {
      // name eg "x"
      param->name = p->name;
      nexttok(p);
      switch (p->tok) {
        case TRParen:
        case TComma:
        case TSemi:
          // just a lone name, eg "x" in "(x, y)"
          array_push(&typeq, as_Node(param));
          break;

        default:
          // type follows name, eg "x int"
          param->type = pType(p, fl);
          hasTypedParam = true;
          // cascade type to predecessors
          for (u32 i = 0; i < typeq.len; i++)
            ((LocalNode*)typeq.v[i])->type = unbox_id_type(param->type);
          typeq.len = 0;
      }
    } else {
      // definitely just type, e.g. "fun([]int,bool)"
      param->type = pType(p, fl);
    }

    // end loop?
    switch (p->tok) {
      case TComma:
      case TSemi:
        nexttok(p); // consume "," or ";"
        if (p->tok == TRParen)
          goto finish; // trailing "," or ";"
        break; // continue reading more
      case TRParen:
        goto finish;
      default:
        syntaxerr(p, "expecting , ; or )");
        advance(p, (Tok[]){ TRParen, 0 });
        goto finish;
    }
  }

finish:
  if (hasTypedParam) {
    // name-and-type form; e.g. "(x, y T, z Y)"
    if (typeq.len > 0) {
      // at least one param has type, but the last one does not.
      // e.g. "(x, y int, z)"
      syntaxerr(p, "expecting type");
    }
    u32 index = 0;
    for (u32 i = 0; i < fn->params.len; i++) {
      auto param = as_ParamNode(fn->params.v[i]);
      param->index = index++;
      defsym(p, param->name, param);
    }
  } else {
    // type-only form, e.g. "(T, T, Y)"
    // make ident of each cn->local.name where cn->type == NULL
    //
    // TODO: for template parameters, this case means "name only without type constraints"
    //
    u32 index = 0;
    for (u32 i = 0; i < fn->params.len; i++) {
      auto param = as_ParamNode(fn->params.v[i]);
      if (!param->type) {
        auto tname = mknode(p, IdType);
        tname->name = param->name;
        param->name = kSym__;
        param->index = index++;
        param->type = presolve_id_type(p, tname);
      }
    }
  }

  for (u32 i = 0; i < fn->params.len; i++) {
    auto param = as_ParamNode(fn->params.v[i]);
    NodeTransferUnresolved(param, param->type);
    NodeTransferUnresolved(fn, param);
  }

  array_free(&typeq);

  fn->params_pos.end = currpos(p);
  want(p, TRParen);
}


// parse template parameters, e.g. "<T, R=T>"
static void pTemplateParams(Parser* p, TemplateNode* tpl) {
  tpl->params_pos.start = currpos(p);
  assert(p->tok == TLt);
  nexttok(p); // consume "<"

  PFlag fl = PFlagNone; // lvalue semantics

  if UNLIKELY(p->tok == TGt) {
    syntaxerr(p, "empty template parameter list");
    nexttok(p); // consume ">"
    return;
  }

  u32 index = 0;
  do {
    if (UNLIKELY(p->tok != TId)) {
      syntaxerr(p, "expecting %s", TokName(TId));
      advance(p, (Tok[]){ TGt, 0 });
      break;
    }

    TemplateParamNode* param = mknode(p, TemplateParam);

    NodeSetConst(param);
    NodeSetUnused(param);
    param->name = p->name;
    param->type = kType_nil;
    param->index = index++;
    nexttok(p); // consume id
    array_push(&tpl->params, param);

    // TODO: constraints

    // default value? e.g. "T=something"
    if (got(p, TAssign))
      param->init = parse_prefix(p, fl | PFlagRValue);

    // duplicate name?
    if UNLIKELY(lookupsymShallow(p, param->name))
      b_errf(p->build, NodePosSpan(param), "duplicate template parameter %s", param->name);

    // define in scope
    defsym(p, param->name, param);

  } while (got(p, TComma) && p->tok != TGt);

  tpl->params_pos.end = currpos(p);
  want(p, TGt);
}


// "<" ... ">"
static TemplateNode* nullable pTemplate(
  Parser* p, Sym nullable name, TypeKind prodkind, u32 nparam_hint)
{
  assert(p->tok == TLt); // note: pTemplateParams consumes this token

  TemplateTypeNode* t = mktype(p, TemplateType, TF_KindTemplate);
  t->prodkind = prodkind;

  TemplateNode* tpl = mknode_array(p, Template, params, nparam_hint);
  if UNLIKELY(!tpl) return NULL;
  NodeSetUnused(tpl);
  tpl->name = name;
  tpl->type = as_Type(t);

  // parse parameters
  pTemplateParams(p, tpl);
  tpl->endpos = tpl->params_pos.end;

  if (name)
    defsym(p, name, tpl);

  return tpl;
}


// Fun     = FunDef | FunExpr
// FunDef  = "fun" Id? params? Type? Block?
// FunExpr = "fun" Id? params? Type? "->" Expr
//
// e.g.
//   fun foo (x, y int) int
//   fun foo (x, y int) int { x * y }
//   fun foo { 5 }
//   fun foo -> 5
//   fun (x, y int) int { x * y }
//   fun { 5 }
//   fun -> 5
//
//!PrefixParselet TFun
static Node* PFun(Parser* p, PFlag fl) {
  auto fn = mknode_array(p, Fun, params, 2);
  if UNLIKELY(!fn) return bad(p);
  nexttok(p); // consume "fun"

  // name
  if (p->tok == TId) {
    fn->name = p->name;
    nexttok(p);
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // template parameters, e.g. "fun foo<T, R>(...)" => NTemplate
  TemplateNode* tpl = NULL;
  if (p->tok == TLt) {
    pushScope(p); // template parameter scope
    tpl = pTemplate(p, fn->name, TF_KindFunc, /*nparam_hint*/2);
    if UNLIKELY(!tpl) {
      popScope(p);
      return bad(p);
    }
  } else if (fn->name) {
    defsym(p, fn->name, fn);
  }

  // function parameters
  pushScope(p); // body AND parameter scope
  if (p->tok == TLParen) {
    pFunParams(p, fn);
    fn->endpos = fn->params_pos.end;
  } else {
    fn->endpos = currpos(p);
  }

  // result type(s)
  if (p->tok != TLBrace && p->tok != TSemi) {
    if (p->tok == TRArr) {
      // e.g. "fun foo() -> 123" => "fun foo() auto { 123 }"
      fn->result = kType_auto;
      fn->endpos = currpos(p);
      nexttok(p);
    } else {
      fn->result = pType(p, fl);
      NodeTransferUnresolved(fn, fn->result);
      fn->endpos = pos_max(fn->result->pos, fn->result->endpos);
    }
  } else {
    // no result type specified is the same as "nil" (does not return a value)
    fn->result = kType_nil;
  }

  // body
  p->fnest++;
  PFlag bodyfl = (fn->result == kType_nil) ? (fl & ~PFlagRValue) : (fl | PFlagRValue);
  if (p->tok == TLBrace) {
    // assign body before parsing so that we can check for it in pBlock
    assert((fl & PFlagType) == 0); // needed for PBlockOrStructType
    fn->body = pBlock(p, bodyfl, /*may_simplify*/true);
  } else if (got(p, TRArr)) {
    fn->body = parse_next_tuple(p, PREC_LOWEST, bodyfl);
  }
  p->fnest--;

  if (fn->body) {
    NodeTransferUnresolved(fn, fn->body);
    popScopeAndCheckUnused(p); // function parameter scope
  } else {
    popScope(p);
  }

  if (!tpl)
    return as_Node(fn);

  popScopeAndCheckUnused(p); // template parameter scope
  tpl->body = as_Node(fn);
  return as_Node(tpl);
}


// unsafe = "unsafe" (fun_def | block)
//
//!PrefixParselet TUnsafe
static Node* PUnsafe(Parser* p, PFlag fl) {
  Pos pos = currpos(p);
  pos_set_width(&pos, strlen("unsafe"));
  nexttok(p); // consume keyword

  Node* n;

  switch (p->tok) {
    case TFun:
      n = PFun(p, fl);
      break;
    case TLBrace:
      pushScope(p);
      n = (Node*)pBlock(p, fl, /*may_simplify*/false);
      popScopeAndCheckUnused(p);
      pos = pos_union(pos, n->pos);
      break;
    default: {
      // create an implicit block for single-expression unsafe scope
      // e.g. "x = unsafe foo()" => "x = unsafe { foo() }"
      auto block = b_mknode_array(p->build, Block, pos, a, 1);
      if UNLIKELY(!block) return bad(p);
      block->flags |= NF_Unsafe;
      Expr* expr = pExpr(p, PREC_LOWEST, fl);
      block->endpos = expr->endpos;
      array_push(&block->a, expr);
      n = (Node*)block;
    }
  }

  n->pos = pos;
  n->flags |= NF_Unsafe;
  return n;
}


// end of parselets
// ============================================================================================
// ============================================================================================


// parselets
ASSUME_NONNULL_END
#include "parser_gen.h"
ASSUME_NONNULL_BEGIN


static Node* parse_prefix(Parser* p, PFlag fl) {
  // find prefix parselet
  assert(p->tok < Tok_MAX);
  const Parselet* parselet = &parselets[p->tok];
  if (!parselet->fprefix) {
    // dlog("parse_prefix NOT found for %s", TokName(p->tok));
    syntaxerr(p, (fl & PFlagType) ? "expecting type" : "expecting expression");
    Node* n = bad(p);
    advance(p, (Tok[]){ TRParen, TRBrace, TRBrack, TSemi, 0 });
    return n;
  }
  // dlog("parse_prefix FOUND for %s", TokName(p->tok));
  return parselet->fprefix(p, fl);
}


static Node* parse_infix(Parser* p, int precedence, PFlag fl, Node* left) {
  // wrap parselets
  // TODO: Should we set fl|PFlagRValue here?
  while (p->tok != TNone) {
    const Parselet* parselet = &parselets[p->tok];
    assertnotnull(parselet);
    // if (parselet->f) {
    //   dlog("infix parselet FOUND for %s; parselet->prec=%d < precedence=%d = %s",
    //     TokName(p->tok), parselet->prec, precedence,
    //     (int)parselet->prec < precedence ? "Y" : "N");
    // } else {
    //   dlog("infix parselet NOT found for %s", TokName(p->tok));
    // }
    if (!parselet->f || (int)parselet->prec < precedence) {
      break;
    }
    Node* expr = parselet->f(p, parselet, fl, left);
    if (expr == NULL)
      return left;
    assert(left != expr); // or else: infinite loop
    left = expr;
  }
  return left;
}


static Node* parse_next(Parser* p, int precedence, PFlag fl) {
  // Note: precedence should match the calling parselet's own precedence
  Node* left = parse_prefix(p, fl);
  return parse_infix(p, precedence, fl, left);
}


// parse_multi_expr parses expressions separated by comma.
// It enters at the first comma, after the first element (elem0) and keeps on parsing
// expressions as long as each expression is followed by a comma.
//
// For example, in "a, b, c d" parse_multi_expr enters at the first comman with elem0="a"
// and parses a tuple "(a b c)". It stops before "d" as "c" has no trailing comma.
//
// If in_prefix_mode is true, only prefix parselets are used, meaning that in the
// example "a + b, c + d" only "(b c)" can be parsed successfully with in_prefix_mode=true,
// while if in_prefix_mode=false, the result would be "((binop a b) (binop c d))".
//
// TODO: can we implement this with infix parser instead, with proper precedence?
//
static TupleNode* parse_multi_expr(
  Parser* p, int precedence, PFlag fl, Expr* elem0, bool in_prefix_mode)
{
  assert(p->tok == TComma);
  nexttok(p);

  auto tuple = mknode_array(p, Tuple, a, 4);
  if UNLIKELY(!tuple) return (TupleNode*)bad(p);

  array_push(&tuple->a, elem0);
  NodeTransferUnresolved(tuple, elem0);

  if (in_prefix_mode) {
    do {
      Expr* cn = expectExpr(p, parse_prefix(p, fl));
      array_push(&tuple->a, cn);
      NodeTransferUnresolved(tuple, cn);
    } while (got(p, TComma));
  } else {
    do {
      Expr* cn = pExpr(p, precedence, fl);
      array_push(&tuple->a, cn);
      NodeTransferUnresolved(tuple, cn);
    } while (got(p, TComma));
  }

  set_endpos(p, tuple);
  return tuple;
}


// parse_next_tuple = Expr | Tuple
//
// This function has different behavior depending on PFlagRValue:
//
//   PFlagRValue=OFF consumes a parse_prefix, then a possible tuple and finally calls
//   parse_infix to include the tuple in an infix expression like t + y.
//
//   - PFlagRValue=OFF is "conservative" used for lvalues, e.g. (a b c) in a,b,c=1,2,3
//   - PFlagRValue=ON is "greedy" and used for rvalues, e.g. (x (y + z)) in _,_=x,y+z
//
//   Consider the following source code:
//     a, b + c, d
//   Parsing this with the different functions yields:
//   - PFlagRValue=OFF => (+ (a b) c)
//   - PFlagRValue=ON => (a (+ b c) d)
//
//   Explanation of PFlagRValue=OFF:
//   • PFlagRValue=OFF calls parse_prefix => a
//   • PFlagRValue=OFF sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=OFF calls parse_prefix => b
//   • PFlagRValue=OFF end tuple => (a b)
//   • parse_infix with tuple as the LHS:
//     • parse_infix calls '+' parselet
//       • '+' parselet reads RHS by calling expr:
//         • expr calls parse_prefix (which in turn calls 'ident' parselet) => c
//         • expr returns the c identifier (NId)
//       • '+' parselet produces LHS + RHS => (+ (a b) c)
//     • return
//   • return
//
//   Explanation of PFlagRValue=ON:
//   • PFlagRValue=ON calls expr => a
//   • PFlagRValue=ON sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=ON calls expr
//     • expr calls parse_prefix => b
//     • expr calls parse_infix with b as LHS:
//       • parse_infix calls '+' parselet
//         • '+' parselet reads RHS by calling expr:
//           • expr calls parse_prefix => c
//           • expr returns the c identifier (NId)
//         • '+' parselet produces LHS + RHS => (+ b c)
//       • return
//     • return
//   • PFlagRValue=ON calls expr after another comma
//     • calls parse_prefix => b
//   • PFlagRValue=ON see no more comma; ends the tuple => (a (+ b c) d)
//
static Expr* parse_next_tuple(Parser* p, int precedence, PFlag fl) {
  Node* left = (fl & PFlagRValue) ? parse_next(p, precedence, fl)
                                  : parse_prefix(p, fl);
  Expr* expr = expectExpr(p, left);
  if (p->tok == TComma)
    expr = (Expr*)parse_multi_expr(p, precedence, fl, expr, (fl & PFlagRValue));

  if (fl & PFlagRValue)
    return expr;

  // wrap in possible infix expression, e.g. "left + right"
  return expectExpr(p, parse_infix(p, precedence, fl, (Node*)expr));
}


error parse_tu(Parser* p, BuildCtx* b, Source* src, ParseFlags pflags, FileNode** result) {
  // clear result now so that we don't have to in error branches
  *result = NULL;

  // initialize scanner state
  if ((p->err = ScannerInit((Scanner*)p, b, src, pflags)))
    return p->err;

  // initialize parser state
  p->build = b;
  p->fnest = 0;
  p->is_explicit_ctxtype = false;

  // initialize or reset scopestack
  if (p->scopestack.ptr == NULL) {
    p->scopestack.cap = countof(p->scopestack.storage);
    p->scopestack.ptr = p->scopestack.storage;
  } else {
    p->scopestack.len = 0;
    p->scopestack.base = 0;
  }

  // load first token
  nexttok(p);

  // create FileNode to hold what we parse
  auto file = mknode_array(p, File, a, 16);
  if (!file)
    return err_nomem;
  file->name = src->filename;

  PFlag fl = 0;

  // while we have a valid token...
  while (p->tok != TNone && p->err == 0) {
    // find & call prefix parselet for the current token
    Node* n = parse_prefix(p, fl);

    // if we got a trailing comma, parse as a tuple. e.g. "x,y = a,b"
    if (p->tok == TComma) {
      Expr* expr = expectExpr(p, n);
      n = (Node*)parse_multi_expr(p, PREC_LOWEST, fl, expr, /*in_prefix_mode*/true);
    }

    // wrap in possible infix expression, e.g. "left + right"
    n = parse_infix(p, PREC_LOWEST, fl, n);

    // add to file
    array_push(&file->a, n);
    NodeTransferUnresolved(file, n);

    // if we didn't end on EOF and we didn't find a semicolon, report error
    if UNLIKELY( p->tok != TNone && !got(p, TSemi) ) {
      syntaxerr(p, "after top level declaration");
      if (n && is_IdNode(n)) {
        b_notef(b, (PosSpan){n->pos,NoPos},
          "Did you mean \"var %s\"?", as_IdNode(n)->name);
      }
      advance(p, (Tok[]){ TType, TFun, TSemi, 0 });
    }
  }

  *result = file;
  return p->err;
}


ASSUME_NONNULL_END
