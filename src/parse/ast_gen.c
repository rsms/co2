// generated by ast_gen.py -- do not edit
#include "../coimpl.h"
#include "ast.h"

const char* NodeKindName(NodeKind k) {
  // kNodeNameTable[NodeKind] => const char* name
  static const char* const kNodeNameTable[NodeKind_MAX+2] = {
"Bad", "Field", "Pkg", "File", "Comment", "Nil", "BoolLit", "IntLit",
    "FloatLit", "StrLit", "Id", "BinOp", "PrefixOp", "PostfixOp", "Return",
    "Assign", "Tuple", "Array", "Block", "Fun", "Macro", "Call", "TypeCast",
    "Const", "Var", "Param", "MacroParam", "Ref", "NamedArg", "Selector",
    "Index", "Slice", "If", "TypeType", "NamedType", "AliasType", "RefType",
    "BasicType", "ArrayType", "TupleType", "StructType", "FunType", "?"
  };
  return kNodeNameTable[MIN(NodeKind_MAX+2,k)];
}

static error ASTVisitorNoop(ASTVisitor* v, const Node* n) { return 0; }

void ASTVisitorInit(ASTVisitor* v, const ASTVisitorFuns* f) {
  ASTVisitorFun dft = (f->Node ? f->Node : &ASTVisitorNoop), dft1 = dft;
  // populate v->ftable
  v->ftable[NBad] = f->Bad ? ((ASTVisitorFun)f->Bad) : dft;
  v->ftable[NField] = f->Field ? ((ASTVisitorFun)f->Field) : dft;
  // begin Stmt
  if (f->Stmt) { dft1 = dft; dft = ((ASTVisitorFun)f->Stmt); }
  // begin CUnit
  if (f->CUnit) { dft1 = dft; dft = ((ASTVisitorFun)f->CUnit); }
  v->ftable[NPkg] = f->Pkg ? ((ASTVisitorFun)f->Pkg) : dft;
  v->ftable[NFile] = f->File ? ((ASTVisitorFun)f->File) : dft;
  dft = dft1; // end CUnit
  v->ftable[NComment] = f->Comment ? ((ASTVisitorFun)f->Comment) : dft;
  dft = dft1; // end Stmt
  // begin Expr
  if (f->Expr) { dft1 = dft; dft = ((ASTVisitorFun)f->Expr); }
  // begin LitExpr
  if (f->LitExpr) { dft1 = dft; dft = ((ASTVisitorFun)f->LitExpr); }
  v->ftable[NNil] = f->Nil ? ((ASTVisitorFun)f->Nil) : dft;
  v->ftable[NBoolLit] = f->BoolLit ? ((ASTVisitorFun)f->BoolLit) : dft;
  v->ftable[NIntLit] = f->IntLit ? ((ASTVisitorFun)f->IntLit) : dft;
  v->ftable[NFloatLit] = f->FloatLit ? ((ASTVisitorFun)f->FloatLit) : dft;
  v->ftable[NStrLit] = f->StrLit ? ((ASTVisitorFun)f->StrLit) : dft;
  dft = dft1; // end LitExpr
  v->ftable[NId] = f->Id ? ((ASTVisitorFun)f->Id) : dft;
  v->ftable[NBinOp] = f->BinOp ? ((ASTVisitorFun)f->BinOp) : dft;
  // begin UnaryOp
  if (f->UnaryOp) { dft1 = dft; dft = ((ASTVisitorFun)f->UnaryOp); }
  v->ftable[NPrefixOp] = f->PrefixOp ? ((ASTVisitorFun)f->PrefixOp) : dft;
  v->ftable[NPostfixOp] = f->PostfixOp ? ((ASTVisitorFun)f->PostfixOp) : dft;
  dft = dft1; // end UnaryOp
  v->ftable[NReturn] = f->Return ? ((ASTVisitorFun)f->Return) : dft;
  v->ftable[NAssign] = f->Assign ? ((ASTVisitorFun)f->Assign) : dft;
  // begin ListExpr
  if (f->ListExpr) { dft1 = dft; dft = ((ASTVisitorFun)f->ListExpr); }
  v->ftable[NTuple] = f->Tuple ? ((ASTVisitorFun)f->Tuple) : dft;
  v->ftable[NArray] = f->Array ? ((ASTVisitorFun)f->Array) : dft;
  dft = dft1; // end ListExpr
  v->ftable[NBlock] = f->Block ? ((ASTVisitorFun)f->Block) : dft;
  v->ftable[NFun] = f->Fun ? ((ASTVisitorFun)f->Fun) : dft;
  v->ftable[NMacro] = f->Macro ? ((ASTVisitorFun)f->Macro) : dft;
  v->ftable[NCall] = f->Call ? ((ASTVisitorFun)f->Call) : dft;
  v->ftable[NTypeCast] = f->TypeCast ? ((ASTVisitorFun)f->TypeCast) : dft;
  // begin Local
  if (f->Local) { dft1 = dft; dft = ((ASTVisitorFun)f->Local); }
  v->ftable[NConst] = f->Const ? ((ASTVisitorFun)f->Const) : dft;
  v->ftable[NVar] = f->Var ? ((ASTVisitorFun)f->Var) : dft;
  v->ftable[NParam] = f->Param ? ((ASTVisitorFun)f->Param) : dft;
  v->ftable[NMacroParam] = f->MacroParam ? ((ASTVisitorFun)f->MacroParam) : dft;
  dft = dft1; // end Local
  v->ftable[NRef] = f->Ref ? ((ASTVisitorFun)f->Ref) : dft;
  v->ftable[NNamedArg] = f->NamedArg ? ((ASTVisitorFun)f->NamedArg) : dft;
  v->ftable[NSelector] = f->Selector ? ((ASTVisitorFun)f->Selector) : dft;
  v->ftable[NIndex] = f->Index ? ((ASTVisitorFun)f->Index) : dft;
  v->ftable[NSlice] = f->Slice ? ((ASTVisitorFun)f->Slice) : dft;
  v->ftable[NIf] = f->If ? ((ASTVisitorFun)f->If) : dft;
  dft = dft1; // end Expr
  // begin Type
  if (f->Type) { dft1 = dft; dft = ((ASTVisitorFun)f->Type); }
  v->ftable[NTypeType] = f->TypeType ? ((ASTVisitorFun)f->TypeType) : dft;
  v->ftable[NNamedType] = f->NamedType ? ((ASTVisitorFun)f->NamedType) : dft;
  v->ftable[NAliasType] = f->AliasType ? ((ASTVisitorFun)f->AliasType) : dft;
  v->ftable[NRefType] = f->RefType ? ((ASTVisitorFun)f->RefType) : dft;
  v->ftable[NBasicType] = f->BasicType ? ((ASTVisitorFun)f->BasicType) : dft;
  v->ftable[NArrayType] = f->ArrayType ? ((ASTVisitorFun)f->ArrayType) : dft;
  v->ftable[NTupleType] = f->TupleType ? ((ASTVisitorFun)f->TupleType) : dft;
  v->ftable[NStructType] = f->StructType ? ((ASTVisitorFun)f->StructType) : dft;
  v->ftable[NFunType] = f->FunType ? ((ASTVisitorFun)f->FunType) : dft;
  // end Type
}
