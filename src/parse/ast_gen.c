// generated by ast_gen.py -- do not edit
#include "parse.h"

const char* NodeKindName(NodeKind k) {
  // kNodeNameTable[NodeKind] => const char* name
  static const char* const kNodeNameTable[NodeKind_MAX+2] = {
"Bad", "Field", "Pkg", "File", "Comment", "Nil", "BoolLit", "IntLit",
    "FloatLit", "StrLit", "Id", "BinOp", "PrefixOp", "PostfixOp", "Return",
    "Assign", "Tuple", "Array", "Block", "Fun", "Call", "Template",
    "TemplateInstance", "TypeCast", "Const", "Var", "Param", "TemplateParam",
    "Ref", "NamedArg", "Selector", "Index", "Slice", "If", "TypeExpr",
    "TypeType", "IdType", "AliasType", "RefType", "BasicType", "ArrayType",
    "TupleType", "StructType", "FunType", "TemplateType", "TemplateParamType",
    "?"
  };
  return kNodeNameTable[MIN(NodeKind_MAX+1,k)];
}

const u8 kNodeStructSizeTab[46] = {
  sizeof(struct BadNode),
  sizeof(struct FieldNode),
  sizeof(struct PkgNode),
  sizeof(struct FileNode),
  sizeof(struct CommentNode),
  sizeof(struct NilNode),
  sizeof(struct BoolLitNode),
  sizeof(struct IntLitNode),
  sizeof(struct FloatLitNode),
  sizeof(struct StrLitNode),
  sizeof(struct IdNode),
  sizeof(struct BinOpNode),
  sizeof(struct PrefixOpNode),
  sizeof(struct PostfixOpNode),
  sizeof(struct ReturnNode),
  sizeof(struct AssignNode),
  sizeof(struct TupleNode),
  sizeof(struct ArrayNode),
  sizeof(struct BlockNode),
  sizeof(struct FunNode),
  sizeof(struct CallNode),
  sizeof(struct TemplateNode),
  sizeof(struct TemplateInstanceNode),
  sizeof(struct TypeCastNode),
  sizeof(struct ConstNode),
  sizeof(struct VarNode),
  sizeof(struct ParamNode),
  sizeof(struct TemplateParamNode),
  sizeof(struct RefNode),
  sizeof(struct NamedArgNode),
  sizeof(struct SelectorNode),
  sizeof(struct IndexNode),
  sizeof(struct SliceNode),
  sizeof(struct IfNode),
  sizeof(struct TypeExprNode),
  sizeof(struct TypeTypeNode),
  sizeof(struct IdTypeNode),
  sizeof(struct AliasTypeNode),
  sizeof(struct RefTypeNode),
  sizeof(struct BasicTypeNode),
  sizeof(struct ArrayTypeNode),
  sizeof(struct TupleTypeNode),
  sizeof(struct StructTypeNode),
  sizeof(struct FunTypeNode),
  sizeof(struct TemplateTypeNode),
  sizeof(struct TemplateParamTypeNode),
};

static void ASTVisitorNoop(ASTVisitor* v, const ASTParent* parent, Node* n) {
  if (is_LitExpr(n)) return;
  ASTVisitChildren(v, parent, n);
}

void ASTVisitorInit(ASTVisitor* v, const ASTVisitorFuns* f, void* nullable ctx) {
  v->ctx = ctx;
  array_init(&v->seenstack, v->seenstack_st, sizeof(v->seenstack_st));
  ASTVisitorFun dft = (f->Node ? f->Node : &ASTVisitorNoop), dft1 = dft;

  // populate v->ftable
  v->ftable[NBad] = f->Bad ? ((ASTVisitorFun)f->Bad) : dft;
  v->ftable[NField] = f->Field ? ((ASTVisitorFun)f->Field) : dft;
  // begin Stmt
  if (f->Stmt) { dft1 = dft; dft = ((ASTVisitorFun)f->Stmt); }
  // begin CUnit
  if (f->CUnit) { dft1 = dft; dft = ((ASTVisitorFun)f->CUnit); }
  v->ftable[NPkg] = f->Pkg ? ((ASTVisitorFun)f->Pkg) : dft;
  v->ftable[NFile] = f->File ? ((ASTVisitorFun)f->File) : dft;
  dft = dft1; // end CUnit
  v->ftable[NComment] = f->Comment ? ((ASTVisitorFun)f->Comment) : dft;
  dft = dft1; // end Stmt
  // begin Expr
  if (f->Expr) { dft1 = dft; dft = ((ASTVisitorFun)f->Expr); }
  // begin LitExpr
  if (f->LitExpr) { dft1 = dft; dft = ((ASTVisitorFun)f->LitExpr); }
  v->ftable[NNil] = f->Nil ? ((ASTVisitorFun)f->Nil) : dft;
  v->ftable[NBoolLit] = f->BoolLit ? ((ASTVisitorFun)f->BoolLit) : dft;
  v->ftable[NIntLit] = f->IntLit ? ((ASTVisitorFun)f->IntLit) : dft;
  v->ftable[NFloatLit] = f->FloatLit ? ((ASTVisitorFun)f->FloatLit) : dft;
  v->ftable[NStrLit] = f->StrLit ? ((ASTVisitorFun)f->StrLit) : dft;
  dft = dft1; // end LitExpr
  v->ftable[NId] = f->Id ? ((ASTVisitorFun)f->Id) : dft;
  v->ftable[NBinOp] = f->BinOp ? ((ASTVisitorFun)f->BinOp) : dft;
  // begin UnaryOp
  if (f->UnaryOp) { dft1 = dft; dft = ((ASTVisitorFun)f->UnaryOp); }
  v->ftable[NPrefixOp] = f->PrefixOp ? ((ASTVisitorFun)f->PrefixOp) : dft;
  v->ftable[NPostfixOp] = f->PostfixOp ? ((ASTVisitorFun)f->PostfixOp) : dft;
  dft = dft1; // end UnaryOp
  v->ftable[NReturn] = f->Return ? ((ASTVisitorFun)f->Return) : dft;
  v->ftable[NAssign] = f->Assign ? ((ASTVisitorFun)f->Assign) : dft;
  // begin ListExpr
  if (f->ListExpr) { dft1 = dft; dft = ((ASTVisitorFun)f->ListExpr); }
  v->ftable[NTuple] = f->Tuple ? ((ASTVisitorFun)f->Tuple) : dft;
  v->ftable[NArray] = f->Array ? ((ASTVisitorFun)f->Array) : dft;
  v->ftable[NBlock] = f->Block ? ((ASTVisitorFun)f->Block) : dft;
  dft = dft1; // end ListExpr
  v->ftable[NFun] = f->Fun ? ((ASTVisitorFun)f->Fun) : dft;
  v->ftable[NCall] = f->Call ? ((ASTVisitorFun)f->Call) : dft;
  v->ftable[NTemplate] = f->Template ? ((ASTVisitorFun)f->Template) : dft;
  v->ftable[NTemplateInstance] = f->TemplateInstance ? ((ASTVisitorFun)f->TemplateInstance) : dft;
  v->ftable[NTypeCast] = f->TypeCast ? ((ASTVisitorFun)f->TypeCast) : dft;
  // begin Local
  if (f->Local) { dft1 = dft; dft = ((ASTVisitorFun)f->Local); }
  v->ftable[NConst] = f->Const ? ((ASTVisitorFun)f->Const) : dft;
  v->ftable[NVar] = f->Var ? ((ASTVisitorFun)f->Var) : dft;
  v->ftable[NParam] = f->Param ? ((ASTVisitorFun)f->Param) : dft;
  v->ftable[NTemplateParam] = f->TemplateParam ? ((ASTVisitorFun)f->TemplateParam) : dft;
  dft = dft1; // end Local
  v->ftable[NRef] = f->Ref ? ((ASTVisitorFun)f->Ref) : dft;
  v->ftable[NNamedArg] = f->NamedArg ? ((ASTVisitorFun)f->NamedArg) : dft;
  v->ftable[NSelector] = f->Selector ? ((ASTVisitorFun)f->Selector) : dft;
  v->ftable[NIndex] = f->Index ? ((ASTVisitorFun)f->Index) : dft;
  v->ftable[NSlice] = f->Slice ? ((ASTVisitorFun)f->Slice) : dft;
  v->ftable[NIf] = f->If ? ((ASTVisitorFun)f->If) : dft;
  v->ftable[NTypeExpr] = f->TypeExpr ? ((ASTVisitorFun)f->TypeExpr) : dft;
  dft = dft1; // end Expr
  // begin Type
  if (f->Type) { dft1 = dft; dft = ((ASTVisitorFun)f->Type); }
  v->ftable[NTypeType] = f->TypeType ? ((ASTVisitorFun)f->TypeType) : dft;
  v->ftable[NIdType] = f->IdType ? ((ASTVisitorFun)f->IdType) : dft;
  v->ftable[NAliasType] = f->AliasType ? ((ASTVisitorFun)f->AliasType) : dft;
  v->ftable[NRefType] = f->RefType ? ((ASTVisitorFun)f->RefType) : dft;
  v->ftable[NBasicType] = f->BasicType ? ((ASTVisitorFun)f->BasicType) : dft;
  v->ftable[NArrayType] = f->ArrayType ? ((ASTVisitorFun)f->ArrayType) : dft;
  v->ftable[NTupleType] = f->TupleType ? ((ASTVisitorFun)f->TupleType) : dft;
  v->ftable[NStructType] = f->StructType ? ((ASTVisitorFun)f->StructType) : dft;
  v->ftable[NFunType] = f->FunType ? ((ASTVisitorFun)f->FunType) : dft;
  v->ftable[NTemplateType] = f->TemplateType ? ((ASTVisitorFun)f->TemplateType) : dft;
  v->ftable[NTemplateParamType] = f->TemplateParamType ? ((ASTVisitorFun)f->TemplateParamType) : dft;
  // end Type
}

void ASTVisitorDispose(ASTVisitor* v) {
  array_free(&v->seenstack);
}
