// co source code parser
#include "../coimpl.h"
#include "parse.h"
#include "eval.h"
#include "resolve_id.h"
#include "ctypecast.h"

// Pratt-style recursive descent parser.
//
// Syntax productions are parsed by functions dubbed "parselets".
// They are defined with a magical comment described by the following eBNF:
//
//   infix  = <LF> "//!Parselet" ( "(" Tok Precedence ")" )+
//   prefix = <LF> "//!PrefixParselet" Tok+
//
// Examples:
//
//   //!Parselet (TPlus ADD) (TMinus ADD) (TStar MULTIPLY) (TSlash MULTIPLY)
//   static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left)
//
//   //!PrefixParselet TPlus TMinus TExcalm
//   static Node* PPrefixOp(Parser* p, PFlag fl)
//
// The parselet dispatch map for all tokens is generated by a script (parse_gen.py)
// which builds the "parselets" table (see end of file.)

// panic() on parse errors
#define DEBUG_PANIC_ON_PARSE_ERROR
//
// enable debug messages for pushScope() and popScope()
//#define DEBUG_SCOPE_PUSH_POP
//
// enable debug dumping of symbol bindings (scope stack)
//#define DEBUG_SCOPE_BINDINGS
//
// enable debug messages for defsym()
//#define DEBUG_DEFSYM
//
// enable debug messages for presolve_id()
//#define DEBUG_LOOKUPSYM
//

ASSUME_NONNULL_BEGIN


// Operator precedence
// Precedence    Operator
//     5             *  /  %  <<  >>  &  &^
//     4             +  -  |  ^
//     3             ==  !=  <  <=  >  >=
//     2             &&
//     1             ||
//
typedef enum Precedence {
  PREC_LOWEST,
  PREC_ASSIGN,
  PREC_COMMA,
  PREC_LOGICAL_OR,
  PREC_LOGICAL_AND,
  PREC_BITWISE_OR,
  PREC_BITWISE_XOR,
  PREC_BITWISE_AND,
  PREC_EQUAL,
  PREC_COMPARE,
  PREC_SHIFT,
  PREC_ADD,
  PREC_MULTIPLY,
  PREC_UNARY_PREFIX,
  PREC_UNARY_POSTFIX,
  PREC_MEMBER,
} Precedence;


typedef enum PFlag {
  PFlagNone   = 0,
  PFlagRValue = 1 << 0, // parsing an rvalue
  PFlagType   = 1 << 1, // parsing a type
  PFlagMut    = 1 << 2, // "mut" outer
} PFlag;


typedef struct Parselet Parselet;

typedef Node* (ParseletPrefixFun)(Parser* p, PFlag fl);
typedef Node* nullable (ParseletFun) (Parser* p, const Parselet* e, PFlag fl, Node* left);
  // if an infix parselet returns null, "left" becomes the result

typedef struct Parselet {
  ParseletPrefixFun* fprefix;
  ParseletFun*       f;
  Precedence         prec;
} Parselet;

typedef struct UnresolvedNode {
  Source* src;
  Node*   n;
} UnresolvedNode;

typedef struct Unresolved {
  Sym            sym;
  u32            nodeslen;
  u32            nodescap;
  UnresolvedNode nodes[];
} Unresolved;


#define nexttok(p) ScannerNext((Scanner*)(p))
#define currpos(p) ScannerPos((Scanner*)(p))


inline static Scanner pscan_state_save(const Parser* p) {
  return *(Scanner*)(p);
}

inline static void pscan_state_restore(Parser* p, Scanner state) {
  *(Scanner*)(p) = state;
}

// const char* type_name(Type* t)
#define type_name(n) _Generic((n), \
  Type*:   _type_name(n), \
  default: _type_name(as_Type(n)))
static const char* _type_name(Type* nullable t) {
  if (t)
    return TypeKindName(TF_Kind(t->tflags));
  return "<unknown type>";
}

// const char* node_type_name(Node* n)
// returns the name of n->type
#define node_type_name(n) _node_type_name(as_Node(n))
static const char* _node_type_name(Node* n) {
  if (!n)
    return _type_name(NULL);
  return type_name(TypeOfNode(n));
}


// syntaxerrp reports a source-token related syntax error.
// It will point to the source location of the last-scanned token.
// If n is not NULL, use source location of n instead of current location.
//
static Pos syntaxerrp(Parser* p, Pos pos, const char* format, ...) {
  Mem mem = p->build->mem;
  bool autopos = pos == NoPos;
  if (autopos)
    pos = currpos(p);

  va_list ap;
  va_start(ap, format);
  Str msg = str_make(mem, 64);
  if (strlen(format) > 0)
    msg = str_appendfmtv(msg, format, ap);
  va_end(ap);

  const char* tokname;
  if (p->tok == TNone) {
    tokname = "end of input";
  } else if (p->tok == TSemi && p->tokstart == p->linestart - 1) {
    // Implicit semicolon from linebreak
    tokname = "line break";
    // To improve the error message, find the pos of the linebreak
    if (autopos) {
      const u8* prevlinestart = p->prevtokend - 1;
      while (prevlinestart > p->src->body) {
        if (*prevlinestart == '\n')
          break;
        prevlinestart--;
      }
      u32 col = (u32)(uintptr)(p->prevtokend - prevlinestart);
      pos = pos_make(p->srcposorigin, p->lineno - 1, col, /*span*/0);
    }
  } else {
    tokname = TokName(p->tok);
  }

  Str stmp = NULL;
  if (msg->len == 0) {
    stmp = msg;
    msg = str_make_fmt(mem, "unexpected %s", tokname);
  } else if (str_hasprefix(msg, "expecting ")) {
    stmp = msg;
    const char* sep = (tokname[0] == ';' || tokname[0] == ',') ? " " : ", ";
    msg = str_make_fmt(mem, "unexpected %s%s%s", tokname, sep, msg->p);
  } else if (
    str_hasprefix(msg, "after ") ||
    str_hasprefix(msg, "in ") ||
    str_hasprefix(msg, "at ")
  ) {
    stmp = msg;
    msg = str_make_fmt(mem, "unexpected %s %s", tokname, msg->p);
  }
  if (stmp)
    str_free(stmp);

  b_diag(p->build, DiagError, (PosSpan){pos, NoPos}, msg->p);

  #ifdef DEBUG_PANIC_ON_PARSE_ERROR
  panic("DEBUG_PANIC_ON_PARSE_ERROR %s", msg->p);
  #endif

  str_free(msg);
  return pos;
}


// syntaxerr = syntaxerrp(p, <srcpos of current token>, ...)
#define syntaxerr(p, format, ...) \
  syntaxerrp((p), NoPos, format, ##__VA_ARGS__)


// toklistHas returns true if t is in list (list is expected to be 0-terminated)
static bool toklistHas(const Tok* list, Tok t) {
  Tok t2;
  while ((t2 = *list++)) {
    if (t2 == t)
      return true;
  }
  return false;
}


// advance consumes tokens until it finds a token of the stoplist.
// It is used to recover from parse errors and is not speed critical.
//
static void advance(Parser* p, const Tok* nullable stoplist) {
  nexttok(p); // guarantee progress
  if (stoplist == NULL || *stoplist == 0)
    return;

  if (p->fnest > 0) {
    // Stop at keywords that start a statement.
    // They are good synchronization points in case of syntax
    // errors and (usually) shouldn't be skipped over.
    while (!toklistHas(stoplist, p->tok)) {
      switch (p->tok) {
        case TNone:
        case TBreak:
        case TContinue:
        case TDefer:
        case TFor:
        case TIf:
        case TAuto:
        case TReturn:
        case TSwitch:
        case TType:
          return;
        default:
          break;
      }
      nexttok(p);
    }
  } else {
    while (p->tok != TNone && !toklistHas(stoplist, p->tok))
      nexttok(p);
  }
  // slurp a trailing semicolon
  if (p->tok == TSemi)
    nexttok(p);
}

// mknode allocates a new ast node
// T* nullable mknode(Parser*, NODE_TYPE)
#define mknode(p, NODE_TYPE) ((NODE_TYPE##Node* nullable)mknode1((p), N##NODE_TYPE))

// mktype allocates a new ast Type node
// T* nullable mktype(Parser*, NODE_TYPE, TypeFlags tflags)
#define mktype(p, NODE_TYPE, TYPE_FLAGS) ({                         \
  assert(NodeKindIsType(N##NODE_TYPE));                             \
  auto t = ((NODE_TYPE##Node* nullable)mknode1((p), N##NODE_TYPE)); \
  if (t) t->tflags = (TYPE_FLAGS);                                  \
  t; })

inline static Node* nullable mknode1(Parser* p, NodeKind kind) {
  Node* n = b_mknodex(p->build, kind);
  if (LIKELY(n != NULL))
    n->pos = currpos(p);
  return n;
}


// Node* set_endpos(Parser* p, Node* n)
#define set_endpos(p, n) ({ n->endpos = currpos(p); n; })

// precedence should match the calling parselet's own precedence
static Node* parse_next(Parser* p, int precedence, PFlag fl);
static Node* parse_prefix(Parser* p, PFlag fl);
static Node* parse_infix(Parser* p, int precedence, PFlag fl, Node* left);

// parse_next_tuple = Tuple | Node
static Node* parse_next_tuple(Parser* p, int precedence, PFlag fl);

static const char* var_kind_name(VarNode* n) {
  if (NodeIsParam(n))
    return "function parameter";

  // if (n->var.init && NodeIsType(n->var.init))
  //   return "type definition";

  return "variable";
}


static void scopestackGrow(Parser* p) {
  p->scopestack.cap *= 2;
  Mem mem = p->build->mem;
  if (p->scopestack.ptr == p->scopestack.storage) {
    p->scopestack.ptr = memalloc(mem, sizeof(void*) * p->scopestack.cap);
    memcpy(p->scopestack.ptr, p->scopestack.storage, sizeof(void*) * p->scopestack.len);
  } else {
    p->scopestack.ptr = memrealloc(mem, p->scopestack.ptr, sizeof(void*) * p->scopestack.cap);
  }
}

#ifdef DEBUG_SCOPE_BINDINGS
  static void scopestackDebugDump(Parser* p) {
    dlog("scope bindings:");
    FILE* fp = stderr;
    // stack is arranged like this: | It can also look like this: (empty current scope)
    // [10] key4                    | [10] -- base=6 --
    // [9]  value4                  | [6]  -- base=0 --
    // [8]  key3                    | [5]  key2
    // [7]  value3                  | [4]  value2
    // [6]  -- base=0 --            | [3]  key1
    // [5]  key2                    | [2]  value1
    // [4]  value2                  |
    // [3]  key1                    |
    // [2]  value1                  |
    uintptr i = p->scopestack.len;
    uintptr base = p->scopestack.base;
    while (i > 1) {
      i--;
      if (i == base) {
        usize prevbase = (usize)base;
        base = (uintptr)p->scopestack.ptr[i];
        fprintf(fp, "  --------- (base %zu -> %zu)\n", prevbase, (usize)base);
      } else {
        Sym key = (Sym)p->scopestack.ptr[i];
        i--;
        Node* n = (Node*)p->scopestack.ptr[i];
        fprintf(fp, "  %s => %s %s\n", key, nodename(n), fmtnode(n));
      }
    }
  }
#endif /* DEBUG_SCOPE_BINDINGS */


static void scopestackCheckUnused(Parser* p) {
  // only run when p->build->debug==true
  assert(p->scopestack.len > 0);
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (--i > base) {
    Sym key = (Sym)p->scopestack.ptr[i];
    i--;
    Node* n = (Node*)p->scopestack.ptr[i];
    //dlog(">>  %s => %s %s", key, nodename(n), fmtnode(n));
    if (UNLIKELY(key != kSym__ && n->kind == NVar && as_VarNode(n)->nrefs == 0)) {
      // TODO: combine the error message with that of package-level reporter
      PosSpan ps = { n->pos, n->endpos };
      VarNode* var = as_VarNode(n);
      b_warnf(p->build, ps, "unused %s %s", var_kind_name(var), var->name);
    }
  }
}


// pushScope adds a new scope to the stack. Returns the new scope.
static void pushScope(Parser* p) {
  // add "scope starts here" to scopestack
  if (UNLIKELY(p->scopestack.cap - p->scopestack.len == 0))
    scopestackGrow(p);

  #ifdef DEBUG_SCOPE_PUSH_POP
    dlog("push scope; base %zu -> %zu",
      (usize)p->scopestack.base, (usize)p->scopestack.len);
  #endif

  p->scopestack.ptr[p->scopestack.len++] = (void*)p->scopestack.base;
  p->scopestack.base = p->scopestack.len - 1;
}


// popScope removes the topmost scope
static void popScope(Parser* p) {
  #ifdef DEBUG_SCOPE_PUSH_POP
  {
    usize nbindings = (usize)(p->scopestack.len - p->scopestack.base) / 2;
    dlog("pop scope; base %zu -> %zu (%zu bindings)",
      (usize)p->scopestack.base,
      (usize)(uintptr)p->scopestack.ptr[p->scopestack.base],
      nbindings);
  }
  #endif

  #ifdef DEBUG_SCOPE_BINDINGS
    scopestackDebugDump(p);
  #endif

  // rewind and restore base of parent scope
  p->scopestack.len = p->scopestack.base;
  p->scopestack.base = (uintptr)p->scopestack.ptr[p->scopestack.len];
}


inline static void popScopeAndCheckUnused(Parser* p) {
  // check for unused variables and parameters
  if (p->build->debug && p->scopestack.len - p->scopestack.base > 1)
    scopestackCheckUnused(p);
  popScope(p);
}


inline static void scopestackPush(Parser* p, Sym key, Node* value) {
  assert(p->scopestack.cap - p->scopestack.len > 1);
  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)value;
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)key;
  p->scopestack.len += 2;
}

// lookupsymPkg looks up node for key in the package scope.
static Node* nullable lookupsymPkg(Parser* p, Sym key) {
  // look in the package's scope (including universe)
  #ifdef DEBUG_LOOKUPSYM
    dlog("lookup %s fallback to pkgscope", key);
  #endif
  Node* n = (Node*)ScopeLookup(p->pkgscope, key);
  if (n) {
    if (NodeIsUnused(n)) // must check to avoid editing universe
      NodeClearUnused(n);
    if (p->scopestack.cap - p->scopestack.len > 1) {
      // Put it on the scopestack if there's space, as this will likely be
      // requested soon again.
      // For example, in this case "int" will lookupsym many times:
      //   fun foo(x, y int) int {
      //     tmp = 3 as int
      //     tmp + x + y
      //   }
      // However, with this optimization lookup of "int" only takes the slow path once
      // (for the first "int" in function params) and is then found in the local
      // scopestack for all remaining lookups of "int".
      scopestackPush(p, key, n);
    }
  }
  return n;
}

// lookupsym looks up node for key in the current scope, searching all parent scopes.
// This function is inline because it's only used in one place.
inline static Node* nullable lookupsym(Parser* p, Sym key) {
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      base = (uintptr)p->scopestack.ptr[i];
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  // not found in the current file's scope; look in the package's scope (including universe)
  return lookupsymPkg(p, key);
}

static Node* nullable lookupsymShallow(Parser* p, Sym key) {
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      break;
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  return NULL;
}

#define defsym(p, s, n) _defsym((p), (s), as_Node(assertnotnull(n)))

static void _defsym(Parser* p, Sym s, Node* n) {
  assert(is_Type(n) || is_VarNode(n) || is_FieldNode(n) || is_FunNode(n));

  #ifdef DEBUG_DEFSYM
  Node* existing = lookupsymShallow(p, s);
  if (existing) {
    dlog("defsym %s => %s (replacing %s)", s, nodename(n), nodename(existing));
  } else {
    dlog("defsym %s => %s", s, nodename(n));
  }
  #endif

  if (UNLIKELY(p->scopestack.cap - p->scopestack.len < 2))
    scopestackGrow(p);

  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)n; // value
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)s; // key
  p->scopestack.len += 2;

  if (p->scopestack.base == 0) {
    // top level definition -- add to pkgscope.
    // TODO: For imports, make sure to add to file scope instead of package scope
    //       Lazily create: p->file->array.scope=ScopeNew(p->pkgscope, p->build->mem);
    p->err = ScopeAssoc(p->pkgscope, s, &n);
  }
}


// If the current token is t, advances scanner and returns true.
inline static bool got(Parser* p, Tok t) {
  if (p->tok != t)
    return false;
  nexttok(p);
  return true;
}

// want reports a syntax error if p->tok != t.
// In any case, this function will advance the scanner by one token.
inline static void want(Parser* p, Tok t) {
  if (UNLIKELY(!got(p, t))) {
    syntaxerr(p, "expecting %s", TokName(t));
    nexttok(p);
  }
}

static Node* bad(Parser* p) {
  return (Node*)mknode(p, Bad);
}


static bool name_is_pub(Sym name) {
  assert(symlen(name) > 0);
  return name[0] != '_';
}


// presolve_id resolves an identifier, returning the effective node which may be
// either id or a simplification, like kExpr_true instead of (Id "true" -> kExpr_true)
static Node* presolve_id(Parser* p, IdNode* id) {
  assertnull(id->target);
  assertnotnull(id->name);

  Node* target = lookupsym(p, id->name);

  #ifdef DEBUG_LOOKUPSYM
    if (target) {
      dlog("lookup \"%s\" => %s %s", id->name, nodename(target), fmtnode(target));
    } else {
      dlog("lookup \"%s\" => (not found; unresolved)", id->name);
    }
  #endif

  return resolve_id(id, target);
}


// presolve_type resolves a named type
static Type* presolve_type(Parser* p, NamedTypeNode* namedtype) {
  assertnotnull(namedtype->name);
  Node* target = lookupsym(p, namedtype->name);

  #ifdef DEBUG_LOOKUPSYM
    if (target) {
      dlog("lookup type \"%s\" => %s %s", id->name, nodename(target), fmtnode(target));
    } else {
      dlog("lookup type \"%s\" => (not found; unresolved)", id->name);
    }
  #endif

  if (!target) {
    NodeSetUnresolved(namedtype);
    return as_Type(namedtype);
  }

  return as_Type(target);
}


// use_as_rvalue is used to lazily resolve identifiers which are used in rvalue position
// that is unknown ahead of time. Returns expr or its effective value.
// For example:
//   fun foo(x, y int) int {
//     x
//     ~ might be the beginning of a var definition
// Scenario 1:
//   fun foo(x, y int) int {
//     x = 4
//     ~~~~~ lvalue in a var definition; defining not resolving.
// Scenario 2:
//   fun foo(x, y int) int {
//     x + y
//     ~~~~~  Used as an rvalue in an op; call use_as_rvalue(x)
//
#define use_as_rvalue(p, n) _use_as_rvalue((p),as_Node(n))
static Node* use_id_as_rvalue(Parser* p, IdNode* id) {
  NodeSetRValue(id);
  return resolve_id(id, id->target ? NULL : lookupsym(p, id->name));
}
static Node* _use_as_rvalue(Parser* p, Node* n) {
  switch (n->kind) {
    case NId:        return use_id_as_rvalue(p, as_IdNode(n));
    case NBasicType: return n; // immutable memory, allocated by universe
    default:
      NodeSetRValue(n);
      return n;
  }
}


static Type* nullable set_ctxtype(Parser* p, Type* nullable ctxtype) {
  Type* prev = p->ctxtype;
  p->ctxtype = ctxtype != kType_ideal ? ctxtype : NULL;
  return prev;
}

static Type* expectType(Parser* p, Node* nullable n) {
  if (LIKELY(n == NULL || is_Type(n)))
    return (Type*)n;
  #ifdef DEBUG
    syntaxerrp(p, n->pos, "expected a type; got %s (N%s)", fmtnode(n), nodename(n));
  #else
    syntaxerrp(p, n->pos, "expected a type; got %s", fmtnode(n));
  #endif
  return (Type*)(n ? n : bad(p));
}

static Expr* expectExpr(Parser* p, Node* nullable n) {
  if (LIKELY(n == NULL || is_Expr(n)))
    return (Expr*)n;
  syntaxerrp(p, n->pos, "expected an expression");
  return (Expr*)(n ? n : bad(p));
}


// ============================================================================================
// ============================================================================================
// Parselets (upper case PName = pratt parselet, lower case pName = helper parselet)


// Type or Id (always rvalue)
inline static Type* pType(Parser* p, PFlag fl) {
  Node* n = parse_next(p, PREC_MEMBER, fl | PFlagType | PFlagRValue);
  return expectType(p, n);
}

// Expr
static Expr* pExpr(Parser* p, int precedence, PFlag fl) {
  Node* n = parse_next(p, precedence, fl);
  return expectExpr(p, n);
}

static IdNode* pId(Parser* p) {
  asserteq(p->tok, TId);
  auto n = mknode(p, Id);
  n->name = p->name;
  nexttok(p);
  return n;
}

static NamedTypeNode* pTypename(Parser* p) {
  auto n = pId(p);
  n->kind = NNamedType;
  return (NamedTypeNode*)n;
}


//!PrefixParselet TNil
static Node* PNil(Parser* p, PFlag fl) {
  nexttok(p);
  return as_Node(kExpr_nil);
}

//!PrefixParselet TAuto
static Node* PAuto(Parser* p, PFlag fl) {
  nexttok(p);
  return as_Node(kType_auto);
}

// PId -- identifier (as prefix)
// When parsing an rvalue identifier, PFlagRValue is set in fl
//
//!PrefixParselet TId
static Node* PId(Parser* p, PFlag fl) {
  auto id = pId(p);
  if (fl & PFlagType) {
    auto name = id->name;
    auto tname = (NamedTypeNode*)id;
    tname->kind = NNamedType;
    tname->name = name;
    if ((fl & PFlagRValue) || p->tok == TSemi) {
      NodeSetRValue(tname);
      return as_Node(presolve_type(p, tname));
    }
    return as_Node(tname);
  }
  if ((fl & PFlagRValue) || p->tok == TSemi) {
    NodeSetRValue(id);
    return presolve_id(p, id);
  }
  return as_Node(id);
}


static void set_var_init(Parser* p, VarNode* n, Expr* init) {
  init = expectExpr(p, use_as_rvalue(p, init));
  NodeTransferUnresolved(n, init);
  n->init = init;

  if (!n->type) {
    // infer var type from initializer
    if (init->type != kType_ideal)
      n->type = init->type;
    return;
  }

  if (!init->type || init->type == kType_ideal) {
    n->flags |= NF_PartialType;
    return;
  }

  if (n->type != init->type)
    n->flags |= NF_PartialType;

  if (is_RefTypeNode(n->type)) {
    // check refs
    if (UNLIKELY( !is_RefTypeNode(init->type) )) {
      // e.g. "x &Foo = a"  (fix: "x &Foo = &a")
      syntaxerrp(p, init->pos, "cannot initialize reference with value");
      b_notef(p->build, NodePosSpan(n->init),
        "try referencing the value: &%s", fmtnode(n->init));
    }
    return;
  }

  if (UNLIKELY(init->type->kind == NRefType)) {
    syntaxerrp(p, init->pos, "cannot initialize value with reference");
  }
}


static VarNode* make_var(Parser* p, IdNode* name, Expr* nullable init, Type* nullable t) {
  asserteq(name->kind, NId);
  VarNode* n = mknode(p, Var);
  NodeSetConst(n);
  NodeSetUnused(n);
  NodeSetPublic(n, (p->fnest == 0 && name_is_pub(name->name)));
  n->pos = name->pos; // TODO: expand pos span to include type?
  n->name = name->name;
  n->type = t;

  if (init)
    set_var_init(p, n, init);

  Node* existing = lookupsymShallow(p, n->name);
  if (existing) {
    b_warnf(p->build, NodePosSpan(name),
      "%s definition shadows %s",
      var_kind_name(n),
      is_VarNode(existing) ? var_kind_name((VarNode*)existing) : nodename(existing) );
    b_notef(p->build, NodePosSpan(existing), "previous definition");
  }

  defsym(p, name->name, n);
  return n;
}


static RefTypeNode* pRefType(Parser* p, PFlag fl) {
  auto n = mktype(p, RefType, TF_KindPointer);
  nexttok(p); // consume "&"
  // TODO: parse optional trailing "mut" kw?
  NodeSetConstCond(n, (fl & PFlagMut) == 0);
  n->elem = pType(p, fl | PFlagRValue);
  // n->flags = n->elem->flags & NF_Const;
  n->pos = pos_union(n->pos, n->elem->pos);
  NodeTransferUnresolved(n, n->elem);
  return n;
}


// MutType = "mut" Type
//!PrefixParselet TMut
static Node* PMut(Parser* p, PFlag fl) {
  Pos mut_pos = currpos(p);
  nexttok(p); // consume "mut"

  // expect "&"
  if (p->tok != TAnd) {
    syntaxerr(p, "expecting &");
    return bad(p);
  }
  auto t = pRefType(p, fl | PFlagMut);
  t->pos = pos_union(mut_pos, t->pos);
  return as_Node(t);
}


// VarDef      = ConstVarDef | MutVarDecl
// ConstVarDef = "const" Id Type? "=" Expr
// MutVarDef   = "var" Id (Type | Type? "=" Expr)
//
// e.g. "var x int", "var x = 4", "var x int = 4"
// e.g. "const x int", "const x = 4", "const x int = 4"
//
//!PrefixParselet TVar TConst
static Node* PVarOrConst(Parser* p, PFlag fl) {
  bool isconst = p->tok == TConst;
  // Pos kwpos = currpos(p);
  nexttok(p); // consume "var" or "const"

  // name
  if (UNLIKELY(p->tok != TId)) {
    syntaxerr(p, "expecting name");
    return bad(p);
  }
  IdNode* name = pId(p);

  // optional type
  Type* typ = NULL;
  if (p->tok != TAssign) {
    if (UNLIKELY(p->tok == TSemi)) {
      // improved error message (we'd get a generic one from pType)
      Pos epos = syntaxerr(p, "expecting type or assignment of value");
      // help message (fixup)
      if (isconst) {
        // const x
        b_notef(p->build, (PosSpan){epos,epos},
          "Fix by assigning a value \"%s = VALUE\"", name->name);
      } else {
        // var x
        b_notef(p->build, (PosSpan){epos,epos},
          "Fix by adding a type \"%s TYPE\" or assigning a value \"%s = VALUE\"",
          name->name, name->name);
      }
    } else {
      typ = pType(p, fl);
      NodeSetConstCond(typ, isconst);
    }
  }

  // optional init
  Expr* init = NULL;
  if (got(p, TAssign)) {
    // e.g. "var name = x"
    Type* ctxtype = set_ctxtype(p, typ);
    init = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  } else if (isconst) {
    syntaxerr(p, "expecting assignment of value");
  }

  VarNode* var = make_var(p, name, init, typ);
  var->isconst = isconst;
  return as_Node(var);
}


// e.g. "a = x"
// returns VarNode or AssignNode
static Node* pAssignToId(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  IdNode* dst = as_IdNode(dstn);
  Node* target = dst->target;
  if (!target) {
    target = presolve_id(p, dst);
    if (target == as_Node(dst))
      target = dst->target;
  }

  if (!target || !is_VarNode(target)) {
    // var definition, e.g. "x = 3" -> (var (Id x) (Int 3))
    nexttok(p); // consume '='
    Type* ctxtype = set_ctxtype(p, NULL);
    Expr* init = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
    return as_Node(make_var(p, dst, init, NULL)); // copies dst->name and dst->pos
  }

  // assignment
  VarNode* targetvar = (VarNode*)target;
  if (UNLIKELY(targetvar->isconst)) {
    // syntaxerr(p, "assignment to constant %s", targetvar->name);
    b_errf(p->build, NodePosSpan(dst),
      "cannot assign to constant %s", targetvar->name);
    b_notef(p->build, NodePosSpan(targetvar),
      "constant %s defined here", targetvar->name);
    b_notef(p->build, NodePosSpan(dst),
      "to define a new shadowing variable, use explicit mutability keyword"
      " mut or const. For example: mut %s = ...",
      targetvar->name);
  }
  // assign to existing var and make sure the target is marked as variable
  NodeClearConst(targetvar);
  NodeRefVar(targetvar);
  auto n = mknode(p, Assign);
  nexttok(p); // consume '='
  Expr* right = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
  n->dst = as_Expr(targetvar); // store target instead of NId to simplify IR generation
  n->val = right;
  NodeTransferUnresolved(n, right);
  if (dst->type && dst->type == right->type) {
    NodeTransferPartialType2(n, dst, right);
    n->type = dst->type;
  }
  return as_Node(n);
}


// PIdTrailing parses a trailing identifier, e.g. "b" in "a b"
//
//!Parselet (TId ASSIGN)
static Node* PIdTrailing(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  NamedTypeNode* tname = pTypename(p);

  if (UNLIKELY(( fl & PFlagRValue) || !is_IdNode(left) )) {
    // fl & PFlagRValue  Occurs as an expression, e.g. "b" in "x = a b"
    // !is_IdNode(left)  Identifier following some expression e.g. "b" in "3 b"
    syntaxerrp(p, tname->pos, "unexpected identifier %s", tname->name);
    return as_Node(tname);
  }

  IdNode* id1 = as_IdNode(left);
  Type* typ = presolve_type(p, tname);
  Expr* init = NULL;

  if (got(p, TAssign)) {
    // "a b = expr"
    Type* ctxtype = set_ctxtype(p, typ);
    init = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  }

  return as_Node(make_var(p, id1, init, typ));
}


// assignment to fields, e.g. "x.y = 3" -> (assign (Selector (Id x) (Id y)) (Int 3))
static Node* pAssignToSelector(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  // auto dst = as_SelectorNode(dstn);
  panic("TODO pAssignToSelector");
  return bad(p);
}


// parse assignment of any right-hand-side expression
static Node* pAssignToBase(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  auto dst = as_Expr(dstn);
  auto n = mknode(p, Assign);
  nexttok(p); // consume '='
  Node* right = parse_next_tuple(p, e->prec, fl | PFlagRValue);
  n->dst = dst;
  n->val = as_Expr(right);

  NodeTransferUnresolved2(n, n->dst, n->val);

  if (n->dst->type && n->dst->type == n->val->type) {
    NodeTransferPartialType2(n, n->dst, n->val);
    n->type = n->dst->type;
  }

  return as_Node(n);
}


// e.g. "a, b = x, y"
static Node* pAssignToTuple(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  assert(fl & PFlagRValue);
  AssignNode* n = as_AssignNode(pAssignToBase(p, e, fl, dstn));
  TupleNode* dst = as_TupleNode(dstn);

  TupleNode* val = maybe_TupleNode(n->val);
  if (!val) {
    syntaxerrp(p, dst->pos, "assignment mismatch: %u targets but 1 value", dst->a.len);
    return as_Node(n);
  }

  ExprArray* lnodes = &dst->a;
  ExprArray* rnodes = &val->a;

  if (lnodes->len != rnodes->len) {
    syntaxerrp(p, dst->pos, "assignment mismatch: %u targets but %u values",
      lnodes->len, rnodes->len);
    return as_Node(n);
  }

  for (u32 i = 0; i < lnodes->len; i++) {
    IdNode* dst = as_IdNode(lnodes->v[i]); // TODO: non-Id dst, e.g. "foo.bar = 3"
    Expr* init = rnodes->v[i];

    Expr* target = expectExpr(p, presolve_id(p, dst));
    if (target) {
      NodeClearConst(target);
      if (is_VarNode(target))
        NodeRefVar(as_VarNode(target));
      NodeTransferUnresolved(n, init);
      lnodes->v[i] = target;
    } else {
      lnodes->v[i] = as_Expr(make_var(p, dst, init, NULL));
      rnodes->v[i] = NULL; // indicate that lnodes->v[i]->init is to be used
    }
  }

  return as_Node(n);
}


// Infix assignment e.g. "=" in "left = expr"
//!Parselet (TAssign ASSIGN)
static Node* nullable PAssign(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  fl |= PFlagRValue;
  switch (left->kind) {
    case NId:       MUSTTAIL return pAssignToId(p, e, fl, left);
    case NTuple:    MUSTTAIL return pAssignToTuple(p, e, fl, left);
    case NSelector: MUSTTAIL return pAssignToSelector(p, e, fl, left);
    case NIndex:    MUSTTAIL return pAssignToBase(p, e, fl, left);
    default:
      b_errf(p->build, NodePosSpan(left), "cannot assign to %s", fmtnode(left));
      Tok stoplist[] = { TSemi, 0 };
      advance(p, stoplist);
      return NULL;
  }
}


// Group = "(" Expr ("," Expr)* ")"
// Groups are used to control precedence.
//!PrefixParselet TLParen
static Node* PGroup(Parser* p, PFlag fl) {
  nexttok(p); // consume "("
  Node* n = parse_next_tuple(p, PREC_LOWEST, fl);
  want(p, TRParen);
  return n;
}


// ArrayType = "[" Type size? "]"
// size      = Expr?
static Node* pArrayType(Parser* p, PFlag fl) {
  fl |= PFlagType;
  auto n = mktype(p, ArrayType, TF_KindArray);
  nexttok(p); // consume "["

  // Type
  n->elem = pType(p, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->elem);

  // size?
  if (p->tok != TRBrack) {
    n->sizeexpr = pExpr(p, PREC_LOWEST, (fl & ~PFlagType) | PFlagRValue);
    IntLitNode* zn = NodeEvalUint(p->build, n->sizeexpr);
    if (zn) {
      if (UNLIKELY(zn->ival > 0xFFFFFFFF))
        syntaxerrp(p, n->sizeexpr->pos, "array size too large");
      n->size = (u32)zn->ival;
    } else {
      // likely referencing a global constant yet to be parsed.
      // the type resolver will resolve its size when sizeexpr is known.
      NodeTransferUnresolved(n, n->sizeexpr);
      n->flags |= NF_PartialType;
    }
  }

  n->endpos = currpos(p);
  want(p, TRBrack);
  // return InternASTType(p->build, n);
  return as_Node(n);
}


// ArrayLit = "[" [ Expr (sep Expr)* sep? ] "]"
// sep      = "," | ";"
static Node* pArrayLit(Parser* p, PFlag fl) {
  fl |= PFlagRValue;
  auto n = mknode(p, Array);
  nexttok(p); // consume "["

  // is there an array type context?
  Type* ctxtype = set_ctxtype(p, NULL); // save & set
  bool set_type = false;
  if (ctxtype && is_ArrayTypeNode(ctxtype)) {
    set_ctxtype(p, as_ArrayTypeNode(ctxtype)->elem);
    set_type = true;
  }

  // parse elements
  while (p->tok != TRBrack) {
    Expr* v = as_Expr(parse_next(p, PREC_LOWEST, fl));
    ExprArrayPush(&n->a, v, p->build->mem);
    if (set_type && (!v->type || !b_typeeq(p->build, p->ctxtype, v->type)))
      set_type = false;
    switch (p->tok) {
      case TComma:
      case TSemi:
        nexttok(p); // consume "," or ";"
        break; // continue reading more
      case TRBrack:
        break;
      default:
        syntaxerr(p, "expecting , ; or ]");
        Tok stoplist[] = { TRBrack, 0 };
        advance(p, stoplist);
        want(p, TRBrack);
        return as_Node(n);
    }
  }
  n->endpos = currpos(p);
  want(p, TRBrack);
  if (set_type) {
    // all elements are typed and of equal type (common case, e.g. "[1,2,3]")
    auto t = mktype(p, ArrayType, TF_KindArray);
    t->elem = p->ctxtype;
    t->size = n->a.len;
    n->type = as_Type(t);
  }
  p->ctxtype = ctxtype; // restore
  return as_Node(n);
}


//!PrefixParselet TLBrack
static Node* PLBrackPrefix(Parser* p, PFlag fl) {
  // array type "[T]"
  if (fl & PFlagType)
    return pArrayType(p, fl);
  // array literal "[1, 2, 3]"
  return pArrayLit(p, fl);
}


// Index | Slice
// Index = expr "[" expr "]"
// Slice = expr "[" expr? ":" expr? "]"
//
//!Parselet (TLBrack MEMBER)
static Node* PLBrackInfix(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  assert((fl & PFlagType) == 0); // indexing is not valid in type context
  auto n = mknode(p, Index);

  // warn if there's space in between "left" and "[" (e.g. "x [i]")
  if (UNLIKELY(p->prevtokend < p->tokstart)) {
    PosSpan pos = {0};
    u32 nspace = p->tokstart - p->prevtokend;
    pos.start = pos_with_adjusted_start(n->pos, -(i32)nspace);
    pos.start = pos_with_width(pos.start, nspace);
    b_warnf(p->build, pos, "misleading whitespace in subscript expression");
  }

  nexttok(p); // consume "["

  if (!is_Expr(left)) {
    syntaxerr(p, "can not index %s (%s)", fmtnode(left), node_type_name(left));
    Tok stoplist[] = { TRBrack, 0 };
    advance(p, stoplist);
    want(p, TRBrack);
    return as_Node(n);
  }

  n->index = 0xffffffff; // not a compile-time constant (for now)
  n->operand = as_Expr(use_as_rvalue(p, left));
  NodeTransferUnresolved(n, n->operand);

  if (p->tok == TRBrack) { // "[]"
    syntaxerr(p, "missing index");
    nexttok(p); // consume unexpected "]"
    return as_Node(n);
  }

  if (p->tok != TColon) {
    n->indexexpr = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
    NodeTransferUnresolved(n, n->indexexpr);
  }

  if (p->tok == TColon) {
    // "[:" -- slice
    nexttok(p); // consume ":"
    // convert IndexNode to SliceNode
    Expr* operand = n->operand;
    Expr* start = n->indexexpr;
    SliceNode* slice = (SliceNode*)n;
    slice->kind = NSlice;
    slice->operand = operand;
    slice->start = start;
    if (p->tok != TRBrack) {
      slice->end = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
      NodeTransferUnresolved(slice, slice->end);
    } else {
      slice->end = NULL; // since we converted n->kind
    }
  }

  want(p, TRBrack);
  return as_Node(n);
}


// Ref | RefType
// Ref     = "&" Expr
// RefType = "&" Type
//!PrefixParselet TAnd
static Node* PRefPrefix(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return as_Node(pRefType(p, fl));

  auto ref = mknode(p, Ref);
  nexttok(p); // consume "&"

  // reference target
  Expr* target = ref->target = pExpr(p, PREC_LOWEST, PFlagRValue);
  NodeTransferUnresolved(ref, target);

  // if the target is an id, use the id's target
  if (is_IdNode(target) && ((IdNode*)target)->target)
    target = expectExpr(p, ((IdNode*)target)->target);

  // mutability
  if (
    // e.g. "somefun(&y)"
    p->ctxtype ? ((fl & PFlagMut) == 0) :
    // e.g. "x = &y"
    !NodeIsUnresolved(target) && (
      // if the target is a "const name T = ..." then the ref is const too: "&T"
      // but for vars we leave the ref mutable.
      is_VarNode(target) ? ((VarNode*)target)->isconst :
      NodeIsConst(target)
    )
    // else: target is a global (or undefined)
  ) {
    NodeSetConst(ref);
  } else if (is_VarNode(target) && !((VarNode*)target)->isconst) {
    // since we're making a mutable ref, treat it as a var store,
    // making sure the target var is upgraded to "mut".
    NodeClearConst(target);
  }

  // element type of our reference (e.g. "int" in "x = 1; typeof(&x) // &int")
  Type* elemtype = target->type;
  if (elemtype == NULL || elemtype == kType_ideal) {
    // target is not yet typed; type will be resolved and checked post parsing
    return as_Node(ref);
  }

  // TODO: consider moving the rest of this function into the type resolver and
  // use it both here and there, as we need to perform the same logic in both places.

  // check compatibility with any current context type, e.g. for var initializer
  if (p->ctxtype) {
    if (UNLIKELY(
      !is_RefTypeNode(p->ctxtype) ||
      !b_typeeq(p->build, ((RefTypeNode*)p->ctxtype)->elem, elemtype)) )
    {
      // not a ref type or a ref type of incompatible element type
      syntaxerrp(p, ref->pos,
        "cannot use expression of type %s&%s; expected type %s",
        NodeIsConst(ref) ? "" : "mut", fmtnode(elemtype), fmtnode(p->ctxtype) );
      return as_Node(ref);
    }
    // context type matches; can we use it?
    if (NodeIsConst(((RefTypeNode*)p->ctxtype)->elem) == NodeIsConst(elemtype)) {
      // Note: this saves us from the mknode call later on but apart from that
      // yields an equivalent type and return value.
      ref->type = p->ctxtype;
      return as_Node(ref);
    }
  } else if (UNLIKELY( is_RefTypeNode(elemtype) )) {
    // Target is a reference itself -- can't reference a reference!
    // Note: in C, the equivalent would be to take the address of a pointer, which in Co is
    // not a thing (even if it was, it would lead to too much confusion w/ eg "T&&" types.)
    syntaxerrp(p, ref->pos, "cannot reference a reference (type %s)", fmtnode(elemtype));
    return as_Node(ref);
  }

  // create ref type using the target type as our element type
  RefTypeNode* t = mknode(p, RefType);
  t->elem = elemtype;
  NodeTransferUnresolved(t, elemtype);
  NodeTransferConst(t, ref);
  ref->type = as_Type(t);

  return as_Node(ref);
}


// As = lhs "as" Type
// "as" has the lowest precedence and thus... Examples:
//
//   "9 * 2 as int8"         => (TypeCast int8 (Op * (Int 9) (Int 2)))
//   "9 * (2 as int8)"       => (Op * (Int 9) (TypeCast int8 (Int 2)))
//   "9, 2 as (int8,int8)"   => (Int 9) (TypeCast (Tuple int8 int8) (Int 2))
//   "(9, 2) as (int8,int8)" => (TypeCast (Tuple int8 int8) (Tuple (Int 9) (Int 2)))
//
//!Parselet (TAs LOWEST)
static Node* PAs(Parser* p, const Parselet* e, PFlag fl, Node* lhs) {
  auto n = mknode(p, TypeCast);
  nexttok(p); // consume "as"
  n->expr = expectExpr(p, lhs);
  n->type = pType(p, fl);
  if (NodeIsUnresolved(n->expr))
    n->type->tflags |= NF_PartialType;
  return as_Node(n);
}


// args = arg (sep arg)* sep?
// arg  = Id "=" Expr | Expr
// sep  = "," | ";"
static TupleNode* pArgs(Parser* p, PFlag fl) {
  fl |= PFlagRValue;
  auto tuple = mknode(p, Tuple);
  u32 index = 0;
  Expr* arg;

parse_arg:
  if (p->tok == TId) {
    // identifier
    auto id = pId(p);
    NodeSetRValue(id);

    if (got(p, TAssign)) {
      // named argument (e.g. "name = expr")

      // convert Id to NamedArg
      Sym name = id->name; // tmp
      NamedArgNode* namedarg = (NamedArgNode*)id;
      namedarg->kind = NNamedArg;
      namedarg->name = name;
      namedarg->value = pExpr(p, PREC_LOWEST, fl);
      tuple->flags |= NF_Named; // "has named argument"

      arg = as_Expr(namedarg);
    } else {
      // plain identifier
      // resolve id (and simplify since rvalue, so may get non-id result)
      Node* left = presolve_id(p, id);
      // continue parsing with parse_infix
      arg = expectExpr(p, parse_infix(p, PREC_LOWEST, fl, left));
      if (tuple->flags & NF_Named)
        goto err_pos_after_named;
    }
  } else {
    arg = pExpr(p, PREC_LOWEST, fl);
    if (tuple->flags & NF_Named)
      goto err_pos_after_named;
  }

  ExprArrayPush(&tuple->a, arg, p->build->mem);

  switch (p->tok) {
    case TComma:
    case TSemi:
      if (nexttok(p) == TRParen) // consume "," or ";"
        break; // trailing "," or ";"
      // continue reading more
      index++;
      goto parse_arg;
    case TRParen: // ")" ends argument list
      break;
    default:
      syntaxerr(p, "expecting , ; or )");
      Tok stoplist[] = { TRParen, 0 };
      advance(p, stoplist);
      want(p, TRParen);
      break;
  }

  return set_endpos(p, tuple);

err_pos_after_named:
  // e.g. "(a, b=3, c)" -- positional arg c follows named arg b
  syntaxerrp(p, arg->pos, "positional argument following named argument");
  return set_endpos(p, tuple);
}


//!Parselet (TLParen MEMBER)
static Node* PCall(Parser* p, const Parselet* e, PFlag fl, Node* receiver) {
  auto call = mknode(p, Call);
  nexttok(p); // consume "("

  // receiver
  receiver = use_as_rvalue(p, receiver);
  NodeTransferUnresolved(call, receiver);
  call->receiver = receiver;

  if (got(p, TRParen)) // ")" -- end without arguments
    return as_Node(call);

  // args
  Type* ctxtype = p->ctxtype; // save
  if (is_BasicTypeNode(receiver)) {
    // fast path for primitive types e.g. "i16(123)".
    set_ctxtype(p, (Type*)receiver);
    // convert Call to TypeCast
    auto tcast = (TypeCastNode*)call;
    tcast->kind = NTypeCast;
    tcast->type = (Type*)receiver;
    tcast->expr = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
    if (tcast->type == tcast->expr->type) {
      // short circuit e.g. "x = i64(3)"
      // TODO: expand pos & endpos to include "type(3)"
      call = (CallNode*)as_Node(tcast->expr);
    }
  } else {
    auto args = pArgs(p, fl);
    if (args->a.len > 0) {
      call->args = args;
      NodeTransferUnresolved(call, args);
    }
  }

  p->ctxtype = ctxtype; // restore ctxtype
  want(p, TRParen);
  return as_Node(call);
}


// Field = ( Id Type | NamedType ) ( "=" Expr )?
static FieldNode* pField(Parser* p) {
  asserteq(p->tok, TId);
  auto field = mknode(p, Field);
  field->name = p->name;
  nexttok(p); // consume name

  if (UNLIKELY(p->tok == TSemi)) {
    // e.g. just "type" (name is implicit)
    auto typename = mknode(p, NamedType);
    typename->name = field->name;
    field->type = presolve_type(p, typename);
    field->flags |= NF_Base;
  } else {
    // e.g. "name type"
    // custom error for "field = value"
    if (UNLIKELY(p->tok == TAssign)) {
      syntaxerr(p, "expecting type");
      field->type = kType_nil;
    } else {
      field->type = pType(p, PFlagNone);
    }
  }

  if (UNLIKELY(field->name == kSym__))
    syntaxerrp(p, field->pos, "invalid field name; all fields must be named");

  // check for duplicate names
  Node* existing = lookupsymShallow(p, field->name);
  if (existing) {
    syntaxerrp(p, field->pos, "Duplicate field name \"%s\"", field->name);
    b_notef(p->build, NodePosSpan(existing), "Also defined here");
  }

  defsym(p, field->name, field);

  if (got(p, TAssign)) {
    // e.g. "field = initval"
    Type* ctxtype = set_ctxtype(p, field->type);
    field->init = pExpr(p, PREC_LOWEST, PFlagRValue);
    p->ctxtype = ctxtype; // restore ctxtype
    NodeTransferUnresolved(field, field->init);
    field->flags |= NF_CustomInit; // TODO: only set if field->init is not zero/default
    field->flags |= NF_PartialType;
  }

  NodeTransferCustomInit(field, field->type);
  NodeTransferUnresolved(field, field->type);

  return field;
}


static bool end_block(Parser* p) {
  if (UNLIKELY(p->tok != TRBrace)) {
    syntaxerr(p, "expecting ; or }");
    return false;
  }
  // following is a dance to look ahead for tokens which when following
  // a block does not warrant an implicit semicolon. E.g. "if { } else ..."
  auto scanstate = pscan_state_save(p);
  nexttok(p); // consume '}' and read next token
  if (p->tok != TElse && p->tok != TSemi) {
    pscan_state_restore(p, scanstate);
    p->tok = TSemi; // produce semicolon instead of '}'
  }
  return true;
}


// StructType = {" fields? "}"
// fields     = Field ( ";" Field )* ";"?
static Node* pStructType(Parser* p, PFlag fl, StructTypeNode* stype) {
  asserteq(p->tok, TLBrace);
  nexttok(p); // consume "{"

  stype->name = p->typename;
  p->typename = NULL;

  pushScope(p);

  while (p->tok != TNone && p->tok != TRBrace) {
    if (UNLIKELY(p->tok != TId)) {
      syntaxerr(p, "expecting field or type name");
      break;
    }
    if (UNLIKELY(stype->fields.len == 0xFFFFFFFF)) {
      // overflow protection
      syntaxerr(p, "too many stuct fields");
      Tok stoplist[] = { TRBrace, 0 };
      advance(p, stoplist);
      break;
    }

    auto field = pField(p);
    NodeTransferUnresolved(stype, field);
    NodeTransferCustomInit(stype, field);
    FieldArrayPush(&stype->fields, field, p->build->mem);

    if (!got(p, TSemi))
      break;
  }

  end_block(p);

  popScope(p);
  // note: we only allow refs to previously defined fields to enforce no cycles.
  // Thus we don't save the scope here.
  return as_Node(stype);
}


// StructTypeDef = "struct" StructType
//!PrefixParselet TStruct
static Node* PStructType(Parser* p, PFlag fl) {
  auto stype = mktype(p, StructType, TF_KindStruct);
  nexttok(p); // consume "struct"

  // TODO: when infix, assign stype->name

  // name
  if (p->tok == TId) {
    p->typename = p->name;
    // make sure to define the struct before parsing its body
    defsym(p, p->name, stype);
    nexttok(p); // consume name
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // body
  if (UNLIKELY(p->tok != TLBrace)) {
    syntaxerr(p, "expecting { ... }");
    return as_Node(stype);
  }

  return pStructType(p, fl, stype);
}


// TypeDef = "type" Id Type
//
//!PrefixParselet TType
static Node* PTypeDef(Parser* p, PFlag fl) {
  auto alias = mknode(p, AliasType);
  nexttok(p); // consume "type"
  NodeSetConst(alias);
  NodeSetUnused(alias);

  if (UNLIKELY( p->tok != TId )) {
    syntaxerr(p, "expecting name");
    return as_Node(alias);
  }

  alias->name = p->name;
  // make sure to define the type before parsing a potential struct body
  defsym(p, p->name, alias);
  alias->pos = pos_union(alias->pos, currpos(p)); // include name
  nexttok(p); // consume name

  NodeSetPublic(alias, (p->fnest == 0 && name_is_pub(alias->name)));

  p->typename = alias->name;
  alias->type = pType(p, PFlagNone);
  NodeTransferUnresolved(alias, alias->type);

  // struct with custom initializers must be visited by the type resolver,
  // so be conservative with propagating the type here.
  if ((alias->type->flags & NF_CustomInit) == 0)
    alias->type = kType_type;

  return as_Node(alias);
}


// Block = "{" Expr* "}"
// NOTE: it's the callers responsibility to call pushScope & popScope
static Expr* pBlock(Parser* p, PFlag fl) {
  auto block = mknode(p, Block);
  nexttok(p); // consume "{"

  Node* cn = NULL;
  while (p->tok != TNone && p->tok != TRBrace) {
    cn = parse_next_tuple(p, PREC_LOWEST, fl & ~PFlagRValue);
    NodeArrayPush(&block->a, cn, p->build->mem);
    NodeTransferUnresolved(block, cn);
    if (!got(p, TSemi))
      break;
  }

  // Note: if end_block(p) fails, a syntax error is logged
  if (end_block(p) && cn) {
    // if last expression is a local, increment its refcount
    if (is_VarNode(cn))
      NodeRefVar(as_VarNode(cn));

    // last expression is used as rvalue
    block->a.v[block->a.len - 1] = use_as_rvalue(p, cn);
  }

  set_endpos(p, block);

  // simplify a block with a single expression to just that expression
  if (block->a.len == 1 && is_Expr(block->a.v[0]))
    return as_Expr(block->a.v[0]);

  return as_Expr(block);
}


// BlockOrStructType = Block | StructType
// Block = "{" Expr* "}"
//!PrefixParselet TLBrace
static Node* PBlockOrStructType(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return pStructType(p, fl, mktype(p, StructType, TF_KindStruct));
  pushScope(p);
  Expr* expr = pBlock(p, fl);
  popScopeAndCheckUnused(p);
  return as_Node(expr);
}

// PrefixOp = ( "+" | "-" | "!" | "*" ) Expr
//!PrefixParselet TPlus TMinus TExcalm TStar
static Node* PPrefixOp(Parser* p, PFlag fl) {
  auto op = mknode(p, PrefixOp);
  op->op = p->tok;
  nexttok(p);
  op->expr = pExpr(p, PREC_MEMBER, fl | PFlagRValue);
  NodeTransferUnresolved(op, op->expr);
  return as_Node(op);
}

// InfixOp = Expr ( "+" | "-" | "*" | "/" ) Expr
//!Parselet (TPipePipe LOGICAL_OR)
//          (TAndAnd LOGICAL_AND)
//          (TPipe BITWISE_OR)
//          (THat BITWISE_XOR)
//          (TAnd BITWISE_AND)
//          (TEq EQUAL) (TNEq EQUAL)
//          (TLt COMPARE) (TGt COMPARE) (TLEq COMPARE) (TGEq COMPARE)
//          (TPlus ADD) (TMinus ADD)
//          (TStar MULTIPLY) (TSlash MULTIPLY)
static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto op = mknode(p, BinOp);
  op->op = p->tok;
  nexttok(p); // consume "+"
  op->left = expectExpr(p, use_as_rvalue(p, left));
  Type* ctxtype = set_ctxtype(p, op->left->type);
  op->right = pExpr(p, e->prec, fl | PFlagRValue);
  p->ctxtype = ctxtype; // restore ctxtype
  NodeTransferUnresolved2(op, op->left, op->right);
  return as_Node(op);
}

// PostfixOp = Expr ( "++" | "--" )
//!Parselet (TPlusPlus UNARY_POSTFIX) (TMinusMinus UNARY_POSTFIX)
static Node* PPostfixOp(Parser* p, const Parselet* e, PFlag fl, Node* operand) {
  auto op = mknode(p, PostfixOp);
  op->op = p->tok;
  nexttok(p); // consume "++"
  op->expr = expectExpr(p, use_as_rvalue(p, operand));
  NodeTransferUnresolved(op, op->expr);
  return as_Node(op);
}

// Selector = Expr "." Id
//!Parselet (TDot MEMBER)
static Node* PSelector(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto sel = mknode(p, Selector);
  nexttok(p); // consume "."
  sel->operand = expectExpr(p, use_as_rvalue(p, left));

  // member is a name
  if (UNLIKELY(p->tok != TId)) {
    syntaxerr(p, "expecting member name");
    return as_Node(sel);
  }
  sel->member = p->name;
  set_endpos(p, sel); // extend sel to include member id
  nexttok(p); // consume id

  sel->flags = sel->operand->flags;
  return as_Node(sel);
}

// IntLit = [0-9]+
//!PrefixParselet TIntLit
static Node* PIntLit(Parser* p, PFlag fl) {
  auto lit = mknode(p, IntLit);
  usize len = p->tokend - p->tokstart;
  error err = strparse_u64((const char*)p->tokstart, len, /*base*/10, &lit->ival);
  if (err) {
    lit->ival = 0;
    if (err == err_overflow) {
      syntaxerrp(p, lit->pos, "integer literal too large");
    } else {
      syntaxerrp(p, lit->pos, "invalid integer literal");
    }
  }
  nexttok(p);
  lit->type = kType_ideal;
  if (p->ctxtype)
    return as_Node(ctypecast_implicit(p->build, lit, p->ctxtype, NULL));
  return as_Node(lit);
}

// If = "if" Expr Expr
//!PrefixParselet TIf
static Node* PIf(Parser* p, PFlag fl) {
  auto ifn = mknode(p, If);
  nexttok(p);
  ifn->cond = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
  ifn->thenb = pExpr(p, PREC_LOWEST, fl | PFlagRValue);
  NodeTransferUnresolved2(ifn, ifn->cond, ifn->thenb);
  NodeSetRValueCond(ifn, (fl & PFlagRValue));
  if (p->tok == TElse) {
    nexttok(p);
    ifn->elseb = pExpr(p, PREC_LOWEST, fl);
    NodeTransferUnresolved(ifn, ifn->elseb);
  }
  return as_Node(ifn);
}

// Return = "return" Expr?
//!PrefixParselet TReturn
static Node* PReturn(Parser* p, PFlag fl) {
  auto ret = mknode(p, Return);
  if (UNLIKELY(p->fnest == 0)) {
    // return outside a function
    syntaxerrp(p, ret->pos, "return outside function body");
  }
  nexttok(p);
  if (p->tok != TSemi && p->tok != TRBrace) {
    // parse_next_tuple to allow "return 1, 2, 3" in addition to "return (1, 2, 3)"
    ret->expr = expectExpr(p, parse_next_tuple(p, PREC_LOWEST, fl | PFlagRValue));
    NodeTransferUnresolved(ret, ret->expr);
  }
  return as_Node(ret);
}


// params = "(" param (sep param)* sep? ")"
// param  = Id Type? | Type
// sep    = "," | ";"
//
static TupleNode* pParams(Parser* p) {
  // examples:
  //
  // (T)
  // (x T)
  // (x, y, z T)
  // (... T)
  // (x  ... T)
  // (x, y, z  ... T)
  // (T1, T2, T3)
  // (T1, T2, ... T3)
  //
  assert(p->tok == TLParen);
  auto params = mknode(p, Tuple);
  nexttok(p); // consume "("

  // empty params? eg "()"
  if (p->tok == TRParen || p->tok == TNone) {
    want(p, TRParen);
    return params;
  }

  bool hasTypedParam = false; // true when at least one param has type; e.g. "x T"
  PFlag fl = PFlagRValue;

  // typeq: temporary storage for VarNodes to support "typed groups" of parameters,
  // e.g. "x, y int" -- "x" does not have a type until we parsed "y" and "int", so when
  // we parse "x" we put it in typeq. Also, "x" might be just a type and not a name in
  // the case all args are just types e.g. "T1, T2, T3".
  Node* typeq_st[32];
  NodeArray typeq;
  NodeArrayInitStorage(&typeq, typeq_st, countof(typeq_st));

  while (1) {
    auto var = mknode(p, Var);
    NodeSetConst(var);
    NodeSetUnused(var);
    NodeSetParam(var);
    ExprArrayPush(&params->a, as_Expr(var), p->build->mem);

    if (p->tok == TId) {
      // name eg "x"
      var->name = p->name;
      nexttok(p);
      switch (p->tok) {
        case TRParen:
        case TComma:
        case TSemi:
          // just a lone name, eg "x" in "(x, y)"
          NodeArrayPush(&typeq, as_Node(var), p->build->mem);
          break;

        default:
          // type follows name, eg "x int"
          var->type = pType(p, fl);
          hasTypedParam = true;
          // cascade type to predecessors
          for (u32 i = 0; i < typeq.len; i++)
            ((VarNode*)typeq.v[i])->type = var->type;
          typeq.len = 0;
      }
    } else {
      // definitely just type, e.g. "fun([]int,bool)"
      var->type = pType(p, fl);
    }

    // end loop?
    switch (p->tok) {
      case TComma:
      case TSemi:
        if (nexttok(p) == TRParen) // consume "," or ";"
          goto finish; // trailing "," or ";"
        break; // continue reading more
      case TRParen:
        goto finish;
      default:
        syntaxerr(p, "expecting , ; or )");
        Tok stoplist[] = { TRParen, 0 };
        advance(p, stoplist);
        goto finish;
    }
  }

finish:
  if (hasTypedParam) {
    // name-and-type form; e.g. "(x, y T, z Y)"
    if (typeq.len > 0) {
      // at least one param has type, but the last one does not.
      // e.g. "(x, y int, z)"
      syntaxerr(p, "expecting type");
    }
    u32 index = 0;
    for (u32 i = 0; i < params->a.len; i++) {
      auto param = as_VarNode(params->a.v[i]);
      param->index = index++;
      defsym(p, param->name, param);
    }
  } else {
    // type-only form, e.g. "(T, T, Y)"
    // make ident of each cn->var.name where cn->type == NULL
    //
    // TODO: for template parameters, this case means "name only without type constraints"
    //
    u32 index = 0;
    for (u32 i = 0; i < params->a.len; i++) {
      auto param = as_VarNode(params->a.v[i]);
      if (!param->type) {
        auto tname = mknode(p, NamedType);
        tname->name = param->name;
        param->name = kSym__;
        param->index = index++;
        param->type = presolve_type(p, tname);
      }
    }
  }

  for (u32 i = 0; i < params->a.len; i++) {
    auto param = as_VarNode(params->a.v[i]);
    NodeTransferUnresolved(param, param->type);
    NodeTransferUnresolved(params, param);
  }

  NodeArrayFree(&typeq, p->build->mem);
  want(p, TRParen);
  return params;
}

// template parameters, e.g. "<T, R=T>"
static TupleNode* templateParams(Parser* p) {
  assert(p->tok == TLt);
  PFlag fl = PFlagNone; // lvalue semantics
  auto params = mknode(p, Tuple);
  nexttok(p); // consume "<"
  do {
    if (UNLIKELY(p->tok != TId)) {
      syntaxerr(p, "expecting %s", TokName(TId));
      break;
    }
    auto name = mknode(p, Id);
    name->name = p->name;
    nexttok(p); // consume id
    Expr* init = NULL;
    if (got(p, TAssign)) { // T=something
      // TODO: allow types as well as expressions
      init = expectExpr(p, parse_prefix(p, fl | PFlagRValue));
    }
    VarNode* var = make_var(p, name, init, NULL);
    var->flags |= NF_MacroParam;
    var->type = kType_nil;
    ExprArrayPush(&params->a, as_Expr(var), p->build->mem);
  } while (got(p, TComma) && p->tok != TGt);
  want(p, TGt);
  set_endpos(p, params);
  return params;
}


// Fun     = FunDef | FunExpr
// FunDef  = "fun" Id? params? Type? Block?
// FunExpr = "fun" Id? params? Type? "->" Expr
//
// e.g.
//   fun foo (x, y int) int
//   fun foo (x, y int) int { x * y }
//   fun foo { 5 }
//   fun foo -> 5
//   fun (x, y int) int { x * y }
//   fun { 5 }
//   fun -> 5
//
//!PrefixParselet TFun
static Node* PFun(Parser* p, PFlag fl) {
  auto fn = mknode(p, Fun);
  nexttok(p); // consume "fun"

  // name
  if (p->tok == TId) {
    fn->name = p->name;
    nexttok(p);
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // template parameters, e.g. "fun foo<T, R>(...)" => NMacro
  MacroNode* macro = NULL;
  if (p->tok == TLt) {
    macro = mknode(p, Macro);
    if (fn->name)
      defsym(p, fn->name, macro);
    pushScope(p);
    macro->name = fn->name;
    macro->params = templateParams(p);
    // Note: no NodeTransferUnresolved for params
  }

  if (fn->name)
    defsym(p, fn->name, fn);

  // function parameters
  pushScope(p); // body AND parameter scope
  if (p->tok == TLParen) {
    auto params = pParams(p);
    // Note: the type of fun.params should structually match the type of call.args.
    // This reduces the work needed by the type resolver.
    if (params->a.len > 0) {
      fn->params = params;
      NodeTransferUnresolved(fn, params);
    }
  }

  // result type(s)
  if (p->tok != TLBrace && p->tok != TSemi) {
    if (p->tok == TRArr) {
      // e.g. "fun foo() -> 123" => "fun foo() auto { 123 }"
      fn->result = kType_auto;
    } else {
      fn->result = pType(p, fl);
      NodeTransferUnresolved(fn, fn->result);
    }
  } else {
    // no result type specified is the same as "nil" (does not return a value)
    fn->result = kType_nil;
  }

  // set endpos
  // FIXME: this sets endpos to the next following token, not the last token.
  // Example:
  // 1  fun add(x int, y uint) int
  // 2
  // Gets an endpos of 2:0 (which is invalid since column is zero so formatters will ignore it)
  // It should get endpos 1:24 (for "int")
  set_endpos(p, fn);

  // body
  p->fnest++;
  PFlag bodyfl = (fn->result == kType_nil) ? (fl & ~PFlagRValue) : (fl | PFlagRValue);
  if (p->tok == TLBrace) {
    // assign body before parsing so that we can check for it in pBlock
    assert((fl & PFlagType) == 0); // needed for PBlockOrStructType
    fn->body = pBlock(p, bodyfl);
  } else if (got(p, TRArr)) {
    fn->body = expectExpr(p, parse_next_tuple(p, PREC_LOWEST, bodyfl));
  }
  p->fnest--;

  if (fn->body) {
    NodeTransferUnresolved(fn, fn->body);
    popScopeAndCheckUnused(p); // function parameter scope
  } else {
    popScope(p);
  }

  if (!macro)
    return as_Node(fn);

  popScopeAndCheckUnused(p); // template parameter scope
  macro->template = as_Node(fn);
  return as_Node(macro);
}


// end of parselets
// ============================================================================================
// ============================================================================================


//PARSELET_MAP_BEGIN
// automatically generated by misc/gen_parselet_map.py; do not edit
static const Parselet parselets[Tok_MAX] = {
  [TNil] = {PNil, NULL, PREC_MEMBER},
  [TAuto] = {PAuto, NULL, PREC_MEMBER},
  [TId] = {PId, PIdTrailing, PREC_ASSIGN},
  [TMut] = {PMut, NULL, PREC_MEMBER},
  [TVar] = {PVarOrConst, NULL, PREC_MEMBER},
  [TConst] = {PVarOrConst, NULL, PREC_MEMBER},
  [TLParen] = {PGroup, PCall, PREC_MEMBER},
  [TLBrack] = {PLBrackPrefix, PLBrackInfix, PREC_MEMBER},
  [TAnd] = {PRefPrefix, PInfixOp, PREC_BITWISE_AND},
  [TStruct] = {PStructType, NULL, PREC_MEMBER},
  [TType] = {PTypeDef, NULL, PREC_MEMBER},
  [TLBrace] = {PBlockOrStructType, NULL, PREC_MEMBER},
  [TPlus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TMinus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TExcalm] = {PPrefixOp, NULL, PREC_MEMBER},
  [TStar] = {PPrefixOp, PInfixOp, PREC_MULTIPLY},
  [TIntLit] = {PIntLit, NULL, PREC_MEMBER},
  [TIf] = {PIf, NULL, PREC_MEMBER},
  [TReturn] = {PReturn, NULL, PREC_MEMBER},
  [TFun] = {PFun, NULL, PREC_MEMBER},
  [TAssign] = {NULL, PAssign, PREC_ASSIGN},
  [TAs] = {NULL, PAs, PREC_LOWEST},
  [TPipePipe] = {NULL, PInfixOp, PREC_LOGICAL_OR},
  [TAndAnd] = {NULL, PInfixOp, PREC_LOGICAL_AND},
  [TPipe] = {NULL, PInfixOp, PREC_BITWISE_OR},
  [THat] = {NULL, PInfixOp, PREC_BITWISE_XOR},
  [TEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TNEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TLt] = {NULL, PInfixOp, PREC_COMPARE},
  [TGt] = {NULL, PInfixOp, PREC_COMPARE},
  [TLEq] = {NULL, PInfixOp, PREC_COMPARE},
  [TGEq] = {NULL, PInfixOp, PREC_COMPARE},
  [TSlash] = {NULL, PInfixOp, PREC_MULTIPLY},
  [TPlusPlus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TMinusMinus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TDot] = {NULL, PSelector, PREC_MEMBER},
};
//PARSELET_MAP_END


static Node* parse_prefix(Parser* p, PFlag fl) {
  // find prefix parselet
  assert(p->tok < Tok_MAX);
  const Parselet* parselet = &parselets[p->tok];
  if (!parselet->fprefix) {
    // dlog("parse_prefix NOT found for %s", TokName(p->tok));
    syntaxerr(p, "expecting expression");
    Node* n = bad(p);
    Tok stoplist[] = { TRParen, TRBrace, TRBrack, TSemi, 0 };
    advance(p, stoplist);
    return n;
  }
  // dlog("parse_prefix FOUND for %s", TokName(p->tok));
  return p->expr = parselet->fprefix(p, fl);
}


static Node* parse_infix(Parser* p, int precedence, PFlag fl, Node* left) {
  // wrap parselets
  // TODO: Should we set fl|PFlagRValue here?
  while (p->tok != TNone) {
    const Parselet* parselet = &parselets[p->tok];
    assertnotnull(parselet);
    // if (parselet->f) {
    //   dlog("infix parselet FOUND for %s; parselet->prec=%d < precedence=%d = %s",
    //     TokName(p->tok), parselet->prec, precedence,
    //     (int)parselet->prec < precedence ? "Y" : "N");
    // } else {
    //   dlog("infix parselet NOT found for %s", TokName(p->tok));
    // }
    if (!parselet->f || (int)parselet->prec < precedence) {
      break;
    }
    p->expr = parselet->f(p, parselet, fl, left);
    if (p->expr == NULL)
      return left;
    assert(left != p->expr); // or else: infinite loop
    left = p->expr;
  }
  return left;
}


static Node* parse_next(Parser* p, int precedence, PFlag fl) {
  // Note: precedence should match the calling parselet's own precedence
  Node* left = parse_prefix(p, fl);
  return parse_infix(p, precedence, fl, left);
}


// parse_next_tuple = Expr | Tuple
//
// This function has different behavior depending on PFlagRValue:
//
//   PFlagRValue=OFF consumes a parse_prefix, then a possible tuple and finally calls
//   parse_infix to include the tuple in an infix expression like t + y.
//
//   - PFlagRValue=OFF is "conservative" used for lvalues, e.g. (a b c) in a,b,c=1,2,3
//   - PFlagRValue=ON is "greedy" and used for rvalues, e.g. (x (y + z)) in _,_=x,y+z
//
//   Consider the following source code:
//     a, b + c, d
//   Parsing this with the different functions yields:
//   - PFlagRValue=OFF => (+ (a b) c)
//   - PFlagRValue=ON => (a (+ b c) d)
//
//   Explanation of PFlagRValue=OFF:
//   • PFlagRValue=OFF calls parse_prefix => a
//   • PFlagRValue=OFF sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=OFF calls parse_prefix => b
//   • PFlagRValue=OFF end tuple => (a b)
//   • parse_infix with tuple as the LHS:
//     • parse_infix calls '+' parselet
//       • '+' parselet reads RHS by calling expr:
//         • expr calls parse_prefix (which in turn calls 'ident' parselet) => c
//         • expr returns the c identifier (NId)
//       • '+' parselet produces LHS + RHS => (+ (a b) c)
//     • return
//   • return
//
//   Explanation of PFlagRValue=ON:
//   • PFlagRValue=ON calls expr => a
//   • PFlagRValue=ON sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=ON calls expr
//     • expr calls parse_prefix => b
//     • expr calls parse_infix with b as LHS:
//       • parse_infix calls '+' parselet
//         • '+' parselet reads RHS by calling expr:
//           • expr calls parse_prefix => c
//           • expr returns the c identifier (NId)
//         • '+' parselet produces LHS + RHS => (+ b c)
//       • return
//     • return
//   • PFlagRValue=ON calls expr after another comma
//     • calls parse_prefix => b
//   • PFlagRValue=ON see no more comma; ends the tuple => (a (+ b c) d)
//
static Node* parse_next_tuple(Parser* p, int precedence, PFlag fl) {
  Node* left = (fl & PFlagRValue) ? parse_next(p, precedence, fl)
                                  : parse_prefix(p, fl);
  if (got(p, TComma)) {
    // start a tuple
    Node* g;
    NodeArray* array;
    if (fl & PFlagType) {
      auto tuple = mktype(p, TupleType, TF_KindArray);
      array = as_NodeArray(&tuple->a);
      g = as_Node(tuple);
    } else {
      auto tuple = mknode(p, Tuple);
      array = as_NodeArray(&tuple->a);
      g = as_Node(tuple);
    }

    NodeArrayPush(array, left, p->build->mem);
    NodeTransferUnresolved(g, left);
    if (fl & PFlagRValue) {
      do {
        Node* cn = parse_next(p, precedence, fl);
        NodeArrayPush(array, cn, p->build->mem);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    } else {
      do {
        Node* cn = parse_prefix(p, fl);
        NodeArrayPush(array, cn, p->build->mem);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    }
    set_endpos(p, g);
    left = g;
  }

  if (fl & PFlagRValue)
    return left;

  // wrap in possible infix expression, e.g. "left + right"
  return parse_infix(p, precedence, fl, left);
}


#if rstrstrstsrt
static Node* exprOrTuple(Parser* p, int precedence, PFlag fl) {
  auto left = (
    fl & PFlagRValue ? expr(p, precedence, fl) :
                       prefixExpr(p, fl) ); // read a prefix expression, like an identifier

  if (got(p, TComma)) {
    // start a tuple
    auto g = mknode(p, fl & PFlagType ? NTupleType : NTuple);
    NodeArray* array = fl & PFlagType ? &g->t.tuple.a : &g->array.a;
    NodeArrayAppend(p->build->mem, array, left);
    NodeTransferUnresolved(g, left);
    if (fl & PFlagRValue) {
      do {
        Node* cn = expr(p, precedence, fl);
        NodeArrayAppend(p->build->mem, array, cn);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    } else {
      do {
        Node* cn = prefixExpr(p, fl);
        NodeArrayAppend(p->build->mem, array, cn);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    }
    set_endpos(p, g);
    left = g;
  }

  if (fl & PFlagRValue)
    return left;

  // wrap in possible infix expression, e.g. "left + right"
  return infixExpr(p, precedence, fl, left);
}
#endif


error parse_tu(
  Parser* p, BuildCtx* b, Source* src, ParseFlags fl, Scope* pkgscope, FileNode** result)
{
  // clear result now so that we don't have to in error branches
  *result = NULL;

  // initialize scanner state
  if ((p->err = ScannerInit((Scanner*)p, b, src, fl)))
    return p->err;

  // initialize parser state
  p->build = b;
  p->pkgscope = pkgscope;
  p->expr = NULL;
  p->fnest = 0;

  // initialize or reset scopestack
  if (p->scopestack.ptr == NULL) {
    p->scopestack.cap = countof(p->scopestack.storage);
    p->scopestack.ptr = p->scopestack.storage;
  } else {
    p->scopestack.len = 0;
    p->scopestack.base = 0;
  }

  // load first token
  nexttok(p);

  // create FileNode to hold what we parse
  auto file = mknode(p, File);
  if (!file)
    return err_nomem;
  file->name = src->filename->p;

  // do while have a valid token...
  while (p->tok != TNone && p->err == 0) {
    Node* n = parse_next_tuple(p, PREC_LOWEST, PFlagNone);
    NodeArrayPush(&file->a, n, p->build->mem);
    NodeTransferUnresolved(file, n);

    // if we didn't end on EOF and we didn'd find a semicolon, report error
    if (UNLIKELY( p->tok != TNone && !got(p, TSemi) )) {
      syntaxerr(p, "after top level declaration");
      if (n && is_IdNode(n))
        b_notef(b, (PosSpan){n->pos,NoPos}, "Did you mean \"var %s\"?", as_IdNode(n)->name);
      Tok stoplist[] = { TType, TFun, TSemi, 0 };
      advance(p, stoplist);
    }
  }

  *result = file;
  return p->err;
}


ASSUME_NONNULL_END
