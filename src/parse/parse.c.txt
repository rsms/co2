// co source code parser
#include "../coimpl.h"
#include "parse.h"
#include "eval.h"

// Pratt-style recursive descent parser.
//
// Syntax productions are parsed by functions dubbed "parselets".
// They are defined with a magical comment described by the following eBNF:
//
//   infix  = <LF> "//!Parselet" ( "(" Tok Precedence ")" )+
//   prefix = <LF> "//!PrefixParselet" Tok+
//
// Examples:
//
//   //!Parselet (TPlus ADD) (TMinus ADD) (TStar MULTIPLY) (TSlash MULTIPLY)
//   static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left)
//
//   //!PrefixParselet TPlus TMinus TExcalm
//   static Node* PPrefixOp(Parser* p, PFlag fl)
//
// The parselet dispatch map for all tokens is generated by a script (parse_gen.py)
// which builds the "parselets" table (see end of file.)

// panic() on parse errors
#define DEBUG_PANIC_ON_PARSE_ERROR
//
// enable debug messages for pushScope() and popScope()
//#define DEBUG_SCOPE_PUSH_POP
//
// enable debug dumping of symbol bindings (scope stack)
//#define DEBUG_SCOPE_BINDINGS
//
// enable debug messages for defsym()
//#define DEBUG_DEFSYM
//
// enable debug messages for presolve_id()
//#define DEBUG_LOOKUPSYM
//

ASSUME_NONNULL_BEGIN


// Operator precedence
// Precedence    Operator
//     5             *  /  %  <<  >>  &  &^
//     4             +  -  |  ^
//     3             ==  !=  <  <=  >  >=
//     2             &&
//     1             ||
//
typedef enum Precedence {
  PREC_LOWEST,
  PREC_ASSIGN,
  PREC_COMMA,
  PREC_LOGICAL_OR,
  PREC_LOGICAL_AND,
  PREC_BITWISE_OR,
  PREC_BITWISE_XOR,
  PREC_BITWISE_AND,
  PREC_EQUAL,
  PREC_COMPARE,
  PREC_SHIFT,
  PREC_ADD,
  PREC_MULTIPLY,
  PREC_UNARY_PREFIX,
  PREC_UNARY_POSTFIX,
  PREC_MEMBER,
} Precedence;


typedef enum PFlag {
  PFlagNone   = 0,
  PFlagRValue = 1 << 0, // parsing an rvalue
  PFlagType   = 1 << 1, // parsing a type
  PFlagMut    = 1 << 2, // "mut" outer
} PFlag;


typedef struct Parselet Parselet;

typedef Node* (ParseletPrefixFun)(Parser* p, PFlag fl);
typedef Node* nullable (ParseletFun) (Parser* p, const Parselet* e, PFlag fl, Node* left);
  // if an infix parselet returns null, "left" becomes the result

typedef struct Parselet {
  ParseletPrefixFun* fprefix;
  ParseletFun*       f;
  Precedence         prec;
} Parselet;

typedef struct UnresolvedNode {
  Source* src;
  Node*   n;
} UnresolvedNode;

typedef struct Unresolved {
  Sym            sym;
  u32            nodeslen;
  u32            nodescap;
  UnresolvedNode nodes[];
} Unresolved;


#define nexttok(p) ScannerNext((Scanner*)(p))
#define currpos(p) ScannerPos((Scanner*)(p))


// syntaxerrp reports a source-token related syntax error.
// It will point to the source location of the last-scanned token.
// If n is not NULL, use source location of n instead of current location.
//
static Pos syntaxerrp(Parser* p, Pos pos, const char* format, ...) {
  Mem mem = p->build->mem;
  bool autopos = pos == NoPos;
  if (autopos)
    pos = currpos(p);

  va_list ap;
  va_start(ap, format);
  Str msg = str_make(mem, 64);
  if (strlen(format) > 0)
    msg = str_appendfmtv(msg, format, ap);
  va_end(ap);

  const char* tokname;
  if (p->tok == TNone) {
    tokname = "end of input";
  } else if (p->tok == TSemi && p->tokstart == p->linestart - 1) {
    // Implicit semicolon from linebreak
    tokname = "line break";
    // To improve the error message, find the pos of the linebreak
    if (autopos) {
      const u8* prevlinestart = p->prevtokend - 1;
      while (prevlinestart > p->src->body) {
        if (*prevlinestart == '\n')
          break;
        prevlinestart--;
      }
      u32 col = (u32)(uintptr)(p->prevtokend - prevlinestart);
      pos = pos_make(p->srcposorigin, p->lineno - 1, col, /*span*/0);
    }
  } else {
    tokname = TokName(p->tok);
  }

  Str stmp = NULL;
  if (msg->len == 0) {
    stmp = msg;
    msg = str_make_fmt(mem, "unexpected %s", tokname);
  } else if (str_hasprefix(msg, "expecting ")) {
    stmp = msg;
    const char* sep = (tokname[0] == ';' || tokname[0] == ',') ? " " : ", ";
    msg = str_make_fmt(mem, "unexpected %s%s%s", tokname, sep, msg->p);
  } else if (
    str_hasprefix(msg, "after ") ||
    str_hasprefix(msg, "in ") ||
    str_hasprefix(msg, "at ")
  ) {
    stmp = msg;
    msg = str_make_fmt(mem, "unexpected %s %s", tokname, msg->p);
  }
  if (stmp)
    str_free(stmp);

  buildctx_diag(p->build, DiagError, (PosSpan){pos, NoPos}, msg->p);

  #ifdef DEBUG_PANIC_ON_PARSE_ERROR
  panic("DEBUG_PANIC_ON_PARSE_ERROR %s", msg->p);
  #endif

  str_free(msg);
  return pos;
}


// syntaxerr = syntaxerrp(p, <srcpos of current token>, ...)
#define syntaxerr(p, format, ...) \
  syntaxerrp((p), NoPos, format, ##__VA_ARGS__)


// toklistHas returns true if t is in list (list is expected to be 0-terminated)
static bool toklistHas(const Tok* list, Tok t) {
  Tok t2;
  while ((t2 = *list++)) {
    if (t2 == t)
      return true;
  }
  return false;
}


// advance consumes tokens until it finds a token of the followlist.
// It is used to recover from parse errors and is not speed critical.
//
static void advance(Parser* p, const Tok* followlist) {
  nexttok(p); // guarantee progress
  if (followlist == NULL || *followlist == 0) {
    return;
  }
  if (p->fnest > 0) {
    // Stop at keywords that start a statement.
    // They are good synchronization points in case of syntax
    // errors and (usually) shouldn't be skipped over.
    while (!toklistHas(followlist, p->tok)) {
      switch (p->tok) {
        case TNone:
        case TBreak:
        case TContinue:
        case TDefer:
        case TFor:
        case TIf:
        case TAuto:
        case TReturn:
        case TSwitch:
        case TType:
          return;
        default:
          break;
      }
      // dlog("skip %s", TokName(p->tok));
      nexttok(p);
    }
  } else {
    while (p->tok != TNone && !toklistHas(followlist, p->tok)) {
      // dlog("skip %s", TokName(p->tok));
      nexttok(p);
    }
  }
  if (p->tok == TSemi) {
    nexttok(p);
  }
}

// mknode allocates a new ast node
// T* nullable mknode(Parser*, NODE_TYPE)
#define mknode(p, NODE_TYPE) ((NODE_TYPE##Node* nullable)mknode1((p), N##NODE_TYPE))

// mktype allocates a new ast Type node
// T* nullable mktype(Parser*, NODE_TYPE, TypeFlags tflags)
#define mktype(p, NODE_TYPE, TYPE_FLAGS) ({                         \
  assert(NodeKindIsType(N##NODE_TYPE));                             \
  auto t = ((NODE_TYPE##Node* nullable)mknode1((p), N##NODE_TYPE)); \
  if (t) t->tflags = (TYPE_FLAGS);                                  \
  t; })

inline static Node* nullable mknode1(Parser* p, NodeKind kind) {
  Node* n = NodeAlloc(p->build->mem);
  if (UNLIKELY(!n)) {
    p->err = err_nomem;
    return NULL;
  }
  NodeInit(n, kind);
  n->pos = currpos(p);
  return n;
}


ALWAYS_INLINE static Node* set_endpos(Parser* p, Node* n) {
  n->endpos = currpos(p);
  return n;
}

// precedence should match the calling parselet's own precedence
static Node* expr(Parser* p, int precedence, PFlag fl);
static Node* prefixExpr(Parser* p, PFlag fl);
static Node* infixExpr(Parser* p, int precedence, PFlag fl, Node* left);

// exprOrTuple = Expr | Tuple
static Node* exprOrTuple(Parser* p, int precedence, PFlag fl);

static const char* var_kind_name(VarNode* n) {
  if (NodeIsParam(n))
    return "function parameter";

  // if (n->var.init && NodeIsType(n->var.init))
  //   return "type definition";

  return "variable";
}


static void scopestackGrow(Parser* p) {
  p->scopestack.cap *= 2;
  Mem mem = p->build->mem;
  if (p->scopestack.ptr == p->scopestack.storage) {
    p->scopestack.ptr = memalloc(mem, sizeof(void*) * p->scopestack.cap);
    memcpy(p->scopestack.ptr, p->scopestack.storage, sizeof(void*) * p->scopestack.len);
  } else {
    p->scopestack.ptr = memrealloc(mem, p->scopestack.ptr, sizeof(void*) * p->scopestack.cap);
  }
}

#ifdef DEBUG_SCOPE_BINDINGS
  static void scopestackDebugDump(Parser* p) {
    dlog("scope bindings:");
    FILE* fp = stderr;
    // stack is arranged like this: | It can also look like this: (empty current scope)
    // [10] key4                    | [10] -- base=6 --
    // [9]  value4                  | [6]  -- base=0 --
    // [8]  key3                    | [5]  key2
    // [7]  value3                  | [4]  value2
    // [6]  -- base=0 --            | [3]  key1
    // [5]  key2                    | [2]  value1
    // [4]  value2                  |
    // [3]  key1                    |
    // [2]  value1                  |
    uintptr i = p->scopestack.len;
    uintptr base = p->scopestack.base;
    while (i > 1) {
      i--;
      if (i == base) {
        usize prevbase = (usize)base;
        base = (uintptr)p->scopestack.ptr[i];
        fprintf(fp, "  --------- (base %zu -> %zu)\n", prevbase, (usize)base);
      } else {
        Sym key = (Sym)p->scopestack.ptr[i];
        i--;
        Node* n = (Node*)p->scopestack.ptr[i];
        fprintf(fp, "  %s => %s %s\n", key, nodename(n), fmtnode(n));
      }
    }
  }
#endif /* DEBUG_SCOPE_BINDINGS */


static void scopestackCheckUnused(Parser* p) {
  // only run when p->build->debug==true
  assert(p->scopestack.len > 0);
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (--i > base) {
    Sym key = (Sym)p->scopestack.ptr[i];
    i--;
    Node* n = (Node*)p->scopestack.ptr[i];
    //dlog(">>  %s => %s %s", key, nodename(n), fmtnode(n));
    if (UNLIKELY(key != kSym__ && n->kind == NVar && as_VarNode(n)->nrefs == 0)) {
      // TODO: combine the error message with that of package-level reporter
      PosSpan ps = { n->pos, n->endpos };
      VarNode* var = as_VarNode(n);
      buildctx_warnf(p->build, ps, "unused %s %s", var_kind_name(var), var->name);
    }
  }
}


// pushScope adds a new scope to the stack. Returns the new scope.
static void pushScope(Parser* p) {
  // add "scope starts here" to scopestack
  if (UNLIKELY(p->scopestack.cap - p->scopestack.len == 0))
    scopestackGrow(p);

  #ifdef DEBUG_SCOPE_PUSH_POP
    dlog("push scope; base %zu -> %zu",
      (usize)p->scopestack.base, (usize)p->scopestack.len);
  #endif

  p->scopestack.ptr[p->scopestack.len++] = (void*)p->scopestack.base;
  p->scopestack.base = p->scopestack.len - 1;
}


// popScope removes the topmost scope
static void popScope(Parser* p) {
  #ifdef DEBUG_SCOPE_PUSH_POP
  {
    usize nbindings = (usize)(p->scopestack.len - p->scopestack.base) / 2;
    dlog("pop scope; base %zu -> %zu (%zu bindings)",
      (usize)p->scopestack.base,
      (usize)(uintptr)p->scopestack.ptr[p->scopestack.base],
      nbindings);
  }
  #endif

  #ifdef DEBUG_SCOPE_BINDINGS
    scopestackDebugDump(p);
  #endif

  // rewind and restore base of parent scope
  p->scopestack.len = p->scopestack.base;
  p->scopestack.base = (uintptr)p->scopestack.ptr[p->scopestack.len];
}


inline static void popScopeAndCheckUnused(Parser* p) {
  // check for unused variables and parameters
  if (p->build->debug && p->scopestack.len - p->scopestack.base > 1)
    scopestackCheckUnused(p);
  popScope(p);
}


inline static void scopestackPush(Parser* p, Sym key, Node* value) {
  assert(p->scopestack.cap - p->scopestack.len > 1);
  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)value;
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)key;
  p->scopestack.len += 2;
}

// lookupsymPkg looks up node for key in the package scope.
static Node* nullable lookupsymPkg(Parser* p, Sym key) {
  // look in the package's scope (including universe)
  #ifdef DEBUG_LOOKUPSYM
    dlog("lookup %s fallback to pkgscope", key);
  #endif
  Node* n = (Node*)ScopeLookup(p->pkgscope, key);
  if (n) {
    if (NodeIsUnused(n)) // must check to avoid editing universe
      NodeClearUnused(n);
    if (p->scopestack.cap - p->scopestack.len > 1) {
      // Put it on the scopestack if there's space, as this will likely be
      // requested soon again.
      // For example, in this case "int" will lookupsym many times:
      //   fun foo(x, y int) int {
      //     tmp = 3 as int
      //     tmp + x + y
      //   }
      // However, with this optimization lookup of "int" only takes the slow path once
      // (for the first "int" in function params) and is then found in the local
      // scopestack for all remaining lookups of "int".
      scopestackPush(p, key, n);
    }
  }
  return n;
}

// lookupsym looks up node for key in the current scope, searching all parent scopes.
// This function is inline because it's only used in one place.
inline static Node* nullable lookupsym(Parser* p, Sym key) {
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      base = (uintptr)p->scopestack.ptr[i];
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  // not found in the current file's scope; look in the package's scope (including universe)
  return lookupsymPkg(p, key);
}

static Node* nullable lookupsymShallow(Parser* p, Sym key) {
  uintptr i = p->scopestack.len;
  uintptr base = p->scopestack.base;
  while (i > 1) {
    i--;
    if (i == base) {
      break;
    } else if (p->scopestack.ptr[i--] == (void*)key) {
      Node* n = (Node*)p->scopestack.ptr[i];
      if (NodeIsUnused(n)) // must check to avoid editing universe
        NodeClearUnused(n);
      return n;
    }
  }
  return NULL;
}

#define defsym(p, s, n) _defsym((p), (s), as_Node(assertnotnull(n)))

static void _defsym(Parser* p, Sym s, Node* n) {
  assert(is_Type(n) || is_VarNode(n) || is_FieldNode(n) || is_FunNode(n));

  #ifdef DEBUG_DEFSYM
  Node* existing = lookupsymShallow(p, s);
  if (existing) {
    dlog("defsym %s => %s (replacing %s)", s, nodename(n), nodename(existing));
  } else {
    dlog("defsym %s => %s", s, nodename(n));
  }
  #endif

  if (UNLIKELY(p->scopestack.cap - p->scopestack.len < 2))
    scopestackGrow(p);

  // note that key and value are entered in "reverse" order. This simplifies lookup.
  p->scopestack.ptr[p->scopestack.len] = (void*)n; // value
  p->scopestack.ptr[p->scopestack.len + 1] = (void*)s; // key
  p->scopestack.len += 2;

  if (p->scopestack.base == 0) {
    // top level definition -- add to pkgscope.
    // TODO: For imports, make sure to add to file scope instead of package scope
    //       Lazily create: p->file->array.scope=ScopeNew(p->pkgscope, p->build->mem);
    p->err = ScopeAssoc(p->pkgscope, s, &n);
  }
}


// If the current token is t, advances scanner and returns true.
inline static bool got(Parser* p, Tok t) {
  if (p->tok != t)
    return false;
  nexttok(p);
  return true;
}

// want reports a syntax error if p->tok != t.
// In any case, this function will advance the scanner by one token.
inline static void want(Parser* p, Tok t) {
  if (UNLIKELY(!got(p, t))) {
    syntaxerr(p, "expecting %s", TokName(t));
    nexttok(p);
  }
}

static Node* bad(Parser* p) {
  return (Node*)mknode(p, Bad);
}


static bool name_is_pub(Sym name) {
  assert(symlen(name) > 0);
  return name[0] != '_';
}


// presolve_id resolves an identifier, returning the effective node which may be
// either id or a simplification, like kExpr_true instead of (Id "true" -> kExpr_true)
static Node* presolve_id(Parser* p, IdNode* id, PFlag fl) {
  assertnull(id->target);
  assertnotnull(id->name);

  Node* target = lookupsym(p, id->name);

  #ifdef DEBUG_LOOKUPSYM
    if (target) {
      dlog("lookup %s => %s %s", id->name, nodename(target), fmtnode(target));
    } else {
      dlog("lookup %s => (not found; unresolved)", id->name);
    }
  #endif

  return resolve_id(id, target);
}


// use_as_rvalue is used to lazily resolve identifiers which are used in rvalue position
// that is unknown ahead of time. Returns expr or its effective value.
// For example:
//   fun foo(x, y int) int {
//     x
//     ~ might be the beginning of a var definition
// Scenario 1:
//   fun foo(x, y int) int {
//     x = 4
//     ~~~~~ lvalue in a var definition; defining not resolving.
// Scenario 2:
//   fun foo(x, y int) int {
//     x + y
//     ~~~~~  Used as an rvalue in an op; call use_as_rvalue(x)
//
#define use_as_rvalue(p, n) _Generic((n), \
  IdNode*: _use_as_rvalue_id,              \
  default: _use_as_rvalue_any              \
)(p, (n))
static IdNode* _use_as_rvalue_id(Parser* p, IdNode* id) {
  NodeSetRValue(id);
  return resolve_id(id, id->target ? NULL : lookupsym(p, id->name));
}
static Node* _use_as_rvalue_any(Parser* p, Node* n) {
  switch (n->kind) {
    case NId:        return use_as_rvalue_id(p, as_IdNode(n));
    case NBasicType: return n; // immutable memory, allocated by universe
    default:
      NodeSetRValue(n);
      return n;
  }
}


static void assign_ctxtype(Parser* p, Type* nullable new_ctxtype) {
  if (new_ctxtype) {
    assert_is_Type(new_ctxtype);
    assert(new_ctxtype != kType_ideal);
  }
  p->ctxtype = new_ctxtype;
}


static Type* nullable set_ctxtype(Parser* p, Type* nullable new_ctxtype) {
  if (new_ctxtype)
    assert_is_Type(new_ctxtype);
  Type* old_ctxtype = p->ctxtype;
  p->ctxtype = (new_ctxtype != kType_ideal ? new_ctxtype : NULL);
  return old_ctxtype;
}


// ============================================================================================
// ============================================================================================
// Parselets (upper case PName = pratt parselet, lower case pName = helper parselet)


// Type (always rvalue)
inline static Type* pType(Parser* p, PFlag fl) {
  // return exprOrTuple(p, PREC_MEMBER, fl | PFlagType | PFlagRValue); // "a, b" => "a, b"
  return as_Type(expr(p, PREC_MEMBER, fl | PFlagType | PFlagRValue)); // "a, b" => "a"
}

inline static IdNode* pId(Parser* p) {
  asserteq(p->tok, TId);
  auto n = mknode(p, Id);
  n->name = p->name;
  nexttok(p);
  return n;
}


//!PrefixParselet TNil
static Expr* PNil(Parser* p, PFlag fl) {
  nexttok(p);
  return kExpr_nil;
}

//!PrefixParselet TAuto
static Type* PAuto(Parser* p, PFlag fl) {
  nexttok(p);
  return kType_auto;
}

// PId -- identifier (as prefix)
// When parsing an rvalue identifier, PFlagRValue is set in fl
//
//!PrefixParselet TId
static Node* PId(Parser* p, PFlag fl) {
  auto n = pId(p);
  if ((fl & PFlagRValue) || p->tok == TSemi)
    return presolve_id(p, n, fl | PFlagRValue);
  return as_Node(n);
}


static void set_var_init(Parser* p, VarNode* n, Node* init) {
  assert(is_Expr(init) || is_Type(init));
  init = use_as_rvalue(p, init);
  NodeTransferUnresolved(n, init);
  n->init = init;

  if (is_Type(init)) {
    // TODO: set n->type = kType_type ?
    return;
  }

  Expr* initexpr = as_Expr(init);
  if (n->type) {
    // type resolver must visit vars even when they have explicit type.
    if (!initexpr->type || initexpr->type == kType_ideal || n->type != initexpr->type)
      n->flags |= NF_PartialType;

    // check refs
    if (initexpr->type && initexpr->type != kType_ideal) {
      if (n->type->kind == NRefType) {
        if (UNLIKELY(initexpr->type->kind != NRefType)) {
          // e.g. "x &Foo = a"  (fix: "x &Foo = &a")
          syntaxerrp(p, initexpr->pos, "cannot initialize reference with value");
          buildctx_notef(p->build, NodePosSpan(n->init),
            "try referencing the value: &%s", fmtnode(n->init));
        }
      } else if (UNLIKELY(initexpr->type->kind == NRefType)) {
        syntaxerrp(p, initexpr->pos, "cannot initialize value with reference");
      }
    }
  } else {
    // infer var type from initializer
    if (initexpr->type != kType_ideal)
      n->type = initexpr->type;
  }
}


static VarNode* make_var(Parser* p, IdNode* name, Node* nullable init, Type* nullable t) {
  asserteq(name->kind, NId);
  VarNode* n = mknode(p, Var);
  NodeSetConst(n);
  NodeSetUnused(n);
  n->pos = name->pos; // TODO: expand pos span to include type?
  n->name = name->name;
  n->type = t;

  if (p->fnest == 0 && name_is_pub(n->name))
    NodeSetPublic(n);

  if (init)
    set_var_init(p, n, init);

  Node* existing = lookupsymShallow(p, n->name);
  if (existing) {
    buildctx_warnf(p->build, NodePosSpan(name),
      "%s definition shadows %s",
      var_kind_name(n),
      is_VarNode(existing) ? var_kind_name((VarNode*)existing) : nodename(existing) );
    buildctx_notef(p->build, NodePosSpan(existing), "previous definition");
  }

  defsym(p, name->name, n);
  return n;
}


static RefTypeNode* pRefType(Parser* p, PFlag fl) {
  auto n = mktype(p, RefType, TF_KindPointer);
  nexttok(p); // consume "&"
  // TODO: parse optional trailing "mut" kw?
  if ((fl & PFlagMut) == 0)
    NodeSetConst(n);
  n->elem = pType(p, fl | PFlagRValue);
  // n->flags = n->elem->flags & NF_Const;
  n->pos = pos_union(n->pos, n->elem->pos);
  NodeTransferUnresolved(n, n->elem);
  return n;
}


// MutType = "mut" Type
//!PrefixParselet TMut
static Node* PMut(Parser* p, PFlag fl) {
  Pos mut_pos = currpos(p);
  nexttok(p); // consume "mut"

  // expect "&"
  if (p->tok != TAnd) {
    syntaxerr(p, "expecting &");
    return bad(p);
  }
  auto t = pRefType(p, fl | PFlagMut);
  t->pos = pos_union(mut_pos, t->pos);
  return as_Node(t);
}


// VarDef      = ConstVarDef | MutVarDecl
// ConstVarDef = "const" Id Type? "=" Expr
// MutVarDef   = "var" Id (Type | Type? "=" Expr)
//
// e.g. "var x int", "var x = 4", "var x int = 4"
// e.g. "const x int", "const x = 4", "const x int = 4"
//
//!PrefixParselet TVar TConst
static Node* PVarOrConst(Parser* p, PFlag fl) {
  bool isconst = p->tok == TConst;
  // Pos kwpos = currpos(p);
  nexttok(p); // consume "var" or "const"

  // name
  if (UNLIKELY(p->tok != TId)) {
    syntaxerr(p, "expecting name");
    return bad(p);
  }
  IdNode* name = pId(p);

  // optional type
  Type* typ = NULL;
  if (p->tok != TAssign) {
    if (UNLIKELY(p->tok == TSemi)) {
      // improved error message (we'd get a generic one from pType)
      Pos epos = syntaxerr(p, "expecting type or assignment of value");
      // help message (fixup)
      if (isconst) {
        // const x
        buildctx_notef(p->build, (PosSpan){epos,epos},
          "Fix by assigning a value \"%s = VALUE\"", name->name);
      } else {
        // var x
        buildctx_notef(p->build, (PosSpan){epos,epos},
          "Fix by adding a type \"%s TYPE\" or assigning a value \"%s = VALUE\"",
          name->name, name->name);
      }
    } else {
      typ = pType(p, fl);
      if (isconst)
        NodeSetConst(typ);
    }
  }

  // optional init
  Node* init = NULL;
  if (got(p, TAssign)) {
    // e.g. "var name = x"
    Type* ctxtype = set_ctxtype(p, typ);
    init = expr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  } else if (isconst) {
    syntaxerr(p, "expecting assignment of value");
  }

  VarNode* var = make_var(p, name, init, typ);
  var->isconst = isconst;
  return as_Node(var);
}


// e.g. "a = x"
// returns VarNode or AssignNode
static Node* pAssignToId(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  IdNode* dst = as_IdNode(dstn);
  Node* target = dst->target;
  if (!target) {
    target = presolve_id(p, dst, PFlagNone);
    if (target == as_Node(dst))
      target = dst->target;
  }

  if (!target || !is_VarNode(target)) {
    // var definition, e.g. "x = 3" -> (var (Id x) (Int 3))
    nexttok(p); // consume '='
    Type* ctxtype = set_ctxtype(p, NULL);
    Node* init = expr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
    return as_Node(make_var(p, dst, init, NULL)); // copies dst->name and dst->pos
  }

  // assignment
  VarNode* targetvar = (VarNode*)target;
  if (UNLIKELY(targetvar->isconst)) {
    // syntaxerr(p, "assignment to constant %s", targetvar->name);
    buildctx_errf(p->build, NodePosSpan(dst),
      "cannot assign to constant %s", targetvar->name);
    buildctx_notef(p->build, NodePosSpan(targetvar),
      "constant %s defined here", targetvar->name);
    buildctx_notef(p->build, NodePosSpan(dst),
      "to define a new shadowing variable, use explicit mutability keyword"
      " mut or const. For example: mut %s = ...",
      targetvar->name);
  }
  // assign to existing var and make sure the target is marked as variable
  NodeClearConst(targetvar);
  NodeRefVar(targetvar);
  auto n = mknode(p, Assign);
  nexttok(p); // consume '='
  Expr* right = as_Expr(expr(p, PREC_LOWEST, fl | PFlagRValue));
  n->dst = as_Expr(targetvar); // store target instead of NId to simplify IR generation
  n->val = right;
  NodeTransferUnresolved(n, right);
  if (dst->type && dst->type == right->type) {
    NodeTransferPartialType2(n, dst, right);
    n->type = dst->type;
  }
  return as_Node(n);
}


// PIdTrailing parses a trailing identifier, e.g. "b" in "a b"
//
//!Parselet (TId ASSIGN)
static Node* PIdTrailing(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  IdNode* id2 = pId(p);

  if (UNLIKELY(( fl & PFlagRValue) || !is_IdNode(left) )) {
    // fl & PFlagRValue  Occurs as an expression, e.g. "b" in "x = a b"
    // !is_IdNode(left)  Identifier following some expression e.g. "b" in "3 b"
    syntaxerrp(p, id2->pos, "unexpected identifier %s", id2->name);
    return as_Node(id2);
  }

  IdNode* id1 = as_IdNode(left);
  Node* target2 = presolve_id(p, id2, fl | PFlagType);
  Type* typ = as_Type(target2);
  Node* init = NULL;

  if (got(p, TAssign)) {
    // "a b = expr"
    Type* ctxtype = set_ctxtype(p, typ);
    init = expr(p, PREC_LOWEST, fl | PFlagRValue);
    p->ctxtype = ctxtype;
  }
  // make_var(Parser* p, IdNode* name, Node* nullable init, Type* nullable t)

  return as_Node(make_var(p, id1, init, typ));
}


// assignment to fields, e.g. "x.y = 3" -> (assign (Selector (Id x) (Id y)) (Int 3))
static Node* pAssignToSelector(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  // auto dst = as_SelectorNode(dstn);
  panic("TODO pAssignToSelector");
  return bad(p);
}


// parse assignment of any right-hand-side expression
static Node* pAssignToBase(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  auto dst = as_Expr(dstn);
  auto n = mknode(p, Assign);
  nexttok(p); // consume '='
  Node* right = exprOrTuple(p, e->prec, fl | PFlagRValue);
  n->dst = dst;
  n->val = as_Expr(right);

  NodeTransferUnresolved2(n, n->dst, n->val);

  if (n->dst->type && n->dst->type == n->val->type) {
    NodeTransferPartialType2(n, n->dst, n->val);
    n->type = n->dst->type;
  }

  return as_Node(n);
}


// e.g. "a, b = x, y"
static Node* pAssignToTuple(Parser* p, const Parselet* e, PFlag fl, Node* dstn) {
  assert(fl & PFlagRValue);
  AssignNode* n = as_AssignNode(pAssignToBase(p, e, fl, dstn));
  TupleNode* dst = as_TupleNode(dstn);

  TupleNode* val = maybe_TupleNode(n->val);
  if (!val) {
    syntaxerrp(p, dst->pos, "assignment mismatch: %u targets but 1 value", dst->a.len);
    return as_Node(n);
  }

  NodeArray* lnodes = &dst->a;
  NodeArray* rnodes = &val->a;

  if (lnodes->len != rnodes->len) {
    syntaxerrp(p, dst->pos, "assignment mismatch: %u targets but %u values",
      lnodes->len, rnodes->len);
    return as_Node(n);
  }

  for (u32 i = 0; i < lnodes->len; i++) {
    auto dst = as_IdNode(lnodes->v[i]); // TODO: non-Id dst, e.g. "foo.bar = 3"
    auto src = rnodes->v[i];

    Node* target = presolve_id(p, dst, PFlagNone);
    if (target == as_Node(dst))
      target = assertnotnull(dst->target);

    if (target) {
      NodeClearConst(target);
      if (is_VarNode(target))
        NodeRefVar(as_VarNode(target));
      NodeTransferUnresolved(n, src);
      lnodes->v[i] = target;
    } else {
      lnodes->v[i] = as_Node(make_var(p, dst, src, NULL));
      rnodes->v[i] = NULL; // indicate that lnodes->v[i]->var.init is to be used
    }
  }

  return as_Node(n);
}


// Infix assignment e.g. "=" in "left = expr"
//!Parselet (TAssign ASSIGN)
static Node* nullable PAssign(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  fl |= PFlagRValue;
  switch (left->kind) {
    case NId:       MUSTTAIL return pAssignToId(p, e, fl, left);
    case NTuple:    MUSTTAIL return pAssignToTuple(p, e, fl, left);
    case NSelector: MUSTTAIL return pAssignToSelector(p, e, fl, left);
    case NIndex:    MUSTTAIL return pAssignToBase(p, e, fl, left);
    default:
      buildctx_errf(p->build, NodePosSpan(left), "cannot assign to %s", fmtnode(left));
      Tok followlist[] = { TSemi, 0 };
      advance(p, followlist);
      return NULL;
  }
}


// Group = "(" Expr ("," Expr)* ")"
// Groups are used to control precedence.
//!PrefixParselet TLParen
static Node* PGroup(Parser* p, PFlag fl) {
  nexttok(p); // consume "("
  Node* n = exprOrTuple(p, PREC_LOWEST, fl);
  want(p, TRParen);
  return n;
}


// ArrayType = "[" Type size? "]"
// size      = Expr?
static Node* pArrayType(Parser* p, PFlag fl) {
  fl |= PFlagType;
  auto n = mktype(p, ArrayType, TF_KindArray);
  nexttok(p); // consume "["

  // Type
  n->subtype = pType(p, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->subtype);

  // size?
  if (p->tok != TRBrack) {
    n->sizeexpr = expr(p, PREC_LOWEST, (fl & ~PFlagType) | PFlagRValue);
    IntLitNode* zn = NodeEvalUint(p->build, n->sizeexpr);
    if (zn) {
      if (UNLIKELY(zn->ival > 0xFFFFFFFF))
        syntaxerrp(p, n->sizeexpr->pos, "array size too large");
      n->size = (u32)zn->ival;
    } else {
      // likely referencing a global constant yet to be parsed.
      // the type resolver will resolve its size when sizeexpr is known.
      NodeTransferUnresolved(n, n->sizeexpr);
      n->flags |= NF_PartialType;
    }
  }

  n->endpos = currpos(p);
  want(p, TRBrack);
  // return InternASTType(p->build, n);
  return as_Node(n);
}


// ArrayLit = "[" [ Expr (sep Expr)* sep? ] "]"
// sep      = "," | ";"
static Node* pArrayLit(Parser* p, PFlag fl) {
  fl |= PFlagRValue;
  auto n = mknode(p, Array);
  nexttok(p); // consume "["

  // is there an array type context?
  Type* ctxtype = set_ctxtype(p, NULL); // save & set
  bool set_type = false;
  if (ctxtype && is_ArrayTypeNode(ctxtype)) {
    assign_ctxtype(p, as_ArrayTypeNode(ctxtype)->subtype);
    set_type = true;
  }

  // parse elements
  while (p->tok != TRBrack) {
    Expr* v = as_Expr(expr(p, PREC_LOWEST, fl));
    NodeArrayPush(&n->a, as_Node(v), p->build->mem);
    if (set_type && (!v->type || !TypeEquals(p->build, p->ctxtype, v->type)))
      set_type = false;
    switch (p->tok) {
      case TComma:
      case TSemi:
        nexttok(p); // consume "," or ";"
        break; // continue reading more
      case TRBrack:
        break;
      default:
        syntaxerr(p, "expecting , ; or ]");
        Tok followlist[] = { TRBrack, 0 };
        advance(p, followlist);
        return as_Node(n);
    }
  }
  n->endpos = currpos(p);
  want(p, TRBrack);
  if (set_type) {
    // all elements are typed and of equal type (common case, e.g. "[1,2,3]")
    auto t = mktype(p, ArrayType, TF_KindArray);
    t->subtype = p->ctxtype;
    t->size = n->a.len;
    n->type = as_Type(t);
  }
  p->ctxtype = ctxtype; // restore
  return as_Node(n);
}


//!PrefixParselet TLBrack
static Node* PLBrackPrefix(Parser* p, PFlag fl) {
  // array type "[T]"
  if (fl & PFlagType)
    return pArrayType(p, fl);
  // array literal "[1, 2, 3]"
  return pArrayLit(p, fl);
}


// Index | Slice
// Index = expr "[" expr "]"
// Slice = expr "[" expr? ":" expr? "]"
//
//!Parselet (TLBrack MEMBER)
static Node* PLBrackInfix(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  assert((fl & PFlagType) == 0); // indexing is not valid in type context
  auto n = mknode(p, Index);

  // warn if there's space in between "left" and "[", e.g. "x [i]"
  if (UNLIKELY(p->prevtokend < p->tokstart)) {
    PosSpan pos = {0};
    u32 nspace = p->tokstart - p->prevtokend;
    pos.start = pos_with_adjusted_start(n->pos, -(i32)nspace);
    pos.start = pos_with_width(pos.start, nspace);
    buildctx_warnf(p->build, pos, "misleading whitespace in subscript expression");
  }

  nexttok(p); // consume "["
  n->index = 0xffffffff; // not a compile-time constant (for now)
  n->operand = use_as_rvalue(p, left);
  NodeTransferUnresolved(n, n->operand);

  if (p->tok == TRBrack) { // "[]"
    syntaxerr(p, "missing index");
    nexttok(p); // consume unexpected "]"
    return n;
  }

  if (p->tok != TColon) {
    n->indexexpr = expr(p, PREC_LOWEST, fl | PFlagRValue);
    NodeTransferUnresolved(n, n->indexexpr);
  }

  if (p->tok == TColon) {
    // "[:" -- slice
    Node* operand = n->operand;
    Node* start = n->indexexpr;
    n->kind = NSlice;
    n->slice.operand = operand;
    n->slice.start = start;
    nexttok(p); // consume ":"
    if (p->tok != TRBrack) {
      n->slice.end = expr(p, PREC_LOWEST, fl | PFlagRValue);
      NodeTransferUnresolved(n, n->slice.end);
    } else {
      n->slice.end = NULL; // since we converted n->kind
    }
  }

  want(p, TRBrack);
  return n;
}


// Ref | RefType
// Ref     = "&" Expr
// RefType = "&" Type
//!PrefixParselet TAnd
static Node* PRefPrefix(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return as_Node(pRefType(p, fl));

  auto n = mknode(p, Ref);
  nexttok(p); // consume "&"

  // reference target
  n->ref.target = expr(p, PREC_LOWEST, PFlagRValue);
  Node* target = assertnotnull(n->ref.target);
  NodeTransferUnresolved(n, target);
  if (target->kind == NId && target->id.target)
    target = target->id.target;

  // mutability
  if (!p->ctxtype) {
    // e.g. "x = &y"
    if (!NodeIsUnresolved(n->ref.target)) {
      // target is known
      if (target->kind == NVar) {
        // if the target is a "const name T = ..." then the ref is const too: "&T"
        // but for vars we leave the ref mutable.
        if (target->var.isconst)
          NodeSetConst(n);
      } else if (NodeIsConst(target)) {
        NodeSetConst(n);
      }
    } // else: target is a global (or undefined)
  } else if ((fl & PFlagMut) == 0) {
    NodeSetConst(n);
  }

  if (!NodeIsConst(n) && target->kind == NVar && !target->var.isconst) {
    // since we're making a mutable ref, treat it as a var store,
    // making sure the target var is upgraded to "mut".
    NodeClearConst(target);
  }

  if (target->type && target->type != kType_ideal) {
    if (p->ctxtype) {
      if (UNLIKELY(
            p->ctxtype->kind != NRefType ||
            !TypeEquals(p->build, p->ctxtype->t.ref, target->type)) )
      {
        syntaxerrp(p, n->pos,
          "cannot use expression of type %s&%s; expected type %s",
          NodeIsConst(n) ? "" : "mut", fmtnode(target->type), fmtnode(p->ctxtype) );
      } else {
        n->type = p->ctxtype;
      }
    } else if (target->type->kind == NRefType) {
      syntaxerrp(p, n->pos, "cannot reference a reference (type %s)",
        fmtnode(target->type));
    } else {
      // type from target
      Type* t = NewNode(p->build->mem, NRefType);
      t->t.ref = target->type;
      NodeTransferUnresolved(t, t->t.ref);
      NodeTransferConst(t, n);
      n->type = t;
    }
  }

  return n;
}


// As = lhs "as" Type
// "as" has the lowest precedence and thus... Examples:
//
//   "9 * 2 as int8"         => (TypeCast int8 (Op * (Int 9) (Int 2)))
//   "9 * (2 as int8)"       => (Op * (Int 9) (TypeCast int8 (Int 2)))
//   "9, 2 as (int8,int8)"   => (Int 9) (TypeCast (Tuple int8 int8) (Int 2))
//   "(9, 2) as (int8,int8)" => (TypeCast (Tuple int8 int8) (Tuple (Int 9) (Int 2)))
//
//!Parselet (TAs LOWEST)
static Node* PAs(Parser* p, const Parselet* e, PFlag fl, Node* lhs) {
  auto n = mknode(p, TypeCast);
  nexttok(p); // consume "as"
  n->call.receiver = pType(p, fl);
  n->call.args = lhs;
  return n;
}


// args = arg (sep arg)* sep?
// arg  = Id "=" Expr | Expr
// sep  = "," | ";"
static Node* pArgs(Parser* p, PFlag fl) { // => NTuple
  fl |= PFlagRValue;
  auto tuple = mknode(p, Tuple);
  u32 index = 0;
  Node* arg;

  while (1) {
    if (p->tok == TId) {
      Node* id = pId(p);
      if (got(p, TAssign)) {
        // named argument
        Sym name = id->id.name; // tmp
        arg = id;
        arg->kind = NNamedVal;
        arg->namedval.name = name;
        arg->namedval.value = expr(p, PREC_LOWEST, fl);
        tuple->flags |= NF_Named; // "has named argument"
      } else {
        id = presolve_id(p, id, fl);
        arg = infixExpr(p, PREC_LOWEST, fl, id);
        if (tuple->flags & NF_Named)
          goto err_pos_after_named;
      }
    } else {
      arg = expr(p, PREC_LOWEST, fl);
      if (tuple->flags & NF_Named)
        goto err_pos_after_named;
    }

    NodeArrayPush(&tuple->array.a, arg, p->build->mem);

    switch (p->tok) {
      case TComma:
      case TSemi:
        if (nexttok(p) == TRParen) // consume "," or ";"
          goto end; // trailing "," or ";"
        break; // continue reading more
      case TRParen:
        goto end;
      default:
        syntaxerr(p, "expecting , ; or )");
        Tok followlist[] = { TRParen, 0 };
        advance(p, followlist);
        goto end;
    }

    index++;
  }

end:
  return set_endpos(p, tuple);

err_pos_after_named:
  syntaxerrp(p, arg->pos, "positional argument following named argument");
  goto end;
}


//!Parselet (TLParen MEMBER)
static Node* PCall(Parser* p, const Parselet* e, PFlag fl, Node* receiver) {
  auto n = mknode(p, Call);
  nexttok(p); // consume "("
  Type* ctxtype = p->ctxtype; // save ctxtype

  // receiver
  n->call.receiver = use_as_rvalue(p, receiver);
  NodeTransferUnresolved(n, n->call.receiver);

  // args
  n->call.args = NULL;
  if (!got(p, TRParen)) {
    if (n->call.receiver->kind == NBasicType) {
      // fast path for primitive types e.g. "i16(123)"
      n->kind = NTypeCast;
      assign_ctxtype(p, n->call.receiver);
      n->call.args = expr(p, PREC_LOWEST, fl | PFlagRValue);
      if (n->call.receiver == n->call.args->type) {
        // short circuit e.g. "x = i64(3)"
        // TODO: expand n->pos & endpos to include "type(3)"
        n = n->call.args;
      }
    } else {
      Node* args = pArgs(p, fl);
      assert(args->kind == NTuple);
      if (args->array.a.len > 0) {
        n->call.args = args;
        NodeTransferUnresolved(n, args);
      }
    }
    want(p, TRParen);
  }

  p->ctxtype = ctxtype; // restore ctxtype
  return n;
}


// Field = ( Id Type | NamedType ) ( "=" Expr )?
static Node* pField(Parser* p) {
  asserteq(p->tok, TId);
  auto n = mknode(p, Field);
  n->field.name = p->name;
  nexttok(p); // consume name

  if (UNLIKELY(p->tok == TSemi)) {
    // e.g. "type" (implicit name)
    auto typename = mknode(p, Id);
    typename->id.name = n->field.name;
    n->type = presolve_id(p, typename, PFlagType);
    n->flags |= NF_Base;
  } else {
    // e.g. "name type"
    // custom error for "field = value"
    if (UNLIKELY(p->tok == TAssign)) {
      syntaxerr(p, "expecting type");
      n->type = bad(p);
    } else {
      n->type = pType(p, PFlagNone);
    }
  }

  if (UNLIKELY(n->field.name == kSym__))
    syntaxerrp(p, n->pos, "invalid field name; all fields must be named");

  // check for duplicate names
  Node* existing = lookupsymShallow(p, n->field.name);
  if (existing) {
    syntaxerrp(p, n->pos, "Duplicate field name \"%s\"", n->field.name);
    buildctx_notef(p->build, NodePosSpan(existing), "Also defined here");
  }

  defsym(p, n->field.name, n);

  if (got(p, TAssign)) {
    // e.g. "field = initval"
    Node* ctxtype = set_ctxtype(p, n->type);
    n->field.init = expr(p, PREC_LOWEST, PFlagRValue);
    p->ctxtype = ctxtype; // restore ctxtype
    NodeTransferUnresolved(n, n->field.init);
    n->flags |= NF_CustomInit; // TODO: only set if n->field.init is not zero/default
    n->flags |= NF_PartialType;
  }

  NodeTransferCustomInit(n, n->type);
  NodeTransferUnresolved(n, n->type);

  return n;
}


static bool end_block(Parser* p) {
  if (UNLIKELY(p->tok != TRBrace)) {
    syntaxerr(p, "expecting ; or }");
    return false;
  }
  // following is a dance to look ahead for tokens which when following
  // a block does not warrant an implicit semicolon. E.g. "if { } else ..."
  Scanner scanstate = p-> // save scanner state
  nexttok(p); // consume '}' and read next token
  if (p->tok != TElse && p->tok != TSemi) {
    p->= scanstate; // restore scan state
    p->tok = TSemi; // produce semicolon instead of '}'
  }
  return true;
}


// StructType = {" fields? "}"
// fields     = Field ( ";" Field )* ";"?
static Node* pStructType(Parser* p, PFlag fl, Node* n) {
  asserteq(p->tok, TLBrace);
  nexttok(p); // consume "{"

  n->t.kind = TypeKindStruct;
  n->t.struc.name = p->typename;
  p->typename = NULL;

  pushScope(p);

  while (p->tok != TNone && p->tok != TRBrace) {
    if (UNLIKELY(p->tok != TId)) {
      syntaxerr(p, "expecting field or type name");
      break;
    }
    Node* field = pField(p);
    NodeTransferUnresolved(n, field);
    NodeTransferCustomInit(n, field);
    NodeArrayPush(&n->t.struc.a, field, p->build->mem);

    if (UNLIKELY(n->t.struc.a.len == 0xFFFFFFFF)) {
      // overflow protection
      syntaxerr(p, "too many stuct fields");
      break;
    }

    if (!got(p, TSemi))
      break;
  }

  end_block(p);

  popScope(p);
  // note: we only allow refs to previously defined fields to enforce no cycles.
  // Thus we don't save the scope here.
  return n;
}


// StructTypeDef = "struct" StructType
//!PrefixParselet TStruct
static Node* PStructType(Parser* p, PFlag fl) {
  auto n = mktype(p, StructType, TF_KindStruct);
  nexttok(p); // consume "struct"

  // TODO: when infix, assign n->t.struc.name

  // name
  if (p->tok == TId) {
    p->typename = p->name;
    defsym(p, p->name, n); // make sure to define the struct before parsing its body
    nexttok(p); // consume name
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // body
  if (R_LIKELY(p->tok == TLBrace))
    return pStructType(p, fl, n);

  syntaxerr(p, "expecting { ... }");
  return n;
}


// TypeDef = "type" Id Type
//
//!PrefixParselet TType
static Node* PTypeDef(Parser* p, PFlag fl) {
  auto n = mknode(p, Var); // TODO: introduce NTypeAlias
  nexttok(p); // consume "type"
  NodeSetConst(n);
  NodeSetUnused(n);
  n->var.isconst = true;

  // name
  if (p->tok == TId) {
    n->var.name = p->name;
    // make sure to define the type before parsing a potential struct body
    defsym(p, p->name, n);
    n->pos = pos_union(n->pos, currpos(p)); // include name
    nexttok(p); // consume name
    if (p->fnest == 0 && name_is_pub(n->var.name))
      NodeSetPublic(n);
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
  }

  p->typename = n->var.name;
  n->var.init = pType(p, PFlagNone);
  NodeTransferUnresolved(n, n->var.init);

  // struct with custom initializers must be visited by the type resolver,
  // so be conservative with propagating the type here.
  if ((n->var.init->flags & NF_CustomInit) == 0)
    n->type = NewTypeType(p->build->mem, n->var.init);

  return n;
}


// Block = "{" Expr* "}"
// NOTE: it's the callers responsibility to call pushScope & popScope
static Node* pBlock(Parser* p, PFlag fl) {
  auto n = mknode(p, Block);
  nexttok(p); // consume "{"

  Node* cn = NULL;
  while (p->tok != TNone && p->tok != TRBrace) {
    cn = exprOrTuple(p, PREC_LOWEST, fl & ~PFlagRValue);
    NodeArrayPush(&n->array.a, cn, p->build->mem);
    NodeTransferUnresolved(n, cn);
    if (!got(p, TSemi))
      break;
  }

  if (end_block(p) && cn) {
    // if last expression is a local, increment its refcount
    NodeRefAny(cn);

    n->array.a.v[n->array.a.len - 1] = use_as_rvalue(p, cn);
    // if (fl & PFlagRValue) {
    //   // block is used as an rvalue e.g. "x = { ... }"
    //   if (cn && cn->kind == NVar) {
    //     // last expression is a var binding and will be used/returned, so unwrap it.
    //     n->array.a.v[n->array.a.len - 1] = unwrapVar(cn);
    //   }
    // }
  }

  set_endpos(p, n);

  if (n->array.a.len == 1)
    return n->array.a.v[0];

  return n;
}


// BlockOrStructType = Block | StructType
// Block = "{" Expr* "}"
//!PrefixParselet TLBrace
static Node* PBlockOrStructType(Parser* p, PFlag fl) {
  if (fl & PFlagType)
    return pStructType(p, fl, mktype(p, StructType, TF_KindStruct));
  pushScope(p);
  Node* n = pBlock(p, fl);
  popScopeAndCheckUnused(p);
  return n;
}

// PrefixOp = ( "+" | "-" | "!" | "*" ) Expr
//!PrefixParselet TPlus TMinus TExcalm TStar
static Node* PPrefixOp(Parser* p, PFlag fl) {
  auto n = mknode(p, PrefixOp);
  n->op.op = p->tok;
  nexttok(p);
  n->op.left = expr(p, PREC_MEMBER, fl | PFlagRValue);
  NodeTransferUnresolved(n, n->op.left);
  return n;
}

// InfixOp = Expr ( "+" | "-" | "*" | "/" ) Expr
//!Parselet (TPipePipe LOGICAL_OR)
//          (TAndAnd LOGICAL_AND)
//          (TPipe BITWISE_OR)
//          (THat BITWISE_XOR)
//          (TAnd BITWISE_AND)
//          (TEq EQUAL) (TNEq EQUAL)
//          (TLt COMPARE) (TGt COMPARE) (TLEq COMPARE) (TGEq COMPARE)
//          (TPlus ADD) (TMinus ADD)
//          (TStar MULTIPLY) (TSlash MULTIPLY)
static Node* PInfixOp(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto n = mknode(p, BinOp);
  n->op.op = p->tok;
  nexttok(p);
  n->op.left = use_as_rvalue(p, left);
  Type* ctxtype = set_ctxtype(p, n->op.left->type);
  n->op.right = expr(p, e->prec, fl | PFlagRValue);
  p->ctxtype = ctxtype; // restore ctxtype
  nodeTransferUnresolved2(n, left, n->op.right);
  return n;
}

// PostfixOp = Expr ( "++" | "--" )
//!Parselet (TPlusPlus UNARY_POSTFIX) (TMinusMinus UNARY_POSTFIX)
static Node* PPostfixOp(Parser* p, const Parselet* e, PFlag fl, Node* operand) {
  auto n = mknode(p, PostfixOp);
  n->op.op = p->tok;
  n->op.left = use_as_rvalue(p, operand);
  nexttok(p); // consume "+"
  NodeTransferUnresolved(n, n->op.left);
  return n;
}

// Selector = Expr "." Id
//!Parselet (TDot MEMBER)
static Node* PSelector(Parser* p, const Parselet* e, PFlag fl, Node* left) {
  auto n = mknode(p, Selector);
  nexttok(p); // consume "."
  n->sel.operand = use_as_rvalue(p, left);
  TARRAY_INIT(&n->sel.indices);

  // member is a name
  if (UNLIKELY(p->tok != TId)) {
    syntaxerr(p, "expecting member name");
    return n;
  }
  n->sel.member = p->name;
  set_endpos(p, n); // extend n to include member id
  nexttok(p); // consume id

  n->flags = n->sel.operand->flags;
  return n;
}

// IntLit = [0-9]+
//!PrefixParselet TIntLit
static Node* PIntLit(Parser* p, PFlag fl) {
  auto n = mknode(p, IntLit);
  usize len = p->tokend - p->tokstart;
  if (!parseu64((const char*)p->tokstart, len, /*base*/10, &n->val.i)) {
    n->val.i = 0;
    syntaxerrp(p, n->pos, "invalid integer literal");
  }
  nexttok(p);
  n->val.ct = CType_int;
  n->type = kType_ideal;
  if (p->ctxtype)
    return convlit(p->build, n, p->ctxtype, ConvlitImplicit | ConvlitRelaxedType);
  return n;
}

// If = "if" Expr Expr
//!PrefixParselet TIf
static Node* PIf(Parser* p, PFlag fl) {
  auto n = mknode(p, If);
  nexttok(p);
  n->cond.cond = expr(p, PREC_LOWEST, fl | PFlagRValue);
  n->cond.thenb = expr(p, PREC_LOWEST, fl | PFlagRValue);
  nodeTransferUnresolved2(n, n->cond.cond, n->cond.thenb);

  if (fl & PFlagRValue)
    NodeSetRValue(n);

  if (p->tok == TElse) {
    nexttok(p);
    n->cond.elseb = expr(p, PREC_LOWEST, fl);
    NodeTransferUnresolved(n, n->cond.elseb);
  }

  return n;
}

// Return = "return" Expr?
//!PrefixParselet TReturn
static Node* PReturn(Parser* p, PFlag fl) {
  auto n = mknode(p, Return);
  if (UNLIKELY(p->fnest == 0)) {
    // return outside a function
    syntaxerrp(p, n->pos, "return outside function body");
  }
  nexttok(p);
  if (p->tok != TSemi && p->tok != TRBrace) {
    n->op.left = exprOrTuple(p, PREC_LOWEST, fl | PFlagRValue);
    NodeTransferUnresolved(n, n->op.left);
  }
  return n;
}


// params = "(" param (sep param)* sep? ")"
// param  = Id Type? | Type
// sep    = "," | ";"
//
static Node* pParams(Parser* p) { // => NTuple
  // examples:
  //
  // (T)
  // (x T)
  // (x, y, z T)
  // (... T)
  // (x  ... T)
  // (x, y, z  ... T)
  // (T1, T2, T3)
  // (T1, T2, ... T3)
  //
  assert(p->tok == TLParen);
  auto n = mknode(p, Tuple);
  nexttok(p); // consume "("

  // empty params? eg "()"
  if (p->tok == TRParen || p->tok == TNone) {
    want(p, TRParen);
    return n;
  }

  bool hasTypedParam = false; // true when at least one param has type; e.g. "x T"
  PFlag fl = PFlagRValue;

  void* typeq_st[32];
  NodeArray typeq = Array_INIT_WITH_STORAGE(typeq_st, countof(typeq_st));

  while (1) {
    auto cn = mknode(p, Var);
    NodeSetConst(cn);
    NodeSetUnused(cn);
    NodeSetParam(cn);
    NodeArrayPush(&n->array.a, cn, p->build->mem);

    if (p->tok == TId) {
      // name eg "x"
      cn->var.name = p->name;
      nexttok(p);
      switch (p->tok) {
        case TRParen:
        case TComma:
        case TSemi:
          // just a lone name, eg "x" in "(x, y)"
          NodeArrayPush(&typeq, cn, p->build->mem);
          break;

        default:
          // type follows name, eg "x int"
          cn->type = pType(p, fl);
          hasTypedParam = true;
          // cascade type to predecessors
          for (u32 i = 0; i < typeq.len; i++) {
            ((Node*)typeq.v[i])->type = cn->type;
          }
          typeq.len = 0;
      }
    } else {
      // definitely just type, e.g. "fun([]int,bool)"
      cn->type = pType(p, fl);
    }

    // end loop?
    switch (p->tok) {
      case TComma:
      case TSemi:
        if (nexttok(p) == TRParen) // consume "," or ";"
          goto finish; // trailing "," or ";"
        break; // continue reading more
      case TRParen:
        goto finish;
      default:
        syntaxerr(p, "expecting , ; or )");
        Tok followlist[] = { TRParen, 0 };
        advance(p, followlist);
        goto finish;
    }
  }

finish:
  if (hasTypedParam) {
    // name-and-type form; e.g. "(x, y T, z Y)"
    if (typeq.len > 0) {
      // at least one param has type, but the last one does not.
      // e.g. "(x, y int, z)"
      syntaxerr(p, "expecting type");
    }
    u32 index = 0;
    for (u32 i = 0; i < n->array.a.len; i++) {
      Node* cn = (Node*)n->array.a.v[i];
      cn->var.index = index++;
      defsym(p, cn->var.name, cn);
      NodeTransferUnresolved(cn, cn->type);
      NodeTransferUnresolved(n, cn->type);
    }
  } else {
    // type-only form, e.g. "(T, T, Y)"
    // make ident of each cn->var.name where cn->type == NULL
    //
    // TODO: for template parameters, this case means "name only without type constraints"
    //
    u32 index = 0;
    for (u32 i = 0; i < n->array.a.len; i++) {
      Node* cn = (Node*)n->array.a.v[i];
      if (!cn->type) {
        auto t = mknode(p, Id);
        t->id.name = cn->var.name;
        cn->var.name = kSym__;
        cn->var.index = index++;
        cn->type = use_as_rvalue(p, t);
      }
      NodeTransferUnresolved(cn, cn->type);
      NodeTransferUnresolved(n, cn->type);
    }
  }

  ArrayFree(&typeq, p->build->mem);
  want(p, TRParen);
  return n;
}

// template parameters, e.g. "<T, R=T>"
static Node* templateParams(Parser* p) {
  assert(p->tok == TLt);
  PFlag fl = PFlagNone; // lvalue semantics
  auto tuple = mknode(p, Tuple);
  nexttok(p); // consume "<"
  do {
    if (UNLIKELY(p->tok != TId)) {
      syntaxerr(p, "expecting %s", TokName(TId));
      break;
    }
    auto name = mknode(p, Id);
    name->id.name = p->name;
    nexttok(p); // consume id
    Node* init = NULL;
    if (got(p, TAssign)) // T=something
      init = prefixExpr(p, fl | PFlagRValue);
    Node* var = make_var(p, name, init, NULL);
    var->flags |= NF_MacroParam;
    var->type = kType_nil;
    NodeArrayPush(&tuple->array.a, var, p->build->mem);
  } while (got(p, TComma) && p->tok != TGt);
  want(p, TGt);
  set_endpos(p, tuple);
  return tuple;
}


// Fun     = FunDef | FunExpr
// FunDef  = "fun" Id? params? Type? Block?
// FunExpr = "fun" Id? params? Type? "->" Expr
//
// e.g.
//   fun foo (x, y int) int
//   fun foo (x, y int) int { x * y }
//   fun foo { 5 }
//   fun foo -> 5
//   fun (x, y int) int { x * y }
//   fun { 5 }
//   fun -> 5
//
//!PrefixParselet TFun
static Node* PFun(Parser* p, PFlag fl) {
  auto n = mknode(p, Fun);
  nexttok(p); // consume "fun"

  // name
  if (p->tok == TId) {
    n->fun.name = p->name;
    nexttok(p);
  } else if ((fl & PFlagRValue) == 0) {
    syntaxerr(p, "expecting name");
    nexttok(p);
  }

  // template parameters, e.g. "fun foo<T, R>(...)" => NMacro
  Node* macro = NULL;
  if (p->tok == TLt) {
    macro = mknode(p, Macro);
    if (n->fun.name)
      defsym(p, n->fun.name, macro);
    pushScope(p);
    macro->macro.name = n->fun.name;
    macro->macro.params = templateParams(p);
    // Note: no NodeTransferUnresolved for params
  }

  if (n->fun.name)
    defsym(p, n->fun.name, n);

  // function parameters
  pushScope(p); // body AND parameter scope
  if (p->tok == TLParen) {
    Node* pa = pParams(p);
    // Note: the type of fun.params should structually match the type of call.args.
    // This reduces the work needed by the type resolver.
    if (pa->array.a.len > 0) {
      n->fun.params = pa;
      NodeTransferUnresolved(n, pa);
    }
  }

  // result type(s)
  if (p->tok != TLBrace && p->tok != TSemi) {
    if (p->tok == TRArr) {
      // e.g. "fun foo() -> 123" => "fun foo() auto { 123 }"
      n->fun.result = kType_auto;
    } else {
      n->fun.result = pType(p, fl);
      NodeTransferUnresolved(n, n->fun.result);
    }
  } else {
    // no result type specified is the same as "nil" (does not return a value)
    n->fun.result = kType_nil;
  }

  // set endpos
  // FIXME: this sets endpos to the next following token, not the last token.
  // Example:
  // 1  fun add(x int, y uint) int
  // 2
  // Gets an endpos of 2:0 (which is invalid since column is zero so formatters will ignore it)
  // It should get endpos 1:24 (for "int")
  set_endpos(p, n);

  // body
  p->fnest++;
  PFlag bodyfl = n->fun.result == Const_nil ? (fl & ~PFlagRValue) : (fl | PFlagRValue);
  if (p->tok == TLBrace) {
    // assign body before parsing so that we can check for it in pBlock
    assert((fl & PFlagType) == 0); // needed for PBlockOrStructType
    n->fun.body = pBlock(p, bodyfl);
  } else if (got(p, TRArr)) {
    n->fun.body = exprOrTuple(p, PREC_LOWEST, bodyfl);
  }
  p->fnest--;

  if (n->fun.body) {
    NodeTransferUnresolved(n, n->fun.body);
    popScopeAndCheckUnused(p); // function parameter scope
  } else {
    popScope(p);
  }

  if (macro) {
    popScopeAndCheckUnused(p); // template parameter scope
    macro->macro.template = n;
    return macro;
  }

  return n;
}


// end of parselets
// ============================================================================================
// ============================================================================================


//PARSELET_MAP_BEGIN
// automatically generated by misc/gen_parselet_map.py; do not edit
static const Parselet parselets[TMax] = {
  [TNil] = {PNil, NULL, PREC_MEMBER},
  [TAuto] = {PAuto, NULL, PREC_MEMBER},
  [TId] = {PId, PIdTrailing, PREC_ASSIGN},
  [TMut] = {PMut, NULL, PREC_MEMBER},
  [TVar] = {PVarOrConst, NULL, PREC_MEMBER},
  [TConst] = {PVarOrConst, NULL, PREC_MEMBER},
  [TLParen] = {PGroup, PCall, PREC_MEMBER},
  [TLBrack] = {PLBrackPrefix, PLBrackInfix, PREC_MEMBER},
  [TAnd] = {PRefPrefix, PInfixOp, PREC_BITWISE_AND},
  [TStruct] = {PStructType, NULL, PREC_MEMBER},
  [TType] = {PTypeDef, NULL, PREC_MEMBER},
  [TLBrace] = {PBlockOrStructType, NULL, PREC_MEMBER},
  [TPlus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TMinus] = {PPrefixOp, PInfixOp, PREC_ADD},
  [TExcalm] = {PPrefixOp, NULL, PREC_MEMBER},
  [TStar] = {PPrefixOp, PInfixOp, PREC_MULTIPLY},
  [TIntLit] = {PIntLit, NULL, PREC_MEMBER},
  [TIf] = {PIf, NULL, PREC_MEMBER},
  [TReturn] = {PReturn, NULL, PREC_MEMBER},
  [TFun] = {PFun, NULL, PREC_MEMBER},
  [TAssign] = {NULL, PAssign, PREC_ASSIGN},
  [TAs] = {NULL, PAs, PREC_LOWEST},
  [TPipePipe] = {NULL, PInfixOp, PREC_LOGICAL_OR},
  [TAndAnd] = {NULL, PInfixOp, PREC_LOGICAL_AND},
  [TPipe] = {NULL, PInfixOp, PREC_BITWISE_OR},
  [THat] = {NULL, PInfixOp, PREC_BITWISE_XOR},
  [TEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TNEq] = {NULL, PInfixOp, PREC_EQUAL},
  [TLt] = {NULL, PInfixOp, PREC_COMPARE},
  [TGt] = {NULL, PInfixOp, PREC_COMPARE},
  [TLEq] = {NULL, PInfixOp, PREC_COMPARE},
  [TGEq] = {NULL, PInfixOp, PREC_COMPARE},
  [TSlash] = {NULL, PInfixOp, PREC_MULTIPLY},
  [TPlusPlus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TMinusMinus] = {NULL, PPostfixOp, PREC_UNARY_POSTFIX},
  [TDot] = {NULL, PSelector, PREC_MEMBER},
};
//PARSELET_MAP_END


static Node* prefixExpr(Parser* p, PFlag fl) {
  // find prefix parselet
  assert((u32)p->tok < (u32)TMax);
  const Parselet* parselet = &parselets[p->tok];
  if (!parselet->fprefix) {
    // dlog("prefixExpr NOT found for %s", TokName(p->tok));
    syntaxerr(p, "expecting expression");
    Node* n = bad(p);
    Tok followlist[] = { TRParen, TRBrace, TRBrack, TSemi, 0 };
    advance(p, followlist);
    return n;
  }
  // dlog("prefixExpr FOUND for %s", TokName(p->tok));
  return p->expr = parselet->fprefix(p, fl);
}


static Node* infixExpr(Parser* p, int precedence, PFlag fl, Node* left) {
  // wrap parselets
  // TODO: Should we set fl|PFlagRValue here?
  while (p->tok != TNone) {
    const Parselet& parselet = &parselets[p->tok];
    assertnotnull(parselet);
    // if (parselet->f) {
    //   dlog("infix parselet FOUND for %s; parselet->prec=%d < precedence=%d = %s",
    //     TokName(p->tok), parselet->prec, precedence,
    //     (int)parselet->prec < precedence ? "Y" : "N");
    // } else {
    //   dlog("infix parselet NOT found for %s", TokName(p->tok));
    // }
    if (!parselet->f || (int)parselet->prec < precedence) {
      break;
    }
    p->expr = parselet->f(p, parselet, fl, left);
    if (p->expr == NULL)
      return left;
    assert(left != p->expr); // or else: infinite loop
    left = p->expr;
  }
  return left;
}


static Node* expr(Parser* p, int precedence, PFlag fl) {
  // Note: precedence should match the calling parselet's own precedence
  Node* left = prefixExpr(p, fl);
  return infixExpr(p, precedence, fl, left);
}


// exprOrTuple = Expr | Tuple
//
// This function has different behavior depending on PFlagRValue:
//
//   PFlagRValue=OFF consumes a prefixExpr, then a possible tuple and finally calls
//   infixExpr to include the tuple in an infix expression like t + y.
//
//   - PFlagRValue=OFF is "conservative" used for lvalues, e.g. (a b c) in a,b,c=1,2,3
//   - PFlagRValue=ON is "greedy" and used for rvalues, e.g. (x (y + z)) in _,_=x,y+z
//
//   Consider the following source code:
//     a, b + c, d
//   Parsing this with the different functions yields:
//   - PFlagRValue=OFF => (+ (a b) c)
//   - PFlagRValue=ON => (a (+ b c) d)
//
//   Explanation of PFlagRValue=OFF:
//   • PFlagRValue=OFF calls prefixExpr => a
//   • PFlagRValue=OFF sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=OFF calls prefixExpr => b
//   • PFlagRValue=OFF end tuple => (a b)
//   • infixExpr with tuple as the LHS:
//     • infixExpr calls '+' parselet
//       • '+' parselet reads RHS by calling expr:
//         • expr calls prefixExpr (which in turn calls 'ident' parselet) => c
//         • expr returns the c identifier (NId)
//       • '+' parselet produces LHS + RHS => (+ (a b) c)
//     • return
//   • return
//
//   Explanation of PFlagRValue=ON:
//   • PFlagRValue=ON calls expr => a
//   • PFlagRValue=ON sees a comma and begins tuple-parsing mode:
//   • PFlagRValue=ON calls expr
//     • expr calls prefixExpr => b
//     • expr calls infixExpr with b as LHS:
//       • infixExpr calls '+' parselet
//         • '+' parselet reads RHS by calling expr:
//           • expr calls prefixExpr => c
//           • expr returns the c identifier (NId)
//         • '+' parselet produces LHS + RHS => (+ b c)
//       • return
//     • return
//   • PFlagRValue=ON calls expr after another comma
//     • calls prefixExpr => b
//   • PFlagRValue=ON see no more comma; ends the tuple => (a (+ b c) d)
//
static Node* exprOrTuple(Parser* p, int precedence, PFlag fl) {
  Node* left = (
    fl & PFlagRValue ? expr(p, precedence, fl) :
                       prefixExpr(p, fl) ); // read a prefix expression, like an identifier

  if (got(p, TComma)) {
    // start a tuple
    Node* g =
    if (fl & PFlagType) {
      g = as_Node(mktype(p, NTupleType, TF_KindArray));
    } else {
      g = as_Node(mknode(p, NTuple));
    }
    NodeArray* array = fl & PFlagType ? &g->t.tuple.a : &g->array.a;
    NodeArrayPush(array, left, p->build->mem);
    NodeTransferUnresolved(g, left);
    if (fl & PFlagRValue) {
      do {
        Node* cn = expr(p, precedence, fl);
        NodeArrayPush(array, cn, p->build->mem);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    } else {
      do {
        Node* cn = prefixExpr(p, fl);
        NodeArrayPush(array, cn, p->build->mem);
        NodeTransferUnresolved(g, cn);
      } while (got(p, TComma));
    }
    set_endpos(p, g);
    left = g;
  }

  if (fl & PFlagRValue)
    return left;

  // wrap in possible infix expression, e.g. "left + right"
  return infixExpr(p, precedence, fl, left);
}


Node* CreatePkgAST(Build* build, Scope* pkgscope) {
  // Scope* pkgscope
  Node* n = NewNode(build->mem, NPkg);
  n->cunit.name = build->pkg->name; // ok if null
  n->cunit.scope = pkgscope;
  // Note: Do not set n->type as it would prevent type resolver from visiting files
  return n;
}


error parse(
  Parser* p, Build* build, Source* src, ParseFlags fl, Scope* pkgscope, Node** result)
{
  *result = NULL;

  p->build = build;
  p->pkgscope = pkgscope;
  p->expr = NULL;
  p->fnest = 0;
  p->err = 0;

  if ((p->err = ScannerInit(&p-> build, src, fl)))
    return p->err;

  // scopestack
  if (p->scopestack.ptr == NULL) {
    p->scopestack.cap = countof(p->scopestack.storage);
    p->scopestack.ptr = p->scopestack.storage;
  } else {
    // reuse already-allocated memory
    p->scopestack.len = 0;
    p->scopestack.base = 0;
  }

  // load first token
  nexttok(p);

  // TODO: ParseFlags, where one option is PARSE_IMPORTS to parse only imports and then stop.

  auto file = mknode(p, File);
  file->cunit.name = src->filename; // ok if null

  while (p->tok != TNone && p->err == 0) {
    Node* n = exprOrTuple(p, PREC_LOWEST, PFlagNone);

    NodeArrayPush(&file->cunit.a, n, p->build->mem);
    NodeTransferUnresolved(file, n);

    // // print associated comments
    // Comment* c = p->comments;
    // while (c) { printf("#%.*s\n", (int)c->len, c->ptr); c = c->next; }
    // p->comments = p->comments_tail = NULL;
    // // TODO: Add "comments" to Node struct and if caller requests inclusion of comments,
    // // assign these comments to the node. This should be done in mknode and not here.

    // check that we either got a semicolon or EOF
    if (p->tok != TNone && !got(p, TSemi)) {
      syntaxerr(p, "after top level declaration");
      if (n && n->kind == NId) {
        buildctx_notef(
          p->build, (PosSpan){n->pos, NoPos}, "Did you mean \"var %s\"?", n->id.name);
      }
      Tok followlist[] = { TType, TFun, TSemi, 0 };
      advance(p, followlist);
    }
  }

  *result = file;
  return p->err;
}


ASSUME_NONNULL_END
