// generated by ast_gen.py -- do not edit
ASSUME_NONNULL_BEGIN

enum NodeKind {
  NBad            =  0, // struct BadNode
  NField          =  1, // struct FieldNode
  NStmt_BEG       =  2,
    NCUnit_BEG    =  2,
      NPkg        =  2, // struct PkgNode
      NFile       =  3, // struct FileNode
    NCUnit_END    =  3,
    NComment      =  4, // struct CommentNode
  NStmt_END       =  4,
  NExpr_BEG       =  5,
    NLitExpr_BEG  =  5,
      NNil        =  5, // struct NilNode
      NBoolLit    =  6, // struct BoolLitNode
      NIntLit     =  7, // struct IntLitNode
      NFloatLit   =  8, // struct FloatLitNode
      NStrLit     =  9, // struct StrLitNode
    NLitExpr_END  =  9,
    NId           = 10, // struct IdNode
    NBinOp        = 11, // struct BinOpNode
    NUnaryOp_BEG  = 12,
      NPrefixOp   = 12, // struct PrefixOpNode
      NPostfixOp  = 13, // struct PostfixOpNode
    NUnaryOp_END  = 13,
    NReturn       = 14, // struct ReturnNode
    NAssign       = 15, // struct AssignNode
    NListExpr_BEG = 16,
      NTuple      = 16, // struct TupleNode
      NArray      = 17, // struct ArrayNode
    NListExpr_END = 17,
    NBlock        = 18, // struct BlockNode
    NFun          = 19, // struct FunNode
    NMacro        = 20, // struct MacroNode
    NCall         = 21, // struct CallNode
    NTypeCast     = 22, // struct TypeCastNode
    NLocal_BEG    = 23,
      NConst      = 23, // struct ConstNode
      NVar        = 24, // struct VarNode
      NParam      = 25, // struct ParamNode
      NMacroParam = 26, // struct MacroParamNode
    NLocal_END    = 26,
    NRef          = 27, // struct RefNode
    NNamedArg     = 28, // struct NamedArgNode
    NSelector     = 29, // struct SelectorNode
    NIndex        = 30, // struct IndexNode
    NSlice        = 31, // struct SliceNode
    NIf           = 32, // struct IfNode
  NExpr_END       = 32,
  NType_BEG       = 33,
    NTypeType     = 33, // struct TypeTypeNode
    NNamedType    = 34, // struct NamedTypeNode
    NAliasType    = 35, // struct AliasTypeNode
    NRefType      = 36, // struct RefTypeNode
    NBasicType    = 37, // struct BasicTypeNode
    NArrayType    = 38, // struct ArrayTypeNode
    NTupleType    = 39, // struct TupleTypeNode
    NStructType   = 40, // struct StructTypeNode
    NFunType      = 41, // struct FunTypeNode
  NType_END       = 41,
  NodeKind_MAX    = 41,
} END_TYPED_ENUM(NodeKind)

// NodeKindName returns a printable name. E.g. NBad => "Bad"
const char* NodeKindName(NodeKind);

typedef struct BadNode BadNode;
typedef struct FieldNode FieldNode;
typedef struct PkgNode PkgNode;
typedef struct FileNode FileNode;
typedef struct CommentNode CommentNode;
typedef struct NilNode NilNode;
typedef struct BoolLitNode BoolLitNode;
typedef struct IntLitNode IntLitNode;
typedef struct FloatLitNode FloatLitNode;
typedef struct StrLitNode StrLitNode;
typedef struct IdNode IdNode;
typedef struct BinOpNode BinOpNode;
typedef struct PrefixOpNode PrefixOpNode;
typedef struct PostfixOpNode PostfixOpNode;
typedef struct ReturnNode ReturnNode;
typedef struct AssignNode AssignNode;
typedef struct TupleNode TupleNode;
typedef struct ArrayNode ArrayNode;
typedef struct BlockNode BlockNode;
typedef struct FunNode FunNode;
typedef struct MacroNode MacroNode;
typedef struct CallNode CallNode;
typedef struct TypeCastNode TypeCastNode;
typedef struct ConstNode ConstNode;
typedef struct VarNode VarNode;
typedef struct ParamNode ParamNode;
typedef struct MacroParamNode MacroParamNode;
typedef struct RefNode RefNode;
typedef struct NamedArgNode NamedArgNode;
typedef struct SelectorNode SelectorNode;
typedef struct IndexNode IndexNode;
typedef struct SliceNode SliceNode;
typedef struct IfNode IfNode;
typedef struct TypeTypeNode TypeTypeNode;
typedef struct NamedTypeNode NamedTypeNode;
typedef struct AliasTypeNode AliasTypeNode;
typedef struct RefTypeNode RefTypeNode;
typedef struct BasicTypeNode BasicTypeNode;
typedef struct ArrayTypeNode ArrayTypeNode;
typedef struct TupleTypeNode TupleTypeNode;
typedef struct StructTypeNode StructTypeNode;
typedef struct FunTypeNode FunTypeNode;

// bool NodeKindIs<kind>(NodeKind)
#define NodeKindIsStmt(k) (NStmt_BEG <= (k) && (k) <= NStmt_END)
#define NodeKindIsCUnit(k) (NCUnit_BEG <= (k) && (k) <= NCUnit_END)
#define NodeKindIsExpr(k) (NExpr_BEG <= (k) && (k) <= NExpr_END)
#define NodeKindIsLitExpr(k) (NLitExpr_BEG <= (k) && (k) <= NLitExpr_END)
#define NodeKindIsUnaryOp(k) (NUnaryOp_BEG <= (k) && (k) <= NUnaryOp_END)
#define NodeKindIsListExpr(k) (NListExpr_BEG <= (k) && (k) <= NListExpr_END)
#define NodeKindIsLocal(k) (NLocal_BEG <= (k) && (k) <= NLocal_END)
#define NodeKindIsType(k) (NType_BEG <= (k) && (k) <= NType_END)

// bool is_<kind>(const Node*)
#define is_BadNode(n) ((n)->kind==NBad)
#define is_FieldNode(n) ((n)->kind==NField)
#define is_Stmt(n) NodeKindIsStmt((n)->kind)
#define is_CUnitNode(n) NodeKindIsCUnit((n)->kind)
#define is_PkgNode(n) ((n)->kind==NPkg)
#define is_FileNode(n) ((n)->kind==NFile)
#define is_CommentNode(n) ((n)->kind==NComment)
#define is_Expr(n) NodeKindIsExpr((n)->kind)
#define is_LitExpr(n) NodeKindIsLitExpr((n)->kind)
#define is_NilNode(n) ((n)->kind==NNil)
#define is_BoolLitNode(n) ((n)->kind==NBoolLit)
#define is_IntLitNode(n) ((n)->kind==NIntLit)
#define is_FloatLitNode(n) ((n)->kind==NFloatLit)
#define is_StrLitNode(n) ((n)->kind==NStrLit)
#define is_IdNode(n) ((n)->kind==NId)
#define is_BinOpNode(n) ((n)->kind==NBinOp)
#define is_UnaryOpNode(n) NodeKindIsUnaryOp((n)->kind)
#define is_PrefixOpNode(n) ((n)->kind==NPrefixOp)
#define is_PostfixOpNode(n) ((n)->kind==NPostfixOp)
#define is_ReturnNode(n) ((n)->kind==NReturn)
#define is_AssignNode(n) ((n)->kind==NAssign)
#define is_ListExprNode(n) NodeKindIsListExpr((n)->kind)
#define is_TupleNode(n) ((n)->kind==NTuple)
#define is_ArrayNode(n) ((n)->kind==NArray)
#define is_BlockNode(n) ((n)->kind==NBlock)
#define is_FunNode(n) ((n)->kind==NFun)
#define is_MacroNode(n) ((n)->kind==NMacro)
#define is_CallNode(n) ((n)->kind==NCall)
#define is_TypeCastNode(n) ((n)->kind==NTypeCast)
#define is_LocalNode(n) NodeKindIsLocal((n)->kind)
#define is_ConstNode(n) ((n)->kind==NConst)
#define is_VarNode(n) ((n)->kind==NVar)
#define is_ParamNode(n) ((n)->kind==NParam)
#define is_MacroParamNode(n) ((n)->kind==NMacroParam)
#define is_RefNode(n) ((n)->kind==NRef)
#define is_NamedArgNode(n) ((n)->kind==NNamedArg)
#define is_SelectorNode(n) ((n)->kind==NSelector)
#define is_IndexNode(n) ((n)->kind==NIndex)
#define is_SliceNode(n) ((n)->kind==NSlice)
#define is_IfNode(n) ((n)->kind==NIf)
#define is_Type(n) NodeKindIsType((n)->kind)
#define is_TypeTypeNode(n) ((n)->kind==NTypeType)
#define is_NamedTypeNode(n) ((n)->kind==NNamedType)
#define is_AliasTypeNode(n) ((n)->kind==NAliasType)
#define is_RefTypeNode(n) ((n)->kind==NRefType)
#define is_BasicTypeNode(n) ((n)->kind==NBasicType)
#define is_ArrayTypeNode(n) ((n)->kind==NArrayType)
#define is_TupleTypeNode(n) ((n)->kind==NTupleType)
#define is_StructTypeNode(n) ((n)->kind==NStructType)
#define is_FunTypeNode(n) ((n)->kind==NFunType)

// void assert_is_<kind>(const Node*)
#ifdef DEBUG
#define _assert_is1(NAME,n) ({ \
  NodeKind nk__ = assertnotnull(n)->kind; \
  assertf(NodeKindIs##NAME(nk__), "expected N%s; got N%s #%d", \
          #NAME, NodeKindName(nk__), nk__); \
})
#else
#define _assert_is1(NAME,n) ((void)0)
#endif
#define assert_is_BadNode(n) asserteq(assertnotnull(n)->kind,NBad)
#define assert_is_FieldNode(n) asserteq(assertnotnull(n)->kind,NField)
#define assert_is_Stmt(n) _assert_is1(Stmt,(n))
#define assert_is_CUnitNode(n) _assert_is1(CUnit,(n))
#define assert_is_PkgNode(n) asserteq(assertnotnull(n)->kind,NPkg)
#define assert_is_FileNode(n) asserteq(assertnotnull(n)->kind,NFile)
#define assert_is_CommentNode(n) asserteq(assertnotnull(n)->kind,NComment)
#define assert_is_Expr(n) _assert_is1(Expr,(n))
#define assert_is_LitExpr(n) _assert_is1(LitExpr,(n))
#define assert_is_NilNode(n) asserteq(assertnotnull(n)->kind,NNil)
#define assert_is_BoolLitNode(n) asserteq(assertnotnull(n)->kind,NBoolLit)
#define assert_is_IntLitNode(n) asserteq(assertnotnull(n)->kind,NIntLit)
#define assert_is_FloatLitNode(n) asserteq(assertnotnull(n)->kind,NFloatLit)
#define assert_is_StrLitNode(n) asserteq(assertnotnull(n)->kind,NStrLit)
#define assert_is_IdNode(n) asserteq(assertnotnull(n)->kind,NId)
#define assert_is_BinOpNode(n) asserteq(assertnotnull(n)->kind,NBinOp)
#define assert_is_UnaryOpNode(n) _assert_is1(UnaryOp,(n))
#define assert_is_PrefixOpNode(n) asserteq(assertnotnull(n)->kind,NPrefixOp)
#define assert_is_PostfixOpNode(n) asserteq(assertnotnull(n)->kind,NPostfixOp)
#define assert_is_ReturnNode(n) asserteq(assertnotnull(n)->kind,NReturn)
#define assert_is_AssignNode(n) asserteq(assertnotnull(n)->kind,NAssign)
#define assert_is_ListExprNode(n) _assert_is1(ListExpr,(n))
#define assert_is_TupleNode(n) asserteq(assertnotnull(n)->kind,NTuple)
#define assert_is_ArrayNode(n) asserteq(assertnotnull(n)->kind,NArray)
#define assert_is_BlockNode(n) asserteq(assertnotnull(n)->kind,NBlock)
#define assert_is_FunNode(n) asserteq(assertnotnull(n)->kind,NFun)
#define assert_is_MacroNode(n) asserteq(assertnotnull(n)->kind,NMacro)
#define assert_is_CallNode(n) asserteq(assertnotnull(n)->kind,NCall)
#define assert_is_TypeCastNode(n) asserteq(assertnotnull(n)->kind,NTypeCast)
#define assert_is_LocalNode(n) _assert_is1(Local,(n))
#define assert_is_ConstNode(n) asserteq(assertnotnull(n)->kind,NConst)
#define assert_is_VarNode(n) asserteq(assertnotnull(n)->kind,NVar)
#define assert_is_ParamNode(n) asserteq(assertnotnull(n)->kind,NParam)
#define assert_is_MacroParamNode(n) asserteq(assertnotnull(n)->kind,NMacroParam)
#define assert_is_RefNode(n) asserteq(assertnotnull(n)->kind,NRef)
#define assert_is_NamedArgNode(n) asserteq(assertnotnull(n)->kind,NNamedArg)
#define assert_is_SelectorNode(n) asserteq(assertnotnull(n)->kind,NSelector)
#define assert_is_IndexNode(n) asserteq(assertnotnull(n)->kind,NIndex)
#define assert_is_SliceNode(n) asserteq(assertnotnull(n)->kind,NSlice)
#define assert_is_IfNode(n) asserteq(assertnotnull(n)->kind,NIf)
#define assert_is_Type(n) _assert_is1(Type,(n))
#define assert_is_TypeTypeNode(n) asserteq(assertnotnull(n)->kind,NTypeType)
#define assert_is_NamedTypeNode(n) asserteq(assertnotnull(n)->kind,NNamedType)
#define assert_is_AliasTypeNode(n) asserteq(assertnotnull(n)->kind,NAliasType)
#define assert_is_RefTypeNode(n) asserteq(assertnotnull(n)->kind,NRefType)
#define assert_is_BasicTypeNode(n) asserteq(assertnotnull(n)->kind,NBasicType)
#define assert_is_ArrayTypeNode(n) asserteq(assertnotnull(n)->kind,NArrayType)
#define assert_is_TupleTypeNode(n) asserteq(assertnotnull(n)->kind,NTupleType)
#define assert_is_StructTypeNode(n) asserteq(assertnotnull(n)->kind,NStructType)
#define assert_is_FunTypeNode(n) asserteq(assertnotnull(n)->kind,NFunType)

// T* as_T(Node* n)
// const T* as_const_T(const Node* n)
//
// Large _Generic with both const and non-const cases ("const T*" & "T*")
// are really slow to compile, so we break up the "as_" macros into two forms.
#if defined(DEBUG)
  #define as_Node(n) ((Node*)(n))
  #define as_const_Node(n) ((const Node*)(n))
  #define as_BadNode(n) ({ assert_is_BadNode(n); (BadNode*)(n); })
  #define as_const_BadNode(n) ({ assert_is_BadNode(n); (const BadNode*)(n); })
  #define as_FieldNode(n) ({ assert_is_FieldNode(n); (FieldNode*)(n); })
  #define as_const_FieldNode(n) ({ assert_is_FieldNode(n); (const FieldNode*)(n); })
  #define as_PkgNode(n) ({ assert_is_PkgNode(n); (PkgNode*)(n); })
  #define as_const_PkgNode(n) ({ assert_is_PkgNode(n); (const PkgNode*)(n); })
  #define as_FileNode(n) ({ assert_is_FileNode(n); (FileNode*)(n); })
  #define as_const_FileNode(n) ({ assert_is_FileNode(n); (const FileNode*)(n); })
  #define as_CommentNode(n) ({ assert_is_CommentNode(n); (CommentNode*)(n); })
  #define as_const_CommentNode(n) ({ assert_is_CommentNode(n); (const CommentNode*)(n); })
  #define as_NilNode(n) ({ assert_is_NilNode(n); (NilNode*)(n); })
  #define as_const_NilNode(n) ({ assert_is_NilNode(n); (const NilNode*)(n); })
  #define as_BoolLitNode(n) ({ assert_is_BoolLitNode(n); (BoolLitNode*)(n); })
  #define as_const_BoolLitNode(n) ({ assert_is_BoolLitNode(n); (const BoolLitNode*)(n); })
  #define as_IntLitNode(n) ({ assert_is_IntLitNode(n); (IntLitNode*)(n); })
  #define as_const_IntLitNode(n) ({ assert_is_IntLitNode(n); (const IntLitNode*)(n); })
  #define as_FloatLitNode(n) ({ assert_is_FloatLitNode(n); (FloatLitNode*)(n); })
  #define as_const_FloatLitNode(n) ({ assert_is_FloatLitNode(n); (const FloatLitNode*)(n); })
  #define as_StrLitNode(n) ({ assert_is_StrLitNode(n); (StrLitNode*)(n); })
  #define as_const_StrLitNode(n) ({ assert_is_StrLitNode(n); (const StrLitNode*)(n); })
  #define as_IdNode(n) ({ assert_is_IdNode(n); (IdNode*)(n); })
  #define as_const_IdNode(n) ({ assert_is_IdNode(n); (const IdNode*)(n); })
  #define as_BinOpNode(n) ({ assert_is_BinOpNode(n); (BinOpNode*)(n); })
  #define as_const_BinOpNode(n) ({ assert_is_BinOpNode(n); (const BinOpNode*)(n); })
  #define as_PrefixOpNode(n) ({ assert_is_PrefixOpNode(n); (PrefixOpNode*)(n); })
  #define as_const_PrefixOpNode(n) ({ assert_is_PrefixOpNode(n); (const PrefixOpNode*)(n); })
  #define as_PostfixOpNode(n) ({ assert_is_PostfixOpNode(n); (PostfixOpNode*)(n); })
  #define as_const_PostfixOpNode(n) ({ assert_is_PostfixOpNode(n); (const PostfixOpNode*)(n); })
  #define as_ReturnNode(n) ({ assert_is_ReturnNode(n); (ReturnNode*)(n); })
  #define as_const_ReturnNode(n) ({ assert_is_ReturnNode(n); (const ReturnNode*)(n); })
  #define as_AssignNode(n) ({ assert_is_AssignNode(n); (AssignNode*)(n); })
  #define as_const_AssignNode(n) ({ assert_is_AssignNode(n); (const AssignNode*)(n); })
  #define as_TupleNode(n) ({ assert_is_TupleNode(n); (TupleNode*)(n); })
  #define as_const_TupleNode(n) ({ assert_is_TupleNode(n); (const TupleNode*)(n); })
  #define as_ArrayNode(n) ({ assert_is_ArrayNode(n); (ArrayNode*)(n); })
  #define as_const_ArrayNode(n) ({ assert_is_ArrayNode(n); (const ArrayNode*)(n); })
  #define as_BlockNode(n) ({ assert_is_BlockNode(n); (BlockNode*)(n); })
  #define as_const_BlockNode(n) ({ assert_is_BlockNode(n); (const BlockNode*)(n); })
  #define as_FunNode(n) ({ assert_is_FunNode(n); (FunNode*)(n); })
  #define as_const_FunNode(n) ({ assert_is_FunNode(n); (const FunNode*)(n); })
  #define as_MacroNode(n) ({ assert_is_MacroNode(n); (MacroNode*)(n); })
  #define as_const_MacroNode(n) ({ assert_is_MacroNode(n); (const MacroNode*)(n); })
  #define as_CallNode(n) ({ assert_is_CallNode(n); (CallNode*)(n); })
  #define as_const_CallNode(n) ({ assert_is_CallNode(n); (const CallNode*)(n); })
  #define as_TypeCastNode(n) ({ assert_is_TypeCastNode(n); (TypeCastNode*)(n); })
  #define as_const_TypeCastNode(n) ({ assert_is_TypeCastNode(n); (const TypeCastNode*)(n); })
  #define as_ConstNode(n) ({ assert_is_ConstNode(n); (ConstNode*)(n); })
  #define as_const_ConstNode(n) ({ assert_is_ConstNode(n); (const ConstNode*)(n); })
  #define as_VarNode(n) ({ assert_is_VarNode(n); (VarNode*)(n); })
  #define as_const_VarNode(n) ({ assert_is_VarNode(n); (const VarNode*)(n); })
  #define as_ParamNode(n) ({ assert_is_ParamNode(n); (ParamNode*)(n); })
  #define as_const_ParamNode(n) ({ assert_is_ParamNode(n); (const ParamNode*)(n); })
  #define as_MacroParamNode(n) ({ assert_is_MacroParamNode(n); (MacroParamNode*)(n); })
  #define as_const_MacroParamNode(n) ({ assert_is_MacroParamNode(n); (const MacroParamNode*)(n); })
  #define as_RefNode(n) ({ assert_is_RefNode(n); (RefNode*)(n); })
  #define as_const_RefNode(n) ({ assert_is_RefNode(n); (const RefNode*)(n); })
  #define as_NamedArgNode(n) ({ assert_is_NamedArgNode(n); (NamedArgNode*)(n); })
  #define as_const_NamedArgNode(n) ({ assert_is_NamedArgNode(n); (const NamedArgNode*)(n); })
  #define as_SelectorNode(n) ({ assert_is_SelectorNode(n); (SelectorNode*)(n); })
  #define as_const_SelectorNode(n) ({ assert_is_SelectorNode(n); (const SelectorNode*)(n); })
  #define as_IndexNode(n) ({ assert_is_IndexNode(n); (IndexNode*)(n); })
  #define as_const_IndexNode(n) ({ assert_is_IndexNode(n); (const IndexNode*)(n); })
  #define as_SliceNode(n) ({ assert_is_SliceNode(n); (SliceNode*)(n); })
  #define as_const_SliceNode(n) ({ assert_is_SliceNode(n); (const SliceNode*)(n); })
  #define as_IfNode(n) ({ assert_is_IfNode(n); (IfNode*)(n); })
  #define as_const_IfNode(n) ({ assert_is_IfNode(n); (const IfNode*)(n); })
  #define as_TypeTypeNode(n) ({ assert_is_TypeTypeNode(n); (TypeTypeNode*)(n); })
  #define as_const_TypeTypeNode(n) ({ assert_is_TypeTypeNode(n); (const TypeTypeNode*)(n); })
  #define as_NamedTypeNode(n) ({ assert_is_NamedTypeNode(n); (NamedTypeNode*)(n); })
  #define as_const_NamedTypeNode(n) ({ assert_is_NamedTypeNode(n); (const NamedTypeNode*)(n); })
  #define as_AliasTypeNode(n) ({ assert_is_AliasTypeNode(n); (AliasTypeNode*)(n); })
  #define as_const_AliasTypeNode(n) ({ assert_is_AliasTypeNode(n); (const AliasTypeNode*)(n); })
  #define as_RefTypeNode(n) ({ assert_is_RefTypeNode(n); (RefTypeNode*)(n); })
  #define as_const_RefTypeNode(n) ({ assert_is_RefTypeNode(n); (const RefTypeNode*)(n); })
  #define as_BasicTypeNode(n) ({ assert_is_BasicTypeNode(n); (BasicTypeNode*)(n); })
  #define as_const_BasicTypeNode(n) ({ assert_is_BasicTypeNode(n); (const BasicTypeNode*)(n); })
  #define as_ArrayTypeNode(n) ({ assert_is_ArrayTypeNode(n); (ArrayTypeNode*)(n); })
  #define as_const_ArrayTypeNode(n) ({ assert_is_ArrayTypeNode(n); (const ArrayTypeNode*)(n); })
  #define as_TupleTypeNode(n) ({ assert_is_TupleTypeNode(n); (TupleTypeNode*)(n); })
  #define as_const_TupleTypeNode(n) ({ assert_is_TupleTypeNode(n); (const TupleTypeNode*)(n); })
  #define as_StructTypeNode(n) ({ assert_is_StructTypeNode(n); (StructTypeNode*)(n); })
  #define as_const_StructTypeNode(n) ({ assert_is_StructTypeNode(n); (const StructTypeNode*)(n); })
  #define as_FunTypeNode(n) ({ assert_is_FunTypeNode(n); (FunTypeNode*)(n); })
  #define as_const_FunTypeNode(n) ({ assert_is_FunTypeNode(n); (const FunTypeNode*)(n); })
  #define as_Stmt(n) _Generic((n), PkgNode*:(Stmt*)(n), FileNode*:(Stmt*)(n), \
    struct CUnitNode*:(Stmt*)(n), CommentNode*:(Stmt*)(n), Stmt*:(Stmt*)(n), \
    Node*: ({ assert_is_Stmt(n); (Stmt*)(n); }))
  #define as_const_Stmt(n) _Generic((n), const PkgNode*:(const Stmt*)(n), \
    const FileNode*:(const Stmt*)(n), const struct CUnitNode*:(const Stmt*)(n), \
    const CommentNode*:(const Stmt*)(n), const Stmt*:(const Stmt*)(n), \
    const Node*: ({ assert_is_Stmt(n); (const Stmt*)(n); }))

  #define as_CUnitNode(n) _Generic((n), PkgNode*:(struct CUnitNode*)(n), \
    FileNode*:(struct CUnitNode*)(n), struct CUnitNode*:(struct CUnitNode*)(n), \
    Node*: ({ assert_is_CUnitNode(n); (struct CUnitNode*)(n); }))
  #define as_const_CUnitNode(n) _Generic((n), \
    const PkgNode*:(const struct CUnitNode*)(n), \
    const FileNode*:(const struct CUnitNode*)(n), \
    const struct CUnitNode*:(const struct CUnitNode*)(n), \
    const Node*: ({ assert_is_CUnitNode(n); (const struct CUnitNode*)(n); }))

  #define as_Expr(n) _Generic((n), NilNode*:(Expr*)(n), BoolLitNode*:(Expr*)(n), \
    IntLitNode*:(Expr*)(n), FloatLitNode*:(Expr*)(n), StrLitNode*:(Expr*)(n), \
    struct LitExpr*:(Expr*)(n), IdNode*:(Expr*)(n), BinOpNode*:(Expr*)(n), \
    PrefixOpNode*:(Expr*)(n), PostfixOpNode*:(Expr*)(n), struct UnaryOpNode*:(Expr*)(n), \
    ReturnNode*:(Expr*)(n), AssignNode*:(Expr*)(n), TupleNode*:(Expr*)(n), \
    ArrayNode*:(Expr*)(n), struct ListExprNode*:(Expr*)(n), BlockNode*:(Expr*)(n), \
    FunNode*:(Expr*)(n), MacroNode*:(Expr*)(n), CallNode*:(Expr*)(n), \
    TypeCastNode*:(Expr*)(n), ConstNode*:(Expr*)(n), VarNode*:(Expr*)(n), \
    ParamNode*:(Expr*)(n), MacroParamNode*:(Expr*)(n), struct LocalNode*:(Expr*)(n), \
    RefNode*:(Expr*)(n), NamedArgNode*:(Expr*)(n), SelectorNode*:(Expr*)(n), \
    IndexNode*:(Expr*)(n), SliceNode*:(Expr*)(n), IfNode*:(Expr*)(n), Expr*:(Expr*)(n), \
    Node*: ({ assert_is_Expr(n); (Expr*)(n); }))
  #define as_const_Expr(n) _Generic((n), const NilNode*:(const Expr*)(n), \
    const BoolLitNode*:(const Expr*)(n), const IntLitNode*:(const Expr*)(n), \
    const FloatLitNode*:(const Expr*)(n), const StrLitNode*:(const Expr*)(n), \
    const struct LitExpr*:(const Expr*)(n), const IdNode*:(const Expr*)(n), \
    const BinOpNode*:(const Expr*)(n), const PrefixOpNode*:(const Expr*)(n), \
    const PostfixOpNode*:(const Expr*)(n), const struct UnaryOpNode*:(const Expr*)(n), \
    const ReturnNode*:(const Expr*)(n), const AssignNode*:(const Expr*)(n), \
    const TupleNode*:(const Expr*)(n), const ArrayNode*:(const Expr*)(n), \
    const struct ListExprNode*:(const Expr*)(n), const BlockNode*:(const Expr*)(n), \
    const FunNode*:(const Expr*)(n), const MacroNode*:(const Expr*)(n), \
    const CallNode*:(const Expr*)(n), const TypeCastNode*:(const Expr*)(n), \
    const ConstNode*:(const Expr*)(n), const VarNode*:(const Expr*)(n), \
    const ParamNode*:(const Expr*)(n), const MacroParamNode*:(const Expr*)(n), \
    const struct LocalNode*:(const Expr*)(n), const RefNode*:(const Expr*)(n), \
    const NamedArgNode*:(const Expr*)(n), const SelectorNode*:(const Expr*)(n), \
    const IndexNode*:(const Expr*)(n), const SliceNode*:(const Expr*)(n), \
    const IfNode*:(const Expr*)(n), const Expr*:(const Expr*)(n), \
    const Node*: ({ assert_is_Expr(n); (const Expr*)(n); }))

  #define as_LitExpr(n) _Generic((n), NilNode*:(struct LitExpr*)(n), \
    BoolLitNode*:(struct LitExpr*)(n), IntLitNode*:(struct LitExpr*)(n), \
    FloatLitNode*:(struct LitExpr*)(n), StrLitNode*:(struct LitExpr*)(n), \
    struct LitExpr*:(struct LitExpr*)(n), \
    Node*: ({ assert_is_LitExpr(n); (struct LitExpr*)(n); }))
  #define as_const_LitExpr(n) _Generic((n), const NilNode*:(const struct LitExpr*)(n), \
    const BoolLitNode*:(const struct LitExpr*)(n), \
    const IntLitNode*:(const struct LitExpr*)(n), \
    const FloatLitNode*:(const struct LitExpr*)(n), \
    const StrLitNode*:(const struct LitExpr*)(n), \
    const struct LitExpr*:(const struct LitExpr*)(n), \
    const Node*: ({ assert_is_LitExpr(n); (const struct LitExpr*)(n); }))

  #define as_UnaryOpNode(n) _Generic((n), PrefixOpNode*:(struct UnaryOpNode*)(n), \
    PostfixOpNode*:(struct UnaryOpNode*)(n), \
    struct UnaryOpNode*:(struct UnaryOpNode*)(n), \
    Node*: ({ assert_is_UnaryOpNode(n); (struct UnaryOpNode*)(n); }))
  #define as_const_UnaryOpNode(n) _Generic((n), \
    const PrefixOpNode*:(const struct UnaryOpNode*)(n), \
    const PostfixOpNode*:(const struct UnaryOpNode*)(n), \
    const struct UnaryOpNode*:(const struct UnaryOpNode*)(n), \
    const Node*: ({ assert_is_UnaryOpNode(n); (const struct UnaryOpNode*)(n); }))

  #define as_ListExprNode(n) _Generic((n), TupleNode*:(struct ListExprNode*)(n), \
    ArrayNode*:(struct ListExprNode*)(n), \
    struct ListExprNode*:(struct ListExprNode*)(n), \
    Node*: ({ assert_is_ListExprNode(n); (struct ListExprNode*)(n); }))
  #define as_const_ListExprNode(n) _Generic((n), \
    const TupleNode*:(const struct ListExprNode*)(n), \
    const ArrayNode*:(const struct ListExprNode*)(n), \
    const struct ListExprNode*:(const struct ListExprNode*)(n), \
    const Node*: ({ assert_is_ListExprNode(n); (const struct ListExprNode*)(n); }))

  #define as_LocalNode(n) _Generic((n), ConstNode*:(struct LocalNode*)(n), \
    VarNode*:(struct LocalNode*)(n), ParamNode*:(struct LocalNode*)(n), \
    MacroParamNode*:(struct LocalNode*)(n), struct LocalNode*:(struct LocalNode*)(n), \
    Node*: ({ assert_is_LocalNode(n); (struct LocalNode*)(n); }))
  #define as_const_LocalNode(n) _Generic((n), \
    const ConstNode*:(const struct LocalNode*)(n), \
    const VarNode*:(const struct LocalNode*)(n), \
    const ParamNode*:(const struct LocalNode*)(n), \
    const MacroParamNode*:(const struct LocalNode*)(n), \
    const struct LocalNode*:(const struct LocalNode*)(n), \
    const Node*: ({ assert_is_LocalNode(n); (const struct LocalNode*)(n); }))

  #define as_Type(n) _Generic((n), TypeTypeNode*:(Type*)(n), NamedTypeNode*:(Type*)(n), \
    AliasTypeNode*:(Type*)(n), RefTypeNode*:(Type*)(n), BasicTypeNode*:(Type*)(n), \
    ArrayTypeNode*:(Type*)(n), TupleTypeNode*:(Type*)(n), StructTypeNode*:(Type*)(n), \
    FunTypeNode*:(Type*)(n), Type*:(Type*)(n), \
    Node*: ({ assert_is_Type(n); (Type*)(n); }))
  #define as_const_Type(n) _Generic((n), const TypeTypeNode*:(const Type*)(n), \
    const NamedTypeNode*:(const Type*)(n), const AliasTypeNode*:(const Type*)(n), \
    const RefTypeNode*:(const Type*)(n), const BasicTypeNode*:(const Type*)(n), \
    const ArrayTypeNode*:(const Type*)(n), const TupleTypeNode*:(const Type*)(n), \
    const StructTypeNode*:(const Type*)(n), const FunTypeNode*:(const Type*)(n), \
    const Type*:(const Type*)(n), \
    const Node*: ({ assert_is_Type(n); (const Type*)(n); }))

#else // !defined(DEBUG)
  #define as_Node(n) ((Node*)(n))
  #define as_const_Node(n) ((const Node*)(n))
  #define as_BadNode(n) ((BadNode*)(n))
  #define as_const_BadNode(n) ((const BadNode*)(n))
  #define as_FieldNode(n) ((FieldNode*)(n))
  #define as_const_FieldNode(n) ((const FieldNode*)(n))
  #define as_PkgNode(n) ((PkgNode*)(n))
  #define as_const_PkgNode(n) ((const PkgNode*)(n))
  #define as_FileNode(n) ((FileNode*)(n))
  #define as_const_FileNode(n) ((const FileNode*)(n))
  #define as_CommentNode(n) ((CommentNode*)(n))
  #define as_const_CommentNode(n) ((const CommentNode*)(n))
  #define as_NilNode(n) ((NilNode*)(n))
  #define as_const_NilNode(n) ((const NilNode*)(n))
  #define as_BoolLitNode(n) ((BoolLitNode*)(n))
  #define as_const_BoolLitNode(n) ((const BoolLitNode*)(n))
  #define as_IntLitNode(n) ((IntLitNode*)(n))
  #define as_const_IntLitNode(n) ((const IntLitNode*)(n))
  #define as_FloatLitNode(n) ((FloatLitNode*)(n))
  #define as_const_FloatLitNode(n) ((const FloatLitNode*)(n))
  #define as_StrLitNode(n) ((StrLitNode*)(n))
  #define as_const_StrLitNode(n) ((const StrLitNode*)(n))
  #define as_IdNode(n) ((IdNode*)(n))
  #define as_const_IdNode(n) ((const IdNode*)(n))
  #define as_BinOpNode(n) ((BinOpNode*)(n))
  #define as_const_BinOpNode(n) ((const BinOpNode*)(n))
  #define as_PrefixOpNode(n) ((PrefixOpNode*)(n))
  #define as_const_PrefixOpNode(n) ((const PrefixOpNode*)(n))
  #define as_PostfixOpNode(n) ((PostfixOpNode*)(n))
  #define as_const_PostfixOpNode(n) ((const PostfixOpNode*)(n))
  #define as_ReturnNode(n) ((ReturnNode*)(n))
  #define as_const_ReturnNode(n) ((const ReturnNode*)(n))
  #define as_AssignNode(n) ((AssignNode*)(n))
  #define as_const_AssignNode(n) ((const AssignNode*)(n))
  #define as_TupleNode(n) ((TupleNode*)(n))
  #define as_const_TupleNode(n) ((const TupleNode*)(n))
  #define as_ArrayNode(n) ((ArrayNode*)(n))
  #define as_const_ArrayNode(n) ((const ArrayNode*)(n))
  #define as_BlockNode(n) ((BlockNode*)(n))
  #define as_const_BlockNode(n) ((const BlockNode*)(n))
  #define as_FunNode(n) ((FunNode*)(n))
  #define as_const_FunNode(n) ((const FunNode*)(n))
  #define as_MacroNode(n) ((MacroNode*)(n))
  #define as_const_MacroNode(n) ((const MacroNode*)(n))
  #define as_CallNode(n) ((CallNode*)(n))
  #define as_const_CallNode(n) ((const CallNode*)(n))
  #define as_TypeCastNode(n) ((TypeCastNode*)(n))
  #define as_const_TypeCastNode(n) ((const TypeCastNode*)(n))
  #define as_ConstNode(n) ((ConstNode*)(n))
  #define as_const_ConstNode(n) ((const ConstNode*)(n))
  #define as_VarNode(n) ((VarNode*)(n))
  #define as_const_VarNode(n) ((const VarNode*)(n))
  #define as_ParamNode(n) ((ParamNode*)(n))
  #define as_const_ParamNode(n) ((const ParamNode*)(n))
  #define as_MacroParamNode(n) ((MacroParamNode*)(n))
  #define as_const_MacroParamNode(n) ((const MacroParamNode*)(n))
  #define as_RefNode(n) ((RefNode*)(n))
  #define as_const_RefNode(n) ((const RefNode*)(n))
  #define as_NamedArgNode(n) ((NamedArgNode*)(n))
  #define as_const_NamedArgNode(n) ((const NamedArgNode*)(n))
  #define as_SelectorNode(n) ((SelectorNode*)(n))
  #define as_const_SelectorNode(n) ((const SelectorNode*)(n))
  #define as_IndexNode(n) ((IndexNode*)(n))
  #define as_const_IndexNode(n) ((const IndexNode*)(n))
  #define as_SliceNode(n) ((SliceNode*)(n))
  #define as_const_SliceNode(n) ((const SliceNode*)(n))
  #define as_IfNode(n) ((IfNode*)(n))
  #define as_const_IfNode(n) ((const IfNode*)(n))
  #define as_TypeTypeNode(n) ((TypeTypeNode*)(n))
  #define as_const_TypeTypeNode(n) ((const TypeTypeNode*)(n))
  #define as_NamedTypeNode(n) ((NamedTypeNode*)(n))
  #define as_const_NamedTypeNode(n) ((const NamedTypeNode*)(n))
  #define as_AliasTypeNode(n) ((AliasTypeNode*)(n))
  #define as_const_AliasTypeNode(n) ((const AliasTypeNode*)(n))
  #define as_RefTypeNode(n) ((RefTypeNode*)(n))
  #define as_const_RefTypeNode(n) ((const RefTypeNode*)(n))
  #define as_BasicTypeNode(n) ((BasicTypeNode*)(n))
  #define as_const_BasicTypeNode(n) ((const BasicTypeNode*)(n))
  #define as_ArrayTypeNode(n) ((ArrayTypeNode*)(n))
  #define as_const_ArrayTypeNode(n) ((const ArrayTypeNode*)(n))
  #define as_TupleTypeNode(n) ((TupleTypeNode*)(n))
  #define as_const_TupleTypeNode(n) ((const TupleTypeNode*)(n))
  #define as_StructTypeNode(n) ((StructTypeNode*)(n))
  #define as_const_StructTypeNode(n) ((const StructTypeNode*)(n))
  #define as_FunTypeNode(n) ((FunTypeNode*)(n))
  #define as_const_FunTypeNode(n) ((const FunTypeNode*)(n))
  #define as_Stmt(n) ((Stmt*)(n))
  #define as_const_Stmt(n) ((const Stmt*)(n))
  #define as_CUnitNode(n) ((struct CUnitNode*)(n))
  #define as_const_CUnitNode(n) ((const struct CUnitNode*)(n))
  #define as_Expr(n) ((Expr*)(n))
  #define as_const_Expr(n) ((const Expr*)(n))
  #define as_LitExpr(n) ((struct LitExpr*)(n))
  #define as_const_LitExpr(n) ((const struct LitExpr*)(n))
  #define as_UnaryOpNode(n) ((struct UnaryOpNode*)(n))
  #define as_const_UnaryOpNode(n) ((const struct UnaryOpNode*)(n))
  #define as_ListExprNode(n) ((struct ListExprNode*)(n))
  #define as_const_ListExprNode(n) ((const struct ListExprNode*)(n))
  #define as_LocalNode(n) ((struct LocalNode*)(n))
  #define as_const_LocalNode(n) ((const struct LocalNode*)(n))
  #define as_Type(n) ((Type*)(n))
  #define as_const_Type(n) ((const Type*)(n))
#endif // DEBUG

// <type>* nullable maybe_<type>(Node* n)
// const <type>* nullable maybe_<type>(const Node* n)
#define maybe_BadNode(n) (is_BadNode(n)?(BadNode*)(n):NULL)
#define maybe_FieldNode(n) (is_FieldNode(n)?(FieldNode*)(n):NULL)
#define maybe_Stmt(n) (is_Stmt(n)?as_Stmt(n):NULL)
#define maybe_CUnitNode(n) (is_CUnitNode(n)?as_CUnitNode(n):NULL)
#define maybe_PkgNode(n) (is_PkgNode(n)?(PkgNode*)(n):NULL)
#define maybe_FileNode(n) (is_FileNode(n)?(FileNode*)(n):NULL)
#define maybe_CommentNode(n) (is_CommentNode(n)?(CommentNode*)(n):NULL)
#define maybe_Expr(n) (is_Expr(n)?as_Expr(n):NULL)
#define maybe_LitExpr(n) (is_LitExpr(n)?as_LitExpr(n):NULL)
#define maybe_NilNode(n) (is_NilNode(n)?(NilNode*)(n):NULL)
#define maybe_BoolLitNode(n) (is_BoolLitNode(n)?(BoolLitNode*)(n):NULL)
#define maybe_IntLitNode(n) (is_IntLitNode(n)?(IntLitNode*)(n):NULL)
#define maybe_FloatLitNode(n) (is_FloatLitNode(n)?(FloatLitNode*)(n):NULL)
#define maybe_StrLitNode(n) (is_StrLitNode(n)?(StrLitNode*)(n):NULL)
#define maybe_IdNode(n) (is_IdNode(n)?(IdNode*)(n):NULL)
#define maybe_BinOpNode(n) (is_BinOpNode(n)?(BinOpNode*)(n):NULL)
#define maybe_UnaryOpNode(n) (is_UnaryOpNode(n)?as_UnaryOpNode(n):NULL)
#define maybe_PrefixOpNode(n) (is_PrefixOpNode(n)?(PrefixOpNode*)(n):NULL)
#define maybe_PostfixOpNode(n) (is_PostfixOpNode(n)?(PostfixOpNode*)(n):NULL)
#define maybe_ReturnNode(n) (is_ReturnNode(n)?(ReturnNode*)(n):NULL)
#define maybe_AssignNode(n) (is_AssignNode(n)?(AssignNode*)(n):NULL)
#define maybe_ListExprNode(n) (is_ListExprNode(n)?as_ListExprNode(n):NULL)
#define maybe_TupleNode(n) (is_TupleNode(n)?(TupleNode*)(n):NULL)
#define maybe_ArrayNode(n) (is_ArrayNode(n)?(ArrayNode*)(n):NULL)
#define maybe_BlockNode(n) (is_BlockNode(n)?(BlockNode*)(n):NULL)
#define maybe_FunNode(n) (is_FunNode(n)?(FunNode*)(n):NULL)
#define maybe_MacroNode(n) (is_MacroNode(n)?(MacroNode*)(n):NULL)
#define maybe_CallNode(n) (is_CallNode(n)?(CallNode*)(n):NULL)
#define maybe_TypeCastNode(n) (is_TypeCastNode(n)?(TypeCastNode*)(n):NULL)
#define maybe_LocalNode(n) (is_LocalNode(n)?as_LocalNode(n):NULL)
#define maybe_ConstNode(n) (is_ConstNode(n)?(ConstNode*)(n):NULL)
#define maybe_VarNode(n) (is_VarNode(n)?(VarNode*)(n):NULL)
#define maybe_ParamNode(n) (is_ParamNode(n)?(ParamNode*)(n):NULL)
#define maybe_MacroParamNode(n) (is_MacroParamNode(n)?(MacroParamNode*)(n):NULL)
#define maybe_RefNode(n) (is_RefNode(n)?(RefNode*)(n):NULL)
#define maybe_NamedArgNode(n) (is_NamedArgNode(n)?(NamedArgNode*)(n):NULL)
#define maybe_SelectorNode(n) (is_SelectorNode(n)?(SelectorNode*)(n):NULL)
#define maybe_IndexNode(n) (is_IndexNode(n)?(IndexNode*)(n):NULL)
#define maybe_SliceNode(n) (is_SliceNode(n)?(SliceNode*)(n):NULL)
#define maybe_IfNode(n) (is_IfNode(n)?(IfNode*)(n):NULL)
#define maybe_Type(n) (is_Type(n)?as_Type(n):NULL)
#define maybe_TypeTypeNode(n) (is_TypeTypeNode(n)?(TypeTypeNode*)(n):NULL)
#define maybe_NamedTypeNode(n) (is_NamedTypeNode(n)?(NamedTypeNode*)(n):NULL)
#define maybe_AliasTypeNode(n) (is_AliasTypeNode(n)?(AliasTypeNode*)(n):NULL)
#define maybe_RefTypeNode(n) (is_RefTypeNode(n)?(RefTypeNode*)(n):NULL)
#define maybe_BasicTypeNode(n) (is_BasicTypeNode(n)?(BasicTypeNode*)(n):NULL)
#define maybe_ArrayTypeNode(n) (is_ArrayTypeNode(n)?(ArrayTypeNode*)(n):NULL)
#define maybe_TupleTypeNode(n) (is_TupleTypeNode(n)?(TupleTypeNode*)(n):NULL)
#define maybe_StructTypeNode(n) (is_StructTypeNode(n)?(StructTypeNode*)(n):NULL)
#define maybe_FunTypeNode(n) (is_FunTypeNode(n)?(FunTypeNode*)(n):NULL)

// Type* nullable TypeOfNode(Node* n)
// Type* TypeOfNode(Type* n)
#define TypeOfNode(n) _Generic((n), const TypeTypeNode*:(const Type*)kType_type, \
  TypeTypeNode*:kType_type, const NamedTypeNode*:(const Type*)kType_type, \
  NamedTypeNode*:kType_type, const AliasTypeNode*:(const Type*)kType_type, \
  AliasTypeNode*:kType_type, const RefTypeNode*:(const Type*)kType_type, \
  RefTypeNode*:kType_type, const BasicTypeNode*:(const Type*)kType_type, \
  BasicTypeNode*:kType_type, const ArrayTypeNode*:(const Type*)kType_type, \
  ArrayTypeNode*:kType_type, const TupleTypeNode*:(const Type*)kType_type, \
  TupleTypeNode*:kType_type, const StructTypeNode*:(const Type*)kType_type, \
  StructTypeNode*:kType_type, const FunTypeNode*:(const Type*)kType_type, \
  FunTypeNode*:kType_type, const Type*:(const Type*)kType_type, Type*:kType_type, \
  const NilNode*:(const Type*)((Expr*)(n))->type, NilNode*:((Expr*)(n))->type, \
  const BoolLitNode*:(const Type*)((Expr*)(n))->type, BoolLitNode*:((Expr*)(n))->type, \
  const IntLitNode*:(const Type*)((Expr*)(n))->type, IntLitNode*:((Expr*)(n))->type, \
  const FloatLitNode*:(const Type*)((Expr*)(n))->type, FloatLitNode*:((Expr*)(n))->type, \
  const StrLitNode*:(const Type*)((Expr*)(n))->type, StrLitNode*:((Expr*)(n))->type, \
  const struct LitExpr*:(const Type*)((Expr*)(n))->type, \
  struct LitExpr*:((Expr*)(n))->type, const IdNode*:(const Type*)((Expr*)(n))->type, \
  IdNode*:((Expr*)(n))->type, const BinOpNode*:(const Type*)((Expr*)(n))->type, \
  BinOpNode*:((Expr*)(n))->type, const PrefixOpNode*:(const Type*)((Expr*)(n))->type, \
  PrefixOpNode*:((Expr*)(n))->type, \
  const PostfixOpNode*:(const Type*)((Expr*)(n))->type, \
  PostfixOpNode*:((Expr*)(n))->type, \
  const struct UnaryOpNode*:(const Type*)((Expr*)(n))->type, \
  struct UnaryOpNode*:((Expr*)(n))->type, \
  const ReturnNode*:(const Type*)((Expr*)(n))->type, ReturnNode*:((Expr*)(n))->type, \
  const AssignNode*:(const Type*)((Expr*)(n))->type, AssignNode*:((Expr*)(n))->type, \
  const TupleNode*:(const Type*)((Expr*)(n))->type, TupleNode*:((Expr*)(n))->type, \
  const ArrayNode*:(const Type*)((Expr*)(n))->type, ArrayNode*:((Expr*)(n))->type, \
  const struct ListExprNode*:(const Type*)((Expr*)(n))->type, \
  struct ListExprNode*:((Expr*)(n))->type, \
  const BlockNode*:(const Type*)((Expr*)(n))->type, BlockNode*:((Expr*)(n))->type, \
  const FunNode*:(const Type*)((Expr*)(n))->type, FunNode*:((Expr*)(n))->type, \
  const MacroNode*:(const Type*)((Expr*)(n))->type, MacroNode*:((Expr*)(n))->type, \
  const CallNode*:(const Type*)((Expr*)(n))->type, CallNode*:((Expr*)(n))->type, \
  const TypeCastNode*:(const Type*)((Expr*)(n))->type, TypeCastNode*:((Expr*)(n))->type, \
  const ConstNode*:(const Type*)((Expr*)(n))->type, ConstNode*:((Expr*)(n))->type, \
  const VarNode*:(const Type*)((Expr*)(n))->type, VarNode*:((Expr*)(n))->type, \
  const ParamNode*:(const Type*)((Expr*)(n))->type, ParamNode*:((Expr*)(n))->type, \
  const MacroParamNode*:(const Type*)((Expr*)(n))->type, \
  MacroParamNode*:((Expr*)(n))->type, \
  const struct LocalNode*:(const Type*)((Expr*)(n))->type, \
  struct LocalNode*:((Expr*)(n))->type, const RefNode*:(const Type*)((Expr*)(n))->type, \
  RefNode*:((Expr*)(n))->type, const NamedArgNode*:(const Type*)((Expr*)(n))->type, \
  NamedArgNode*:((Expr*)(n))->type, const SelectorNode*:(const Type*)((Expr*)(n))->type, \
  SelectorNode*:((Expr*)(n))->type, const IndexNode*:(const Type*)((Expr*)(n))->type, \
  IndexNode*:((Expr*)(n))->type, const SliceNode*:(const Type*)((Expr*)(n))->type, \
  SliceNode*:((Expr*)(n))->type, const IfNode*:(const Type*)((Expr*)(n))->type, \
  IfNode*:((Expr*)(n))->type, const Expr*:(const Type*)((Expr*)(n))->type, \
  Expr*:((Expr*)(n))->type, BadNode*:NULL, FieldNode*:NULL, Stmt*:NULL, \
  struct CUnitNode*:NULL, PkgNode*:NULL, FileNode*:NULL, CommentNode*:NULL, \
  const Node*: ( is_Type(n) ? (const Type*)kType_type : \
   is_Expr(n) ? (const Type*)((Expr*)(n))->type : NULL ), \
  Node*:( is_Type(n) ? kType_type : is_Expr(n) ? ((Expr*)(n))->type : NULL))

union NodeUnion {
BadNode _0; FieldNode _1; PkgNode _2; FileNode _3; CommentNode _4; NilNode _5;
  BoolLitNode _6; IntLitNode _7; FloatLitNode _8; StrLitNode _9; IdNode _10;
  BinOpNode _11; PrefixOpNode _12; PostfixOpNode _13; ReturnNode _14;
  AssignNode _15; TupleNode _16; ArrayNode _17; BlockNode _18; FunNode _19;
  MacroNode _20; CallNode _21; TypeCastNode _22; ConstNode _23; VarNode _24;
  ParamNode _25; MacroParamNode _26; RefNode _27; NamedArgNode _28;
  SelectorNode _29; IndexNode _30; SliceNode _31; IfNode _32; TypeTypeNode _33;
  NamedTypeNode _34; AliasTypeNode _35; RefTypeNode _36; BasicTypeNode _37;
  ArrayTypeNode _38; TupleTypeNode _39; StructTypeNode _40; FunTypeNode _41;
};

typedef struct ASTVisitor     ASTVisitor;
typedef struct ASTVisitorFuns ASTVisitorFuns;
typedef int(*ASTVisitorFun)(ASTVisitor*, const Node*);
struct ASTVisitor {
  ASTVisitorFun ftable[44];
};
void ASTVisitorInit(ASTVisitor*, const ASTVisitorFuns*);
// error ASTVisit(ASTVisitor* v, const NODE_TYPE* n)
#define ASTVisit(v, n) _Generic((n), \
  const BadNode*: (v)->ftable[NBad]((v),(const Node*)(n)), \
  BadNode*: (v)->ftable[NBad]((v),(const Node*)(n)), \
  const FieldNode*: (v)->ftable[NField]((v),(const Node*)(n)), \
  FieldNode*: (v)->ftable[NField]((v),(const Node*)(n)), \
  const PkgNode*: (v)->ftable[NPkg]((v),(const Node*)(n)), \
  PkgNode*: (v)->ftable[NPkg]((v),(const Node*)(n)), \
  const FileNode*: (v)->ftable[NFile]((v),(const Node*)(n)), \
  FileNode*: (v)->ftable[NFile]((v),(const Node*)(n)), \
  const CommentNode*: (v)->ftable[NComment]((v),(const Node*)(n)), \
  CommentNode*: (v)->ftable[NComment]((v),(const Node*)(n)), \
  const NilNode*: (v)->ftable[NNil]((v),(const Node*)(n)), \
  NilNode*: (v)->ftable[NNil]((v),(const Node*)(n)), \
  const BoolLitNode*: (v)->ftable[NBoolLit]((v),(const Node*)(n)), \
  BoolLitNode*: (v)->ftable[NBoolLit]((v),(const Node*)(n)), \
  const IntLitNode*: (v)->ftable[NIntLit]((v),(const Node*)(n)), \
  IntLitNode*: (v)->ftable[NIntLit]((v),(const Node*)(n)), \
  const FloatLitNode*: (v)->ftable[NFloatLit]((v),(const Node*)(n)), \
  FloatLitNode*: (v)->ftable[NFloatLit]((v),(const Node*)(n)), \
  const StrLitNode*: (v)->ftable[NStrLit]((v),(const Node*)(n)), \
  StrLitNode*: (v)->ftable[NStrLit]((v),(const Node*)(n)), \
  const IdNode*: (v)->ftable[NId]((v),(const Node*)(n)), \
  IdNode*: (v)->ftable[NId]((v),(const Node*)(n)), \
  const BinOpNode*: (v)->ftable[NBinOp]((v),(const Node*)(n)), \
  BinOpNode*: (v)->ftable[NBinOp]((v),(const Node*)(n)), \
  const PrefixOpNode*: (v)->ftable[NPrefixOp]((v),(const Node*)(n)), \
  PrefixOpNode*: (v)->ftable[NPrefixOp]((v),(const Node*)(n)), \
  const PostfixOpNode*: (v)->ftable[NPostfixOp]((v),(const Node*)(n)), \
  PostfixOpNode*: (v)->ftable[NPostfixOp]((v),(const Node*)(n)), \
  const ReturnNode*: (v)->ftable[NReturn]((v),(const Node*)(n)), \
  ReturnNode*: (v)->ftable[NReturn]((v),(const Node*)(n)), \
  const AssignNode*: (v)->ftable[NAssign]((v),(const Node*)(n)), \
  AssignNode*: (v)->ftable[NAssign]((v),(const Node*)(n)), \
  const TupleNode*: (v)->ftable[NTuple]((v),(const Node*)(n)), \
  TupleNode*: (v)->ftable[NTuple]((v),(const Node*)(n)), \
  const ArrayNode*: (v)->ftable[NArray]((v),(const Node*)(n)), \
  ArrayNode*: (v)->ftable[NArray]((v),(const Node*)(n)), \
  const BlockNode*: (v)->ftable[NBlock]((v),(const Node*)(n)), \
  BlockNode*: (v)->ftable[NBlock]((v),(const Node*)(n)), \
  const FunNode*: (v)->ftable[NFun]((v),(const Node*)(n)), \
  FunNode*: (v)->ftable[NFun]((v),(const Node*)(n)), \
  const MacroNode*: (v)->ftable[NMacro]((v),(const Node*)(n)), \
  MacroNode*: (v)->ftable[NMacro]((v),(const Node*)(n)), \
  const CallNode*: (v)->ftable[NCall]((v),(const Node*)(n)), \
  CallNode*: (v)->ftable[NCall]((v),(const Node*)(n)), \
  const TypeCastNode*: (v)->ftable[NTypeCast]((v),(const Node*)(n)), \
  TypeCastNode*: (v)->ftable[NTypeCast]((v),(const Node*)(n)), \
  const ConstNode*: (v)->ftable[NConst]((v),(const Node*)(n)), \
  ConstNode*: (v)->ftable[NConst]((v),(const Node*)(n)), \
  const VarNode*: (v)->ftable[NVar]((v),(const Node*)(n)), \
  VarNode*: (v)->ftable[NVar]((v),(const Node*)(n)), \
  const ParamNode*: (v)->ftable[NParam]((v),(const Node*)(n)), \
  ParamNode*: (v)->ftable[NParam]((v),(const Node*)(n)), \
  const MacroParamNode*: (v)->ftable[NMacroParam]((v),(const Node*)(n)), \
  MacroParamNode*: (v)->ftable[NMacroParam]((v),(const Node*)(n)), \
  const RefNode*: (v)->ftable[NRef]((v),(const Node*)(n)), \
  RefNode*: (v)->ftable[NRef]((v),(const Node*)(n)), \
  const NamedArgNode*: (v)->ftable[NNamedArg]((v),(const Node*)(n)), \
  NamedArgNode*: (v)->ftable[NNamedArg]((v),(const Node*)(n)), \
  const SelectorNode*: (v)->ftable[NSelector]((v),(const Node*)(n)), \
  SelectorNode*: (v)->ftable[NSelector]((v),(const Node*)(n)), \
  const IndexNode*: (v)->ftable[NIndex]((v),(const Node*)(n)), \
  IndexNode*: (v)->ftable[NIndex]((v),(const Node*)(n)), \
  const SliceNode*: (v)->ftable[NSlice]((v),(const Node*)(n)), \
  SliceNode*: (v)->ftable[NSlice]((v),(const Node*)(n)), \
  const IfNode*: (v)->ftable[NIf]((v),(const Node*)(n)), \
  IfNode*: (v)->ftable[NIf]((v),(const Node*)(n)), \
  const TypeTypeNode*: (v)->ftable[NTypeType]((v),(const Node*)(n)), \
  TypeTypeNode*: (v)->ftable[NTypeType]((v),(const Node*)(n)), \
  const NamedTypeNode*: (v)->ftable[NNamedType]((v),(const Node*)(n)), \
  NamedTypeNode*: (v)->ftable[NNamedType]((v),(const Node*)(n)), \
  const AliasTypeNode*: (v)->ftable[NAliasType]((v),(const Node*)(n)), \
  AliasTypeNode*: (v)->ftable[NAliasType]((v),(const Node*)(n)), \
  const RefTypeNode*: (v)->ftable[NRefType]((v),(const Node*)(n)), \
  RefTypeNode*: (v)->ftable[NRefType]((v),(const Node*)(n)), \
  const BasicTypeNode*: (v)->ftable[NBasicType]((v),(const Node*)(n)), \
  BasicTypeNode*: (v)->ftable[NBasicType]((v),(const Node*)(n)), \
  const ArrayTypeNode*: (v)->ftable[NArrayType]((v),(const Node*)(n)), \
  ArrayTypeNode*: (v)->ftable[NArrayType]((v),(const Node*)(n)), \
  const TupleTypeNode*: (v)->ftable[NTupleType]((v),(const Node*)(n)), \
  TupleTypeNode*: (v)->ftable[NTupleType]((v),(const Node*)(n)), \
  const StructTypeNode*: (v)->ftable[NStructType]((v),(const Node*)(n)), \
  StructTypeNode*: (v)->ftable[NStructType]((v),(const Node*)(n)), \
  const FunTypeNode*: (v)->ftable[NFunType]((v),(const Node*)(n)), \
  FunTypeNode*: (v)->ftable[NFunType]((v),(const Node*)(n)), \
  const Node*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  Node*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const Stmt*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  Stmt*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const struct CUnitNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  struct CUnitNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const Expr*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  Expr*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const struct LitExpr*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  struct LitExpr*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const struct UnaryOpNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  struct UnaryOpNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const struct ListExprNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  struct ListExprNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const struct LocalNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  struct LocalNode*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  const Type*: (v)->ftable[(n)->kind]((v),(const Node*)(n)), \
  Type*: (v)->ftable[(n)->kind]((v),(const Node*)(n)))

struct ASTVisitorFuns {
  error(*nullable Bad)(ASTVisitor*, const BadNode*);
  error(*nullable Field)(ASTVisitor*, const FieldNode*);
  error(*nullable Pkg)(ASTVisitor*, const PkgNode*);
  error(*nullable File)(ASTVisitor*, const FileNode*);
  error(*nullable Comment)(ASTVisitor*, const CommentNode*);
  error(*nullable Nil)(ASTVisitor*, const NilNode*);
  error(*nullable BoolLit)(ASTVisitor*, const BoolLitNode*);
  error(*nullable IntLit)(ASTVisitor*, const IntLitNode*);
  error(*nullable FloatLit)(ASTVisitor*, const FloatLitNode*);
  error(*nullable StrLit)(ASTVisitor*, const StrLitNode*);
  error(*nullable Id)(ASTVisitor*, const IdNode*);
  error(*nullable BinOp)(ASTVisitor*, const BinOpNode*);
  error(*nullable PrefixOp)(ASTVisitor*, const PrefixOpNode*);
  error(*nullable PostfixOp)(ASTVisitor*, const PostfixOpNode*);
  error(*nullable Return)(ASTVisitor*, const ReturnNode*);
  error(*nullable Assign)(ASTVisitor*, const AssignNode*);
  error(*nullable Tuple)(ASTVisitor*, const TupleNode*);
  error(*nullable Array)(ASTVisitor*, const ArrayNode*);
  error(*nullable Block)(ASTVisitor*, const BlockNode*);
  error(*nullable Fun)(ASTVisitor*, const FunNode*);
  error(*nullable Macro)(ASTVisitor*, const MacroNode*);
  error(*nullable Call)(ASTVisitor*, const CallNode*);
  error(*nullable TypeCast)(ASTVisitor*, const TypeCastNode*);
  error(*nullable Const)(ASTVisitor*, const ConstNode*);
  error(*nullable Var)(ASTVisitor*, const VarNode*);
  error(*nullable Param)(ASTVisitor*, const ParamNode*);
  error(*nullable MacroParam)(ASTVisitor*, const MacroParamNode*);
  error(*nullable Ref)(ASTVisitor*, const RefNode*);
  error(*nullable NamedArg)(ASTVisitor*, const NamedArgNode*);
  error(*nullable Selector)(ASTVisitor*, const SelectorNode*);
  error(*nullable Index)(ASTVisitor*, const IndexNode*);
  error(*nullable Slice)(ASTVisitor*, const SliceNode*);
  error(*nullable If)(ASTVisitor*, const IfNode*);
  error(*nullable TypeType)(ASTVisitor*, const TypeTypeNode*);
  error(*nullable NamedType)(ASTVisitor*, const NamedTypeNode*);
  error(*nullable AliasType)(ASTVisitor*, const AliasTypeNode*);
  error(*nullable RefType)(ASTVisitor*, const RefTypeNode*);
  error(*nullable BasicType)(ASTVisitor*, const BasicTypeNode*);
  error(*nullable ArrayType)(ASTVisitor*, const ArrayTypeNode*);
  error(*nullable TupleType)(ASTVisitor*, const TupleTypeNode*);
  error(*nullable StructType)(ASTVisitor*, const StructTypeNode*);
  error(*nullable FunType)(ASTVisitor*, const FunTypeNode*);

  // class-level visitors called for nodes without specific visitors
  error(*nullable Stmt)(ASTVisitor*, const Stmt*);
  error(*nullable CUnit)(ASTVisitor*, const struct CUnitNode*);
  error(*nullable Expr)(ASTVisitor*, const Expr*);
  error(*nullable LitExpr)(ASTVisitor*, const struct LitExpr*);
  error(*nullable UnaryOp)(ASTVisitor*, const struct UnaryOpNode*);
  error(*nullable ListExpr)(ASTVisitor*, const struct ListExprNode*);
  error(*nullable Local)(ASTVisitor*, const struct LocalNode*);
  error(*nullable Type)(ASTVisitor*, const Type*);

  // catch-all fallback visitor
  error(*nullable Node)(ASTVisitor*, const Node*);
};

ASSUME_NONNULL_END
